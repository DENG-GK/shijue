# 简单阈值

## 1. cv2.threshold() 函数详解

### 1.1 函数语法

`cv2.threshold()` 是OpenCV中进行简单阈值处理的核心函数：

```python
retval, dst = cv2.threshold(src, thresh, maxval, type)
```

**参数说明：**

| 参数 | 类型 | 说明 |
|------|------|------|
| `src` | numpy.ndarray | 输入图像，必须是单通道灰度图像 |
| `thresh` | float | 阈值，用于判断的临界值 |
| `maxval` | float | 最大值，当满足条件时赋予的值（通常为255） |
| `type` | int | 阈值类型，决定如何处理像素 |

**返回值说明：**

| 返回值 | 类型 | 说明 |
|--------|------|------|
| `retval` | float | 实际使用的阈值（使用Otsu或Triangle时有意义） |
| `dst` | numpy.ndarray | 输出图像，与输入图像尺寸和类型相同 |

### 1.2 阈值类型常量

```python
"""
示例1：查看所有阈值类型常量
"""
import cv2

# 阈值类型及其数值
threshold_types = {
    'THRESH_BINARY': cv2.THRESH_BINARY,
    'THRESH_BINARY_INV': cv2.THRESH_BINARY_INV,
    'THRESH_TRUNC': cv2.THRESH_TRUNC,
    'THRESH_TOZERO': cv2.THRESH_TOZERO,
    'THRESH_TOZERO_INV': cv2.THRESH_TOZERO_INV,
    'THRESH_OTSU': cv2.THRESH_OTSU,
    'THRESH_TRIANGLE': cv2.THRESH_TRIANGLE,
}

print("OpenCV 阈值类型常量：")
print("-" * 40)
for name, value in threshold_types.items():
    print(f"{name:20s} = {value}")
print("-" * 40)
print("\n提示：OTSU和TRIANGLE可以与其他类型组合使用")
print("例如：cv2.THRESH_BINARY + cv2.THRESH_OTSU")
```

输出：
```
OpenCV 阈值类型常量：
----------------------------------------
THRESH_BINARY        = 0
THRESH_BINARY_INV    = 1
THRESH_TRUNC         = 2
THRESH_TOZERO        = 3
THRESH_TOZERO_INV    = 4
THRESH_OTSU          = 8
THRESH_TRIANGLE      = 16
----------------------------------------
```

---

## 2. 五种基本阈值类型实战

### 2.1 THRESH_BINARY（二值化）

最常用的阈值类型，将图像转换为黑白二值图。

**公式：**
```
dst(x,y) = maxval  if src(x,y) > thresh
         = 0       otherwise
```

```python
"""
示例2：THRESH_BINARY 二值化
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像：包含不同灰度级的区域
def create_test_image():
    img = np.zeros((300, 400), dtype=np.uint8)

    # 创建5个不同灰度级的区域
    regions = [(50, 50), (100, 130), (150, 210), (200, 290), (250, 370)]
    for gray_value, x in regions:
        cv2.rectangle(img, (x, 50), (x+60, 250), gray_value, -1)

    return img

img = create_test_image()

# 使用不同阈值进行二值化
thresholds = [80, 120, 160, 200]

fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(img, cmap='gray')
axes[0].set_title('Original\n(Gray values: 50, 100, 150, 200, 250)', fontsize=10)
axes[0].axis('off')

# 不同阈值的结果
for i, T in enumerate(thresholds, 1):
    ret, binary = cv2.threshold(img, T, 255, cv2.THRESH_BINARY)
    axes[i].imshow(binary, cmap='gray')
    axes[i].set_title(f'THRESH_BINARY\nT = {T}', fontsize=10)
    axes[i].axis('off')

# 隐藏最后一个空白子图
axes[5].axis('off')

plt.tight_layout()
plt.show()

# 详细打印某个阈值的处理结果
T = 120
ret, binary = cv2.threshold(img, T, 255, cv2.THRESH_BINARY)
print(f"阈值 T = {T} 的处理结果：")
print(f"- 返回值 retval = {ret}")
print(f"- 灰度值 50  (< {T}): 变为 0")
print(f"- 灰度值 100 (< {T}): 变为 0")
print(f"- 灰度值 150 (> {T}): 变为 255")
print(f"- 灰度值 200 (> {T}): 变为 255")
print(f"- 灰度值 250 (> {T}): 变为 255")
```

### 2.2 THRESH_BINARY_INV（反二值化）

与THRESH_BINARY相反，大于阈值的变黑，小于等于阈值的变白。

**公式：**
```
dst(x,y) = 0       if src(x,y) > thresh
         = maxval  otherwise
```

```python
"""
示例3：THRESH_BINARY vs THRESH_BINARY_INV 对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建包含文字的模拟图像（白底黑字）
def create_text_image():
    img = np.ones((200, 400), dtype=np.uint8) * 240  # 浅色背景

    # 模拟文字（深色）
    cv2.putText(img, "Hello OpenCV!", (30, 120),
                cv2.FONT_HERSHEY_SIMPLEX, 2, 30, 3)

    return img

img = create_text_image()
T = 128

# 两种二值化方式
ret1, binary = cv2.threshold(img, T, 255, cv2.THRESH_BINARY)
ret2, binary_inv = cv2.threshold(img, T, 255, cv2.THRESH_BINARY_INV)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(15, 4))

axes[0].imshow(img, cmap='gray')
axes[0].set_title('Original Image\n(Light background, dark text)', fontsize=11)
axes[0].axis('off')

axes[1].imshow(binary, cmap='gray')
axes[1].set_title('THRESH_BINARY\n(Dark text becomes black)', fontsize=11)
axes[1].axis('off')

axes[2].imshow(binary_inv, cmap='gray')
axes[2].set_title('THRESH_BINARY_INV\n(Dark text becomes white)', fontsize=11)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print("应用场景对比：")
print("- THRESH_BINARY: 适合提取浅色目标（目标比背景亮）")
print("- THRESH_BINARY_INV: 适合提取深色目标（目标比背景暗，如文字）")
```

### 2.3 THRESH_TRUNC（截断）

大于阈值的像素被截断为阈值，小于等于阈值的保持不变。

**公式：**
```
dst(x,y) = thresh  if src(x,y) > thresh
         = src(x,y) otherwise
```

```python
"""
示例4：THRESH_TRUNC 截断阈值
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建渐变图像
gradient = np.tile(np.arange(256, dtype=np.uint8), (100, 1))

# 不同阈值的截断效果
thresholds = [64, 128, 192]

fig, axes = plt.subplots(2, 2, figsize=(12, 8))
axes = axes.flatten()

# 原图
axes[0].imshow(gradient, cmap='gray')
axes[0].set_title('Original Gradient (0 → 255)', fontsize=11)
axes[0].set_xlabel('Pixel Value')
axes[0].set_yticks([])

# 不同阈值的截断效果
for i, T in enumerate(thresholds, 1):
    ret, result = cv2.threshold(gradient, T, 255, cv2.THRESH_TRUNC)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'THRESH_TRUNC (T={T})\nMax value becomes {T}', fontsize=11)
    axes[i].set_xlabel('Pixel Value')
    axes[i].set_yticks([])
    axes[i].axvline(x=T, color='r', linestyle='--', linewidth=2)

plt.tight_layout()
plt.show()

# 绘制像素值变化曲线
fig, ax = plt.subplots(figsize=(10, 5))

x = np.arange(256)
ax.plot(x, x, 'b-', label='Original', linewidth=2)

for T in thresholds:
    y = np.minimum(x, T)
    ax.plot(x, y, '--', label=f'TRUNC T={T}', linewidth=2)

ax.set_xlabel('Input Pixel Value', fontsize=12)
ax.set_ylabel('Output Pixel Value', fontsize=12)
ax.set_title('THRESH_TRUNC: Pixel Value Transformation', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(0, 255)
ax.set_ylim(0, 255)

plt.tight_layout()
plt.show()

print("THRESH_TRUNC 应用场景：")
print("- 限制图像的最大亮度")
print("- 处理过曝图像")
print("- 高光区域压缩")
```

### 2.4 THRESH_TOZERO（置零）

小于等于阈值的像素变为0，大于阈值的保持不变。

**公式：**
```
dst(x,y) = src(x,y)  if src(x,y) > thresh
         = 0         otherwise
```

```python
"""
示例5：THRESH_TOZERO 置零阈值
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像
gradient = np.tile(np.arange(256, dtype=np.uint8), (100, 1))

thresholds = [64, 128, 192]

fig, axes = plt.subplots(2, 2, figsize=(12, 8))
axes = axes.flatten()

# 原图
axes[0].imshow(gradient, cmap='gray')
axes[0].set_title('Original Gradient (0 → 255)', fontsize=11)
axes[0].set_xlabel('Pixel Value')
axes[0].set_yticks([])

# 不同阈值的置零效果
for i, T in enumerate(thresholds, 1):
    ret, result = cv2.threshold(gradient, T, 255, cv2.THRESH_TOZERO)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'THRESH_TOZERO (T={T})\nValues ≤ {T} become 0', fontsize=11)
    axes[i].set_xlabel('Pixel Value')
    axes[i].set_yticks([])
    axes[i].axvline(x=T, color='r', linestyle='--', linewidth=2)

plt.tight_layout()
plt.show()

# 绘制像素值变化曲线
fig, ax = plt.subplots(figsize=(10, 5))

x = np.arange(256)
ax.plot(x, x, 'b-', label='Original', linewidth=2)

for T in thresholds:
    y = np.where(x > T, x, 0)
    ax.plot(x, y, '--', label=f'TOZERO T={T}', linewidth=2)

ax.set_xlabel('Input Pixel Value', fontsize=12)
ax.set_ylabel('Output Pixel Value', fontsize=12)
ax.set_title('THRESH_TOZERO: Pixel Value Transformation', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(0, 255)
ax.set_ylim(0, 255)

plt.tight_layout()
plt.show()

print("THRESH_TOZERO 应用场景：")
print("- 去除图像中的暗部细节")
print("- 提取高亮度区域同时保留原始亮度信息")
print("- 背景抑制")
```

### 2.5 THRESH_TOZERO_INV（反置零）

大于阈值的像素变为0，小于等于阈值的保持不变。

**公式：**
```
dst(x,y) = 0         if src(x,y) > thresh
         = src(x,y)  otherwise
```

```python
"""
示例6：THRESH_TOZERO_INV 反置零阈值
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像
gradient = np.tile(np.arange(256, dtype=np.uint8), (100, 1))

thresholds = [64, 128, 192]

fig, axes = plt.subplots(2, 2, figsize=(12, 8))
axes = axes.flatten()

# 原图
axes[0].imshow(gradient, cmap='gray')
axes[0].set_title('Original Gradient (0 → 255)', fontsize=11)
axes[0].set_xlabel('Pixel Value')
axes[0].set_yticks([])

# 不同阈值的反置零效果
for i, T in enumerate(thresholds, 1):
    ret, result = cv2.threshold(gradient, T, 255, cv2.THRESH_TOZERO_INV)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'THRESH_TOZERO_INV (T={T})\nValues > {T} become 0', fontsize=11)
    axes[i].set_xlabel('Pixel Value')
    axes[i].set_yticks([])
    axes[i].axvline(x=T, color='r', linestyle='--', linewidth=2)

plt.tight_layout()
plt.show()

# 绘制像素值变化曲线
fig, ax = plt.subplots(figsize=(10, 5))

x = np.arange(256)
ax.plot(x, x, 'b-', label='Original', linewidth=2)

for T in thresholds:
    y = np.where(x > T, 0, x)
    ax.plot(x, y, '--', label=f'TOZERO_INV T={T}', linewidth=2)

ax.set_xlabel('Input Pixel Value', fontsize=12)
ax.set_ylabel('Output Pixel Value', fontsize=12)
ax.set_title('THRESH_TOZERO_INV: Pixel Value Transformation', fontsize=14)
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_xlim(0, 255)
ax.set_ylim(0, 255)

plt.tight_layout()
plt.show()

print("THRESH_TOZERO_INV 应用场景：")
print("- 去除图像中的高光区域")
print("- 提取暗部细节同时保留原始亮度信息")
print("- 高光抑制")
```

---

## 3. 综合对比与选择指南

### 3.1 五种类型一览

```python
"""
示例7：五种阈值类型综合对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建一个有代表性的测试图像
def create_comprehensive_test_image():
    img = np.zeros((250, 350), dtype=np.uint8)

    # 背景渐变
    for i in range(250):
        img[i, :] = int(30 + i * 0.4)

    # 添加不同亮度的形状
    cv2.circle(img, (80, 125), 50, 220, -1)   # 亮圆
    cv2.rectangle(img, (150, 50), (250, 200), 150, -1)  # 中灰矩形
    cv2.ellipse(img, (300, 125), (30, 60), 0, 0, 360, 80, -1)  # 暗椭圆

    return img

img = create_comprehensive_test_image()
T = 120

# 五种阈值类型
types_info = [
    (cv2.THRESH_BINARY, 'BINARY', '>T→255, ≤T→0'),
    (cv2.THRESH_BINARY_INV, 'BINARY_INV', '>T→0, ≤T→255'),
    (cv2.THRESH_TRUNC, 'TRUNC', '>T→T, ≤T→keep'),
    (cv2.THRESH_TOZERO, 'TOZERO', '>T→keep, ≤T→0'),
    (cv2.THRESH_TOZERO_INV, 'TOZERO_INV', '>T→0, ≤T→keep'),
]

# 可视化
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(img, cmap='gray')
axes[0].set_title(f'Original Image\nThreshold T = {T}', fontsize=12)
axes[0].axis('off')

# 各种阈值类型
for i, (thresh_type, name, formula) in enumerate(types_info, 1):
    ret, result = cv2.threshold(img, T, 255, thresh_type)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'{name}\n{formula}', fontsize=11)
    axes[i].axis('off')

plt.tight_layout()
plt.savefig('threshold_comprehensive_comparison.png', dpi=150, bbox_inches='tight')
plt.show()
```

### 3.2 选择指南

```python
"""
示例8：阈值类型选择指南
"""

threshold_selection_guide = """
╔══════════════════════════════════════════════════════════════════════════════╗
║                        阈值类型选择指南                                       ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  1. 需要纯黑白二值图像？                                                      ║
║     ├── 目标比背景亮 → THRESH_BINARY                                         ║
║     └── 目标比背景暗 → THRESH_BINARY_INV                                     ║
║                                                                              ║
║  2. 需要保留原始灰度信息？                                                    ║
║     ├── 只保留亮部 → THRESH_TOZERO                                           ║
║     ├── 只保留暗部 → THRESH_TOZERO_INV                                       ║
║     └── 限制最大亮度 → THRESH_TRUNC                                          ║
║                                                                              ║
║  3. 常见应用场景：                                                           ║
║     ├── OCR文字识别 → THRESH_BINARY 或 THRESH_BINARY_INV                     ║
║     ├── 目标检测 → THRESH_BINARY + 轮廓检测                                  ║
║     ├── 图像增强 → THRESH_TRUNC（高光压缩）                                   ║
║     ├── 背景去除 → THRESH_TOZERO                                             ║
║     └── 高光去除 → THRESH_TOZERO_INV                                         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
"""

print(threshold_selection_guide)
```

---

## 4. 实用技巧

### 4.1 阈值选择技巧

```python
"""
示例9：阈值选择辅助工具
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def suggest_threshold(image):
    """
    根据图像直方图建议阈值
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 方法1：使用均值
    mean_val = np.mean(gray)

    # 方法2：使用中值
    median_val = np.median(gray)

    # 方法3：使用Otsu自动阈值
    otsu_thresh, _ = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # 方法4：使用Triangle自动阈值
    triangle_thresh, _ = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_TRIANGLE)

    # 计算直方图
    hist = cv2.calcHist([gray], [0], None, [256], [0, 256]).flatten()

    # 可视化
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # 显示图像
    axes[0].imshow(gray, cmap='gray')
    axes[0].set_title('Input Image', fontsize=12)
    axes[0].axis('off')

    # 显示直方图和建议阈值
    axes[1].plot(hist, 'b-', linewidth=1)
    axes[1].axvline(x=mean_val, color='r', linestyle='-', label=f'Mean: {mean_val:.0f}')
    axes[1].axvline(x=median_val, color='g', linestyle='--', label=f'Median: {median_val:.0f}')
    axes[1].axvline(x=otsu_thresh, color='m', linestyle='-.', label=f'Otsu: {otsu_thresh:.0f}')
    axes[1].axvline(x=triangle_thresh, color='c', linestyle=':', label=f'Triangle: {triangle_thresh:.0f}')
    axes[1].set_title('Histogram with Suggested Thresholds', fontsize=12)
    axes[1].set_xlabel('Pixel Value')
    axes[1].set_ylabel('Frequency')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

    print("\n阈值建议：")
    print(f"  均值法:     {mean_val:.0f}")
    print(f"  中值法:     {median_val:.0f}")
    print(f"  Otsu法:     {otsu_thresh:.0f}")
    print(f"  Triangle法: {triangle_thresh:.0f}")

    return {
        'mean': mean_val,
        'median': median_val,
        'otsu': otsu_thresh,
        'triangle': triangle_thresh
    }

# 创建测试图像
test_img = np.zeros((300, 400), dtype=np.uint8)
test_img[:, :200] = np.random.normal(70, 20, (300, 200)).clip(0, 255)
test_img[:, 200:] = np.random.normal(180, 20, (300, 200)).clip(0, 255)
test_img = test_img.astype(np.uint8)

# 获取阈值建议
thresholds = suggest_threshold(test_img)
```

### 4.2 批量处理多个阈值

```python
"""
示例10：批量阈值处理与对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def batch_threshold(image, thresholds, thresh_type=cv2.THRESH_BINARY):
    """
    使用多个阈值批量处理图像
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    results = []
    for T in thresholds:
        _, binary = cv2.threshold(gray, T, 255, thresh_type)
        results.append((T, binary))

    return results

def visualize_batch_results(original, results, title="Batch Threshold Results"):
    """
    可视化批量处理结果
    """
    n = len(results) + 1
    cols = min(4, n)
    rows = (n + cols - 1) // cols

    fig, axes = plt.subplots(rows, cols, figsize=(4*cols, 4*rows))
    if rows == 1:
        axes = [axes] if cols == 1 else axes
    else:
        axes = axes.flatten()

    # 原图
    axes[0].imshow(original, cmap='gray')
    axes[0].set_title('Original', fontsize=11)
    axes[0].axis('off')

    # 结果
    for i, (T, result) in enumerate(results, 1):
        if i < len(axes):
            axes[i].imshow(result, cmap='gray')
            axes[i].set_title(f'T = {T}', fontsize=11)
            axes[i].axis('off')

    # 隐藏多余的子图
    for i in range(n, len(axes)):
        axes[i].axis('off')

    plt.suptitle(title, fontsize=14)
    plt.tight_layout()
    plt.show()

# 创建测试图像
img = np.zeros((200, 300), dtype=np.uint8)
cv2.circle(img, (150, 100), 80, 200, -1)
noise = np.random.normal(0, 30, img.shape)
img = np.clip(img + noise, 0, 255).astype(np.uint8)

# 批量处理
thresholds = [50, 80, 110, 140, 170, 200]
results = batch_threshold(img, thresholds)

# 可视化
visualize_batch_results(img, results, "Effect of Different Thresholds")
```

### 4.3 处理彩色图像

```python
"""
示例11：彩色图像的阈值处理
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def threshold_color_image(image, thresh, method='gray'):
    """
    彩色图像阈值处理

    Parameters:
    -----------
    image : numpy.ndarray
        输入的彩色图像 (BGR格式)
    thresh : int
        阈值
    method : str
        'gray' - 转换为灰度图再处理
        'channels' - 分别处理每个通道
        'hsv' - 在HSV空间处理V通道

    Returns:
    --------
    result : numpy.ndarray
        处理结果
    """
    if method == 'gray':
        # 方法1：转换为灰度图
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        _, result = cv2.threshold(gray, thresh, 255, cv2.THRESH_BINARY)
        return result

    elif method == 'channels':
        # 方法2：分别处理每个通道
        channels = cv2.split(image)
        binary_channels = []
        for ch in channels:
            _, binary = cv2.threshold(ch, thresh, 255, cv2.THRESH_BINARY)
            binary_channels.append(binary)
        result = cv2.merge(binary_channels)
        return result

    elif method == 'hsv':
        # 方法3：在HSV空间处理V通道
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        h, s, v = cv2.split(hsv)
        _, v_binary = cv2.threshold(v, thresh, 255, cv2.THRESH_BINARY)
        return v_binary

    else:
        raise ValueError(f"Unknown method: {method}")

# 创建彩色测试图像
def create_color_test_image():
    img = np.zeros((300, 400, 3), dtype=np.uint8)
    img[:, :] = [50, 50, 50]  # 深灰色背景

    # 添加彩色形状
    cv2.circle(img, (100, 150), 60, (255, 0, 0), -1)   # 蓝色圆
    cv2.rectangle(img, (180, 80), (280, 220), (0, 255, 0), -1)  # 绿色矩形
    cv2.ellipse(img, (350, 150), (40, 70), 0, 0, 360, (0, 0, 255), -1)  # 红色椭圆

    return img

color_img = create_color_test_image()
T = 100

# 三种处理方法
result_gray = threshold_color_image(color_img, T, 'gray')
result_channels = threshold_color_image(color_img, T, 'channels')
result_hsv = threshold_color_image(color_img, T, 'hsv')

# 可视化
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

axes[0, 0].imshow(cv2.cvtColor(color_img, cv2.COLOR_BGR2RGB))
axes[0, 0].set_title('Original Color Image', fontsize=12)
axes[0, 0].axis('off')

axes[0, 1].imshow(result_gray, cmap='gray')
axes[0, 1].set_title('Method: Gray\n(Convert to grayscale first)', fontsize=11)
axes[0, 1].axis('off')

axes[1, 0].imshow(cv2.cvtColor(result_channels, cv2.COLOR_BGR2RGB))
axes[1, 0].set_title('Method: Channels\n(Threshold each channel)', fontsize=11)
axes[1, 0].axis('off')

axes[1, 1].imshow(result_hsv, cmap='gray')
axes[1, 1].set_title('Method: HSV\n(Threshold V channel)', fontsize=11)
axes[1, 1].axis('off')

plt.tight_layout()
plt.show()

print("彩色图像阈值处理方法对比：")
print("- Gray: 简单快速，但丢失颜色信息")
print("- Channels: 保留颜色信息，但可能产生意外的颜色组合")
print("- HSV: 只处理亮度通道，通常效果较好")
```

---

## 5. 完整应用示例

### 5.1 硬币检测

```python
"""
示例12：使用阈值处理检测硬币
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def detect_coins(image):
    """
    使用阈值处理检测图像中的硬币
    """
    # 转换为灰度图
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 高斯模糊去噪
    blurred = cv2.GaussianBlur(gray, (11, 11), 0)

    # 使用Otsu自动阈值
    ret, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    print(f"Otsu自动选择的阈值: {ret}")

    # 形态学操作：填充小洞并去除小噪点
    kernel = np.ones((5, 5), np.uint8)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

    # 查找轮廓
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # 筛选圆形轮廓（硬币）
    coins = []
    for contour in contours:
        area = cv2.contourArea(contour)
        if area < 500:  # 忽略太小的轮廓
            continue

        # 计算圆度
        perimeter = cv2.arcLength(contour, True)
        if perimeter == 0:
            continue
        circularity = 4 * np.pi * area / (perimeter * perimeter)

        if circularity > 0.7:  # 圆度阈值
            (x, y), radius = cv2.minEnclosingCircle(contour)
            coins.append((int(x), int(y), int(radius)))

    # 在原图上绘制结果
    if len(image.shape) == 3:
        result = image.copy()
    else:
        result = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)

    for (x, y, r) in coins:
        cv2.circle(result, (x, y), r, (0, 255, 0), 2)
        cv2.circle(result, (x, y), 3, (0, 0, 255), -1)

    return binary, result, len(coins)

# 创建模拟硬币图像
def create_coin_image():
    img = np.ones((400, 600), dtype=np.uint8) * 40  # 深色背景

    # 添加几个"硬币"（亮色圆形）
    coins_pos = [(100, 150, 50), (250, 200, 45), (400, 120, 55),
                 (180, 320, 40), (450, 300, 50)]

    for x, y, r in coins_pos:
        # 硬币主体
        cv2.circle(img, (x, y), r, 200, -1)
        # 添加一些纹理
        cv2.circle(img, (x, y), r-5, 220, 2)

    # 添加噪声
    noise = np.random.normal(0, 10, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 检测硬币
coin_img = create_coin_image()
binary, result, count = detect_coins(coin_img)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

axes[0].imshow(coin_img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

axes[1].imshow(binary, cmap='gray')
axes[1].set_title('Binary Mask (Otsu)', fontsize=12)
axes[1].axis('off')

axes[2].imshow(cv2.cvtColor(result, cv2.COLOR_BGR2RGB))
axes[2].set_title(f'Detected Coins: {count}', fontsize=12)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print(f"\n检测结果：发现 {count} 个硬币")
```

### 5.2 文档扫描增强

```python
"""
示例13：文档扫描二值化增强
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def enhance_document(image, method='otsu'):
    """
    增强扫描文档的可读性

    Parameters:
    -----------
    image : numpy.ndarray
        输入图像
    method : str
        'otsu' - Otsu自动阈值
        'adaptive' - 自适应阈值
        'combined' - 组合方法

    Returns:
    --------
    enhanced : numpy.ndarray
        增强后的二值图像
    """
    # 转换为灰度图
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 去噪
    denoised = cv2.GaussianBlur(gray, (5, 5), 0)

    if method == 'otsu':
        _, enhanced = cv2.threshold(denoised, 0, 255,
                                    cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    elif method == 'adaptive':
        enhanced = cv2.adaptiveThreshold(denoised, 255,
                                         cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                         cv2.THRESH_BINARY, 21, 10)

    elif method == 'combined':
        # 先用Otsu获取全局阈值
        otsu_thresh, _ = cv2.threshold(denoised, 0, 255,
                                       cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        # 使用自适应阈值
        adaptive = cv2.adaptiveThreshold(denoised, 255,
                                         cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                         cv2.THRESH_BINARY, 21, 10)
        # 结合两者
        _, global_binary = cv2.threshold(denoised, otsu_thresh * 0.9, 255,
                                        cv2.THRESH_BINARY)
        enhanced = cv2.bitwise_and(adaptive, global_binary)

    else:
        raise ValueError(f"Unknown method: {method}")

    return enhanced

# 创建模拟文档图像
def create_document_image():
    img = np.ones((500, 700), dtype=np.uint8) * 230  # 浅色纸张

    # 添加不均匀光照
    rows, cols = img.shape
    for i in range(rows):
        for j in range(cols):
            shade = 1.0 - 0.25 * (i / rows) - 0.15 * np.sin(j / cols * np.pi)
            img[i, j] = int(img[i, j] * shade)

    # 添加模拟文字行
    font = cv2.FONT_HERSHEY_SIMPLEX
    lines = [
        "Document Processing with OpenCV",
        "===============================",
        "",
        "This is a sample document that",
        "demonstrates thresholding techniques",
        "for document image enhancement.",
        "",
        "Key benefits:",
        "- Improved readability",
        "- Better OCR accuracy",
        "- Reduced file size",
    ]

    y = 50
    for line in lines:
        cv2.putText(img, line, (50, y), font, 0.6, 30, 1)
        y += 35

    # 添加噪声
    noise = np.random.normal(0, 8, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 处理文档
doc_img = create_document_image()

result_otsu = enhance_document(doc_img, 'otsu')
result_adaptive = enhance_document(doc_img, 'adaptive')
result_combined = enhance_document(doc_img, 'combined')

# 可视化
fig, axes = plt.subplots(2, 2, figsize=(14, 12))

axes[0, 0].imshow(doc_img, cmap='gray')
axes[0, 0].set_title('Original Document\n(with uneven lighting)', fontsize=12)
axes[0, 0].axis('off')

axes[0, 1].imshow(result_otsu, cmap='gray')
axes[0, 1].set_title('Otsu Thresholding\n(global threshold)', fontsize=12)
axes[0, 1].axis('off')

axes[1, 0].imshow(result_adaptive, cmap='gray')
axes[1, 0].set_title('Adaptive Thresholding\n(local threshold)', fontsize=12)
axes[1, 0].axis('off')

axes[1, 1].imshow(result_combined, cmap='gray')
axes[1, 1].set_title('Combined Method\n(Otsu + Adaptive)', fontsize=12)
axes[1, 1].axis('off')

plt.tight_layout()
plt.show()

print("文档增强方法对比：")
print("- Otsu: 快速，但在光照不均时效果差")
print("- Adaptive: 处理光照不均效果好，但可能引入噪声")
print("- Combined: 结合两者优点，通常效果最好")
```

---

## 6. 本节小结

### 6.1 cv2.threshold() 快速参考

```python
# 基本语法
retval, dst = cv2.threshold(src, thresh, maxval, type)

# 常用调用示例
_, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
_, binary_inv = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)
_, trunc = cv2.threshold(gray, 127, 255, cv2.THRESH_TRUNC)
_, tozero = cv2.threshold(gray, 127, 255, cv2.THRESH_TOZERO)
_, tozero_inv = cv2.threshold(gray, 127, 255, cv2.THRESH_TOZERO_INV)

# 自动阈值
ret, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

### 6.2 阈值类型总结表

| 类型 | 公式 | 适用场景 |
|------|------|---------|
| BINARY | >T→255, ≤T→0 | 目标提取、文档二值化 |
| BINARY_INV | >T→0, ≤T→255 | 深色目标提取 |
| TRUNC | >T→T, ≤T→保持 | 高光压缩 |
| TOZERO | >T→保持, ≤T→0 | 背景去除 |
| TOZERO_INV | >T→0, ≤T→保持 | 高光去除 |

### 6.3 下一步学习

- **自适应阈值**：处理光照不均匀的图像
- **Otsu阈值**：自动确定最佳阈值

---

## 7. 练习题

### 练习1：基础应用
使用 `cv2.threshold()` 函数，分别使用5种阈值类型处理一张图像，观察效果差异。

### 练习2：阈值选择
编写一个函数，输入一张图像，输出建议的阈值（基于直方图分析）。

### 练习3：实际应用
使用阈值处理实现一个简单的车牌区域检测（假设车牌区域比周围更亮或更暗）。

---

> **下一节预告**：自适应阈值 - 解决光照不均匀问题的利器！

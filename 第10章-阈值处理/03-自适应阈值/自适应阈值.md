# 自适应阈值

## 1. 为什么需要自适应阈值？

### 1.1 全局阈值的局限性

在前面的学习中，我们使用的都是**全局阈值**——整幅图像使用同一个阈值。这在理想情况下效果很好，但现实中的图像往往存在：

- **光照不均匀**：图像不同区域的亮度差异很大
- **阴影效果**：物体产生的阴影导致局部变暗
- **渐变背景**：背景亮度从一侧到另一侧逐渐变化
- **光源位置**：光源照射角度导致的明暗差异

```python
"""
示例1：展示全局阈值在光照不均匀情况下的问题
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def create_uneven_lighting_image():
    """创建一个光照不均匀的文档图像"""
    img = np.ones((400, 600), dtype=np.uint8) * 220

    # 添加模拟文字
    texts = ["OpenCV Tutorial", "Image Processing", "Thresholding", "Adaptive Method"]
    for i, text in enumerate(texts):
        y = 80 + i * 80
        cv2.putText(img, text, (50, y), cv2.FONT_HERSHEY_SIMPLEX, 1.2, 40, 2)

    # 添加不均匀光照（左边亮，右边暗）
    rows, cols = img.shape
    for j in range(cols):
        factor = 1.0 - 0.5 * (j / cols)
        img[:, j] = (img[:, j] * factor).astype(np.uint8)

    # 添加角落阴影
    for i in range(rows):
        for j in range(cols):
            dist = np.sqrt(i**2 + j**2) / np.sqrt(rows**2 + cols**2)
            img[i, j] = int(img[i, j] * (0.7 + 0.3 * dist))

    return img

# 创建测试图像
img = create_uneven_lighting_image()

# 使用全局阈值
_, global_thresh = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
_, otsu_thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 使用自适应阈值
adaptive_mean = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                       cv2.THRESH_BINARY, 21, 10)
adaptive_gaussian = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                          cv2.THRESH_BINARY, 21, 10)

# 可视化对比
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

axes[0, 0].imshow(img, cmap='gray')
axes[0, 0].set_title('Original Image\n(Uneven Lighting)', fontsize=12)
axes[0, 0].axis('off')

axes[0, 1].imshow(global_thresh, cmap='gray')
axes[0, 1].set_title('Global Threshold (T=127)\n(Left part lost!)', fontsize=12)
axes[0, 1].axis('off')

axes[0, 2].imshow(otsu_thresh, cmap='gray')
axes[0, 2].set_title('Otsu Threshold\n(Still has problems)', fontsize=12)
axes[0, 2].axis('off')

# 显示直方图
axes[1, 0].hist(img.ravel(), 256, [0, 256], color='blue', alpha=0.7)
axes[1, 0].set_title('Histogram\n(No clear bimodal pattern)', fontsize=12)
axes[1, 0].set_xlabel('Pixel Value')

axes[1, 1].imshow(adaptive_mean, cmap='gray')
axes[1, 1].set_title('Adaptive Mean\n(Much better!)', fontsize=12)
axes[1, 1].axis('off')

axes[1, 2].imshow(adaptive_gaussian, cmap='gray')
axes[1, 2].set_title('Adaptive Gaussian\n(Best result!)', fontsize=12)
axes[1, 2].axis('off')

plt.tight_layout()
plt.show()

print("对比分析：")
print("- 全局阈值(T=127): 左侧较暗区域的文字丢失")
print("- Otsu阈值: 仍然无法很好处理光照不均")
print("- 自适应阈值: 能够正确提取所有区域的文字")
```

### 1.2 自适应阈值的核心思想

自适应阈值的核心思想是：

> **不使用统一的全局阈值，而是为图像的每个小区域计算一个局部阈值。**

```
全局阈值：整幅图像使用 T = 127
         ╔═══════════════════════════════╗
         ║           T = 127             ║
         ║     (所有像素用同一阈值)        ║
         ╚═══════════════════════════════╝

自适应阈值：每个小区域有自己的阈值
         ╔═══════╦═══════╦═══════╦═══════╗
         ║ T=140 ║ T=135 ║ T=120 ║ T=100 ║
         ╠═══════╬═══════╬═══════╬═══════╣
         ║ T=145 ║ T=130 ║ T=115 ║ T=95  ║
         ╠═══════╬═══════╬═══════╬═══════╣
         ║ T=150 ║ T=125 ║ T=110 ║ T=90  ║
         ╚═══════╩═══════╩═══════╩═══════╝
         (每个区域根据局部特征确定阈值)
```

---

## 2. cv2.adaptiveThreshold() 函数详解

### 2.1 函数语法

```python
dst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)
```

**参数说明：**

| 参数 | 类型 | 说明 |
|------|------|------|
| `src` | numpy.ndarray | 输入图像，必须是8位单通道灰度图 |
| `maxValue` | float | 满足条件时赋予的最大值（通常为255） |
| `adaptiveMethod` | int | 自适应方法（MEAN或GAUSSIAN） |
| `thresholdType` | int | 阈值类型（BINARY或BINARY_INV） |
| `blockSize` | int | 邻域大小，必须是奇数（3, 5, 7, ...） |
| `C` | float | 从计算的阈值中减去的常数 |

**返回值：**

| 返回值 | 类型 | 说明 |
|--------|------|------|
| `dst` | numpy.ndarray | 输出的二值图像 |

### 2.2 自适应方法

OpenCV提供两种自适应方法：

#### ADAPTIVE_THRESH_MEAN_C（均值法）

局部阈值 = 邻域内所有像素的**算术平均值** - C

```
         ╔═══╦═══╦═══╗
         ║ 10║ 20║ 30║
         ╠═══╬═══╬═══╣
         ║ 40║ 50║ 60║   均值 = (10+20+30+40+50+60+70+80+90)/9 = 50
         ╠═══╬═══╬═══╣
         ║ 70║ 80║ 90║   阈值 = 50 - C
         ╚═══╩═══╩═══╝
```

#### ADAPTIVE_THRESH_GAUSSIAN_C（高斯法）

局部阈值 = 邻域内像素的**高斯加权平均值** - C

```
         高斯权重（示例，3×3）:
         ╔═════╦═════╦═════╗
         ║ 1/16║ 2/16║ 1/16║
         ╠═════╬═════╬═════╣
         ║ 2/16║ 4/16║ 2/16║   中心像素权重最大
         ╠═════╬═════╬═════╣
         ║ 1/16║ 2/16║ 1/16║
         ╚═════╩═════╩═════╝
```

```python
"""
示例2：两种自适应方法的对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像
def create_test_doc():
    img = np.ones((300, 400), dtype=np.uint8) * 200

    # 添加文字
    cv2.putText(img, "MEAN vs GAUSSIAN", (20, 80),
                cv2.FONT_HERSHEY_SIMPLEX, 1, 30, 2)
    cv2.putText(img, "Compare adaptive", (20, 150),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, 50, 2)
    cv2.putText(img, "threshold methods", (20, 200),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, 50, 2)

    # 添加渐变光照
    for j in range(400):
        factor = 0.6 + 0.4 * (j / 400)
        img[:, j] = (img[:, j] * factor).astype(np.uint8)

    # 添加噪声
    noise = np.random.normal(0, 10, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

img = create_test_doc()

# 相同参数下的两种方法
block_size = 15
C = 5

mean_result = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                     cv2.THRESH_BINARY, block_size, C)
gaussian_result = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                         cv2.THRESH_BINARY, block_size, C)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

axes[0].imshow(img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

axes[1].imshow(mean_result, cmap='gray')
axes[1].set_title(f'ADAPTIVE_THRESH_MEAN_C\nblockSize={block_size}, C={C}', fontsize=11)
axes[1].axis('off')

axes[2].imshow(gaussian_result, cmap='gray')
axes[2].set_title(f'ADAPTIVE_THRESH_GAUSSIAN_C\nblockSize={block_size}, C={C}', fontsize=11)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print("两种方法的区别：")
print("- MEAN_C: 使用简单平均，对噪声更敏感")
print("- GAUSSIAN_C: 使用高斯加权平均，中心像素权重更大，抗噪声能力更强")
print("\n一般推荐使用 GAUSSIAN_C")
```

### 2.3 参数详解

#### blockSize（邻域大小）

blockSize 决定了计算局部阈值时考虑的邻域范围。

```python
"""
示例3：blockSize 参数的影响
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像
img = np.zeros((300, 400), dtype=np.uint8)
img[:] = 180

# 添加不同大小的文字和细节
cv2.putText(img, "Block Size Test", (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1.2, 30, 3)
cv2.putText(img, "Large text", (20, 120), cv2.FONT_HERSHEY_SIMPLEX, 1.0, 40, 2)
cv2.putText(img, "Medium text here", (20, 180), cv2.FONT_HERSHEY_SIMPLEX, 0.7, 50, 2)
cv2.putText(img, "Small tiny text", (20, 230), cv2.FONT_HERSHEY_SIMPLEX, 0.5, 60, 1)

# 添加一些细线
cv2.line(img, (20, 260), (380, 260), 50, 1)
cv2.line(img, (20, 280), (380, 280), 50, 2)

# 添加光照渐变
for i in range(300):
    factor = 0.7 + 0.3 * (i / 300)
    img[i, :] = (img[i, :] * factor).astype(np.uint8)

# 测试不同的blockSize
block_sizes = [3, 11, 31, 51, 101]
C = 5

fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

# 不同blockSize的结果
for i, bs in enumerate(block_sizes, 1):
    result = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY, bs, C)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'blockSize = {bs}', fontsize=12)
    axes[i].axis('off')

plt.tight_layout()
plt.show()

print("blockSize 参数指南：")
print("━" * 50)
print("小值 (3-11):  对细节敏感，但可能产生更多噪声")
print("中值 (21-51): 平衡细节和噪声，通常是好选择")
print("大值 (>51):   平滑效果好，但可能丢失细节")
print("━" * 50)
print("\n提示：blockSize 应该大于要分割的目标的笔画宽度")
```

#### C（常数）

C 是从计算的局部阈值中减去的常数，用于调整分割的敏感度。

```python
"""
示例4：C 参数的影响
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建测试图像
img = np.ones((250, 350), dtype=np.uint8) * 180
cv2.putText(img, "Testing C", (30, 80), cv2.FONT_HERSHEY_SIMPLEX, 1.5, 40, 3)
cv2.putText(img, "parameter", (50, 150), cv2.FONT_HERSHEY_SIMPLEX, 1.2, 50, 2)
cv2.putText(img, "variation", (60, 210), cv2.FONT_HERSHEY_SIMPLEX, 1.0, 60, 2)

# 添加渐变
for j in range(350):
    factor = 0.6 + 0.4 * (j / 350)
    img[:, j] = (img[:, j] * factor).astype(np.uint8)

# 添加噪声
noise = np.random.normal(0, 8, img.shape)
img = np.clip(img + noise, 0, 255).astype(np.uint8)

# 测试不同的C值
C_values = [-5, 0, 5, 10, 20]
block_size = 21

fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

# 不同C值的结果
for i, c in enumerate(C_values, 1):
    result = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY, block_size, c)
    axes[i].imshow(result, cmap='gray')
    title = f'C = {c}'
    if c < 0:
        title += '\n(More white)'
    elif c > 10:
        title += '\n(More black)'
    axes[i].set_title(title, fontsize=12)
    axes[i].axis('off')

plt.tight_layout()
plt.show()

print("C 参数指南：")
print("━" * 50)
print("负值 (C<0):   阈值更低，更多像素变成白色")
print("零值 (C=0):   使用计算的局部均值作为阈值")
print("正值 (C>0):   阈值更高，更多像素变成黑色")
print("━" * 50)
print("\n典型值：2-10，根据图像对比度调整")
print("对比度低的图像：使用较小的C")
print("对比度高的图像：使用较大的C")
```

---

## 3. 实际应用案例

### 3.1 文档扫描增强

```python
"""
示例5：完整的文档扫描增强流程
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

class DocumentScanner:
    """文档扫描增强类"""

    def __init__(self):
        self.block_size = 21
        self.C = 10

    def preprocess(self, image):
        """预处理：转灰度、降噪"""
        if len(image.shape) == 3:
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        else:
            gray = image.copy()

        # 轻微降噪
        denoised = cv2.GaussianBlur(gray, (3, 3), 0)

        return denoised

    def enhance(self, image, method='gaussian'):
        """增强处理"""
        preprocessed = self.preprocess(image)

        if method == 'gaussian':
            adaptive_method = cv2.ADAPTIVE_THRESH_GAUSSIAN_C
        else:
            adaptive_method = cv2.ADAPTIVE_THRESH_MEAN_C

        binary = cv2.adaptiveThreshold(
            preprocessed, 255, adaptive_method,
            cv2.THRESH_BINARY, self.block_size, self.C
        )

        return binary

    def clean(self, binary):
        """清理：去除小噪点"""
        kernel = np.ones((2, 2), np.uint8)
        cleaned = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
        cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, kernel)

        return cleaned

    def process(self, image, method='gaussian', clean=True):
        """完整处理流程"""
        binary = self.enhance(image, method)
        if clean:
            binary = self.clean(binary)
        return binary

# 创建模拟文档
def create_scanned_document():
    """创建模拟的扫描文档图像"""
    img = np.ones((500, 700), dtype=np.uint8) * 230

    # 不均匀背景（模拟扫描时的光照问题）
    rows, cols = img.shape
    for i in range(rows):
        for j in range(cols):
            # 创建复杂的光照变化
            factor = 0.7 + 0.2 * np.sin(i / 100) + 0.1 * np.cos(j / 150)
            factor += 0.1 * (i / rows) - 0.05 * (j / cols)
            img[i, j] = int(img[i, j] * factor)

    # 添加标题
    cv2.putText(img, "Document Processing Demo", (50, 60),
                cv2.FONT_HERSHEY_SIMPLEX, 1.2, 30, 2)
    cv2.line(img, (50, 80), (550, 80), 40, 2)

    # 添加段落
    paragraphs = [
        "This is a sample scanned document with",
        "uneven lighting conditions. The adaptive",
        "thresholding method can handle this well.",
        "",
        "Key advantages:",
        "* Works with varying illumination",
        "* Preserves local details",
        "* Better text extraction quality",
        "",
        "Parameters to tune:",
        "- blockSize: neighborhood size",
        "- C: constant subtracted from mean",
    ]

    y = 120
    for para in paragraphs:
        if para:
            cv2.putText(img, para, (50, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, 35, 1)
        y += 30

    # 添加噪声
    noise = np.random.normal(0, 8, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 使用文档扫描器
scanner = DocumentScanner()
doc_img = create_scanned_document()

# 处理文档
result = scanner.process(doc_img)

# 可视化
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

axes[0].imshow(doc_img, cmap='gray')
axes[0].set_title('Original Scanned Document\n(Uneven lighting)', fontsize=12)
axes[0].axis('off')

axes[1].imshow(result, cmap='gray')
axes[1].set_title('Enhanced Document\n(Adaptive Thresholding)', fontsize=12)
axes[1].axis('off')

plt.tight_layout()
plt.show()

print("文档扫描增强完成！")
print(f"使用参数: blockSize={scanner.block_size}, C={scanner.C}")
```

### 3.2 车牌识别预处理

```python
"""
示例6：车牌识别预处理
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def preprocess_license_plate(image):
    """
    车牌图像预处理
    """
    # 转灰度
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 增强对比度
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(gray)

    # 自适应阈值
    binary = cv2.adaptiveThreshold(
        enhanced, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV, 21, 4
    )

    # 形态学处理
    kernel = np.ones((3, 3), np.uint8)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return gray, enhanced, binary

# 创建模拟车牌图像
def create_license_plate():
    img = np.ones((120, 400), dtype=np.uint8) * 200

    # 车牌背景渐变（模拟光照）
    for j in range(400):
        factor = 0.7 + 0.3 * np.abs(np.sin(j / 80))
        img[:, j] = (img[:, j] * factor).astype(np.uint8)

    # 添加车牌号
    cv2.putText(img, "京A12345", (30, 85),
                cv2.FONT_HERSHEY_SIMPLEX, 2.5, 30, 6)

    # 添加噪声
    noise = np.random.normal(0, 15, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 处理车牌
plate_img = create_license_plate()
gray, enhanced, binary = preprocess_license_plate(plate_img)

# 可视化
fig, axes = plt.subplots(2, 2, figsize=(14, 8))

axes[0, 0].imshow(plate_img, cmap='gray')
axes[0, 0].set_title('Original License Plate\n(Uneven lighting)', fontsize=11)
axes[0, 0].axis('off')

axes[0, 1].imshow(enhanced, cmap='gray')
axes[0, 1].set_title('CLAHE Enhanced\n(Improved contrast)', fontsize=11)
axes[0, 1].axis('off')

axes[1, 0].imshow(binary, cmap='gray')
axes[1, 0].set_title('Adaptive Threshold\n(Ready for OCR)', fontsize=11)
axes[1, 0].axis('off')

# 显示直方图对比
axes[1, 1].hist(plate_img.ravel(), 256, [0, 256], alpha=0.5, label='Original')
axes[1, 1].hist(enhanced.ravel(), 256, [0, 256], alpha=0.5, label='Enhanced')
axes[1, 1].set_title('Histogram Comparison', fontsize=11)
axes[1, 1].legend()
axes[1, 1].set_xlabel('Pixel Value')

plt.tight_layout()
plt.show()

print("车牌预处理完成！")
print("处理流程: 灰度化 → CLAHE增强 → 自适应阈值 → 形态学清理")
```

### 3.3 手写数字识别预处理

```python
"""
示例7：手写数字识别预处理
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def preprocess_handwritten(image, target_size=(28, 28)):
    """
    手写数字图像预处理
    适用于MNIST风格的分类任务
    """
    # 转灰度
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 高斯模糊去噪
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # 自适应阈值（反向，使数字为白色）
    binary = cv2.adaptiveThreshold(
        blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV, 11, 2
    )

    # 查找轮廓以定位数字
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        # 找最大轮廓（假设是数字）
        largest = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largest)

        # 裁剪并居中
        digit = binary[y:y+h, x:x+w]

        # 添加边距
        pad = 4
        digit_padded = cv2.copyMakeBorder(digit, pad, pad, pad, pad,
                                          cv2.BORDER_CONSTANT, value=0)

        # 调整大小
        resized = cv2.resize(digit_padded, target_size, interpolation=cv2.INTER_AREA)
    else:
        resized = cv2.resize(binary, target_size, interpolation=cv2.INTER_AREA)

    return binary, resized

# 创建模拟手写数字
def create_handwritten_digit():
    img = np.ones((150, 150), dtype=np.uint8) * 230

    # 添加不均匀背景
    for i in range(150):
        for j in range(150):
            factor = 0.8 + 0.2 * np.random.random()
            img[i, j] = int(img[i, j] * factor)

    # 绘制一个手写风格的"5"
    pts = np.array([
        [90, 30], [50, 30], [45, 50], [50, 70], [80, 75],
        [95, 90], [90, 115], [60, 120], [40, 110]
    ], np.int32)

    for i in range(len(pts) - 1):
        # 添加一些随机抖动模拟手写
        p1 = pts[i] + np.random.randint(-2, 3, 2)
        p2 = pts[i+1] + np.random.randint(-2, 3, 2)
        cv2.line(img, tuple(p1), tuple(p2), 40, 8)

    # 添加噪声
    noise = np.random.normal(0, 10, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 处理手写数字
digit_img = create_handwritten_digit()
binary, preprocessed = preprocess_handwritten(digit_img)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(12, 4))

axes[0].imshow(digit_img, cmap='gray')
axes[0].set_title('Original Handwritten\n(Noisy background)', fontsize=11)
axes[0].axis('off')

axes[1].imshow(binary, cmap='gray')
axes[1].set_title('Adaptive Threshold\n(Cleaned)', fontsize=11)
axes[1].axis('off')

axes[2].imshow(preprocessed, cmap='gray')
axes[2].set_title('Preprocessed (28x28)\n(Ready for classification)', fontsize=11)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print("手写数字预处理完成！")
print(f"输出尺寸: {preprocessed.shape} (MNIST格式)")
```

---

## 4. 参数调优技巧

### 4.1 交互式参数调整

```python
"""
示例8：交互式参数调整工具
"""
import cv2
import numpy as np

def nothing(x):
    pass

def interactive_adaptive_threshold(image):
    """
    交互式自适应阈值参数调整工具
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    cv2.namedWindow('Adaptive Threshold Tuner')
    cv2.createTrackbar('blockSize', 'Adaptive Threshold Tuner', 11, 100, nothing)
    cv2.createTrackbar('C', 'Adaptive Threshold Tuner', 10, 50, nothing)
    cv2.createTrackbar('Method', 'Adaptive Threshold Tuner', 1, 1, nothing)

    print("调参说明：")
    print("- blockSize: 邻域大小（会自动转为奇数）")
    print("- C: 从均值减去的常数")
    print("- Method: 0=MEAN, 1=GAUSSIAN")
    print("按 ESC 退出")

    while True:
        block_size = cv2.getTrackbarPos('blockSize', 'Adaptive Threshold Tuner')
        c_value = cv2.getTrackbarPos('C', 'Adaptive Threshold Tuner')
        method = cv2.getTrackbarPos('Method', 'Adaptive Threshold Tuner')

        # 确保blockSize是奇数且至少为3
        block_size = max(3, block_size)
        if block_size % 2 == 0:
            block_size += 1

        # 选择方法
        if method == 0:
            adaptive_method = cv2.ADAPTIVE_THRESH_MEAN_C
            method_name = "MEAN"
        else:
            adaptive_method = cv2.ADAPTIVE_THRESH_GAUSSIAN_C
            method_name = "GAUSSIAN"

        # 应用自适应阈值
        result = cv2.adaptiveThreshold(gray, 255, adaptive_method,
                                       cv2.THRESH_BINARY, block_size, c_value)

        # 添加参数信息
        info = f"blockSize={block_size}, C={c_value}, Method={method_name}"
        display = result.copy()
        cv2.putText(display, info, (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, 128, 2)

        # 显示原图和结果
        combined = np.hstack([gray, display])
        cv2.imshow('Adaptive Threshold Tuner', combined)

        if cv2.waitKey(1) & 0xFF == 27:
            break

    cv2.destroyAllWindows()
    return block_size, c_value

# 使用示例
# 创建测试图像
# test_img = create_uneven_lighting_image()  # 使用之前定义的函数
# best_blocksize, best_c = interactive_adaptive_threshold(test_img)
print("提示：运行 interactive_adaptive_threshold(your_image) 进行交互式调参")
```

### 4.2 自动参数选择

```python
"""
示例9：自动参数选择策略
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def auto_adaptive_params(image):
    """
    根据图像特征自动选择自适应阈值参数
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 分析图像特征
    height, width = gray.shape

    # 1. 估算blockSize：基于图像尺寸
    # 通常选择图像较小边的1/20到1/10之间
    min_dim = min(height, width)
    suggested_block = max(11, min(min_dim // 15, 51))
    # 确保是奇数
    suggested_block = suggested_block if suggested_block % 2 == 1 else suggested_block + 1

    # 2. 估算C值：基于图像对比度
    # 计算图像的标准差作为对比度指标
    std_dev = np.std(gray)
    # 对比度高的图像用较大的C
    suggested_c = max(2, min(int(std_dev / 10), 15))

    # 3. 验证参数（通过分析结果质量）
    results = {}
    for block in [suggested_block - 10, suggested_block, suggested_block + 10]:
        if block < 3:
            continue
        block = block if block % 2 == 1 else block + 1

        for c in [suggested_c - 3, suggested_c, suggested_c + 3]:
            if c < 0:
                continue

            binary = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                          cv2.THRESH_BINARY, block, c)

            # 计算质量指标：白色像素比例应该在合理范围内
            white_ratio = np.sum(binary == 255) / binary.size

            # 理想的白色比例取决于应用，这里假设在0.2-0.8之间较好
            if 0.2 < white_ratio < 0.8:
                quality_score = 1 - abs(white_ratio - 0.5)  # 越接近0.5越好
            else:
                quality_score = 0

            results[(block, c)] = {
                'binary': binary,
                'white_ratio': white_ratio,
                'score': quality_score
            }

    # 选择最佳参数
    best_params = max(results.keys(), key=lambda x: results[x]['score'])

    return {
        'block_size': best_params[0],
        'C': best_params[1],
        'result': results[best_params]['binary'],
        'analysis': {
            'image_size': (height, width),
            'std_dev': std_dev,
            'white_ratio': results[best_params]['white_ratio']
        }
    }

# 测试
def create_test_image_for_auto():
    img = np.ones((300, 400), dtype=np.uint8) * 200
    cv2.putText(img, "Auto Params Test", (30, 80),
                cv2.FONT_HERSHEY_SIMPLEX, 1.2, 40, 2)
    cv2.putText(img, "Testing automatic", (30, 150),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, 50, 2)
    cv2.putText(img, "parameter selection", (30, 210),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, 50, 2)

    for j in range(400):
        factor = 0.6 + 0.4 * (j / 400)
        img[:, j] = (img[:, j] * factor).astype(np.uint8)

    noise = np.random.normal(0, 10, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)
    return img

test_img = create_test_image_for_auto()
auto_result = auto_adaptive_params(test_img)

# 可视化
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

axes[0].imshow(test_img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

axes[1].imshow(auto_result['result'], cmap='gray')
axes[1].set_title(f"Auto Parameters\nblockSize={auto_result['block_size']}, C={auto_result['C']}", fontsize=12)
axes[1].axis('off')

plt.tight_layout()
plt.show()

print("自动参数选择结果：")
print(f"  blockSize: {auto_result['block_size']}")
print(f"  C: {auto_result['C']}")
print(f"\n图像分析：")
print(f"  尺寸: {auto_result['analysis']['image_size']}")
print(f"  标准差: {auto_result['analysis']['std_dev']:.2f}")
print(f"  白色比例: {auto_result['analysis']['white_ratio']:.2%}")
```

---

## 5. 与其他方法的比较

### 5.1 全局阈值 vs 自适应阈值

```python
"""
示例10：全局阈值与自适应阈值的综合对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def comprehensive_comparison(image):
    """全面比较不同阈值方法"""
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    results = {}

    # 1. 固定阈值
    _, results['Fixed (T=127)'] = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

    # 2. Otsu
    ret, results['Otsu'] = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # 3. 自适应均值
    results['Adaptive Mean'] = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 21, 10)

    # 4. 自适应高斯
    results['Adaptive Gaussian'] = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 10)

    return results

# 创建具有明显光照不均的测试图像
def create_challenging_image():
    img = np.ones((400, 500), dtype=np.uint8) * 200

    # 添加多行文字
    lines = [
        "Comparison Test",
        "Global vs Adaptive",
        "Which is better?",
        "Let's find out!",
    ]

    for i, line in enumerate(lines):
        y = 80 + i * 80
        cv2.putText(img, line, (40, y), cv2.FONT_HERSHEY_SIMPLEX, 1.0, 30, 2)

    # 创建复杂的光照变化
    rows, cols = img.shape
    for i in range(rows):
        for j in range(cols):
            # 左上角亮，右下角暗
            factor = 1.0 - 0.3 * (i / rows) - 0.3 * (j / cols)
            # 添加一些波动
            factor += 0.1 * np.sin(i / 30) * np.cos(j / 40)
            img[i, j] = int(img[i, j] * max(0.3, min(1.0, factor)))

    # 添加噪声
    noise = np.random.normal(0, 10, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 运行比较
test_img = create_challenging_image()
results = comprehensive_comparison(test_img)

# 可视化
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(test_img, cmap='gray')
axes[0].set_title('Original Image\n(Complex lighting)', fontsize=11)
axes[0].axis('off')

# 各种方法的结果
for i, (name, result) in enumerate(results.items(), 1):
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(name, fontsize=11)
    axes[i].axis('off')

# 隐藏空白子图
axes[5].axis('off')

plt.tight_layout()
plt.show()

# 打印比较结论
print("方法对比结论：")
print("=" * 60)
print("固定阈值:       简单快速，但无法处理光照不均")
print("Otsu:          自动选择阈值，但仍是全局阈值")
print("自适应均值:     局部阈值，对边缘敏感")
print("自适应高斯:     局部阈值，边缘更平滑（推荐）")
print("=" * 60)
```

---

## 6. 本节小结

### 6.1 核心要点

| 要点 | 说明 |
|------|------|
| **适用场景** | 光照不均匀的图像 |
| **核心思想** | 为每个像素计算局部阈值 |
| **推荐方法** | ADAPTIVE_THRESH_GAUSSIAN_C |
| **关键参数** | blockSize（邻域大小）、C（调整常数） |

### 6.2 参数选择指南

```
blockSize 选择：
├── 图像较小（<500像素）：11-21
├── 图像中等（500-1000像素）：21-41
└── 图像较大（>1000像素）：41-101

C 值选择：
├── 对比度低：2-5
├── 对比度中等：5-10
└── 对比度高：10-20
```

### 6.3 cv2.adaptiveThreshold() 快速参考

```python
# 常用调用方式
result = cv2.adaptiveThreshold(
    gray,                              # 输入灰度图
    255,                               # 最大值
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,    # 高斯加权（推荐）
    cv2.THRESH_BINARY,                 # 二值化类型
    21,                                # 邻域大小（奇数）
    10                                 # 调整常数
)
```

---

## 7. 练习题

### 练习1
使用自适应阈值处理一张光照不均匀的文档图像，对比不同blockSize的效果。

### 练习2
实现一个函数，自动判断图像是否适合使用自适应阈值（基于光照均匀性分析）。

### 练习3
结合形态学操作，对自适应阈值的结果进行后处理，去除噪点并填充空洞。

---

> **下一节预告**：Otsu阈值 - 让计算机自动找到最佳阈值！

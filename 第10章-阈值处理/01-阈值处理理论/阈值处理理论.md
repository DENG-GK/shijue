# 阈值处理理论

## 1. 什么是阈值处理？

### 1.1 生活中的阈值概念

在日常生活中，我们经常会遇到"阈值"的概念：

- **考试及格线**：60分以上及格，60分以下不及格
- **身高限制**：身高120cm以上才能乘坐过山车
- **温度报警**：温度超过38.5°C就算发烧

这些都是阈值的应用——通过一个**临界值**将事物分成两类。

### 1.2 图像处理中的阈值

在图像处理中，阈值处理（Thresholding）是一种最简单、最基础的图像分割方法。它的核心思想是：

> **根据像素值与阈值的比较结果，将图像中的每个像素分为两类或多类。**

```
原理示意：
像素值: [50, 120, 200, 80, 255, 30, 180]
阈值T = 128

比较结果:
50  < 128  →  0（黑色）
120 < 128  →  0（黑色）
200 > 128  →  255（白色）
80  < 128  →  0（黑色）
255 > 128  →  255（白色）
30  < 128  →  0（黑色）
180 > 128  →  255（白色）

输出: [0, 0, 255, 0, 255, 0, 255]
```

### 1.3 为什么需要阈值处理？

阈值处理在计算机视觉中有着广泛的应用：

| 应用场景 | 说明 |
|---------|------|
| **目标提取** | 将目标物体从背景中分离出来 |
| **文档扫描** | 将文字与纸张背景分离，提高OCR识别率 |
| **缺陷检测** | 在工业检测中识别产品表面的缺陷 |
| **车牌识别** | 分离车牌区域与背景 |
| **医学影像** | 分割X光片、CT图像中的病变区域 |
| **预处理步骤** | 为后续的轮廓检测、形态学处理做准备 |

---

## 2. 阈值处理的数学基础

### 2.1 基本数学表达式

最简单的二值阈值处理可以用以下公式表示：

```
        ┌ maxVal,  if src(x,y) > T
dst(x,y) = ┤
        └ 0,       otherwise

其中：
- src(x,y): 源图像在坐标(x,y)处的像素值
- dst(x,y): 目标图像在坐标(x,y)处的像素值
- T: 阈值（Threshold）
- maxVal: 最大值（通常为255）
```

### 2.2 直方图与阈值选择

理解图像的直方图对于选择合适的阈值非常重要：

```python
"""
示例1：理解图像直方图与阈值的关系
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建一个简单的测试图像
# 模拟一个有明显前景和背景的图像
img = np.zeros((200, 200), dtype=np.uint8)
img[50:150, 50:150] = 200  # 中间区域设为亮色（前景）
img = cv2.GaussianBlur(img, (21, 21), 0)  # 添加一些模糊使其更自然

# 添加噪声
noise = np.random.normal(0, 10, img.shape).astype(np.int16)
img = np.clip(img.astype(np.int16) + noise, 0, 255).astype(np.uint8)

# 计算直方图
hist = cv2.calcHist([img], [0], None, [256], [0, 256])

# 可视化
plt.figure(figsize=(12, 4))

plt.subplot(131)
plt.imshow(img, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(132)
plt.plot(hist)
plt.title('Histogram')
plt.xlabel('Pixel Value')
plt.ylabel('Frequency')
plt.axvline(x=100, color='r', linestyle='--', label='Threshold=100')
plt.legend()

# 应用阈值
_, binary = cv2.threshold(img, 100, 255, cv2.THRESH_BINARY)

plt.subplot(133)
plt.imshow(binary, cmap='gray')
plt.title('After Thresholding (T=100)')
plt.axis('off')

plt.tight_layout()
plt.show()

print("直方图分析：")
print(f"- 图像像素范围: {img.min()} ~ {img.max()}")
print(f"- 直方图峰值位置: {np.argmax(hist)}")
print(f"- 选择的阈值: 100")
```

### 2.3 双峰直方图

理想情况下，适合阈值分割的图像具有**双峰直方图**（Bimodal Histogram）：

```
频率
  |
  |    ****                    ****
  |   *    *                  *    *
  |  *      *                *      *
  | *        *              *        *
  |*          *    ____    *          *
  |            ****    ****
  +------------------------------------ 像素值
  0     背景峰值    阈值    前景峰值   255
                     ↑
               最佳阈值位置
               （两个峰之间的谷底）
```

```python
"""
示例2：双峰直方图分析
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def analyze_histogram(image, title="Image"):
    """分析图像直方图，找出可能的阈值"""
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 计算直方图
    hist = cv2.calcHist([gray], [0], None, [256], [0, 256]).flatten()

    # 平滑直方图以便找峰值
    from scipy.ndimage import gaussian_filter1d
    hist_smooth = gaussian_filter1d(hist, sigma=5)

    # 找局部最大值（峰值）
    peaks = []
    for i in range(1, 255):
        if hist_smooth[i] > hist_smooth[i-1] and hist_smooth[i] > hist_smooth[i+1]:
            if hist_smooth[i] > np.mean(hist_smooth):  # 只保留显著的峰
                peaks.append(i)

    # 可视化
    plt.figure(figsize=(12, 4))

    plt.subplot(121)
    plt.imshow(gray, cmap='gray')
    plt.title(title)
    plt.axis('off')

    plt.subplot(122)
    plt.plot(hist, alpha=0.5, label='Original')
    plt.plot(hist_smooth, label='Smoothed')
    for p in peaks:
        plt.axvline(x=p, color='r', linestyle='--', alpha=0.5)
        plt.annotate(f'Peak: {p}', (p, hist_smooth[p]))
    plt.title('Histogram Analysis')
    plt.xlabel('Pixel Value')
    plt.ylabel('Frequency')
    plt.legend()

    plt.tight_layout()
    plt.show()

    if len(peaks) >= 2:
        suggested_threshold = (peaks[0] + peaks[1]) // 2
        print(f"检测到双峰: {peaks[:2]}")
        print(f"建议阈值: {suggested_threshold}")
        return suggested_threshold
    else:
        print("未检测到明显的双峰分布")
        return 128

# 创建测试图像
test_img = np.zeros((300, 300), dtype=np.uint8)
test_img[:, :150] = np.random.normal(60, 15, (300, 150)).clip(0, 255)  # 左半部分：暗色
test_img[:, 150:] = np.random.normal(180, 15, (300, 150)).clip(0, 255)  # 右半部分：亮色
test_img = test_img.astype(np.uint8)

threshold = analyze_histogram(test_img, "Bimodal Test Image")
```

---

## 3. 阈值处理的类型

OpenCV提供了多种阈值处理类型，每种适用于不同的场景：

### 3.1 五种基本阈值类型

```
原始像素值示意（假设阈值T=127）：

像素值:     0   50   127   180   255
            |----|----|----|----|
                      ↑
                    阈值T
```

| 类型 | OpenCV常量 | 公式 | 效果描述 |
|------|-----------|------|---------|
| 二值化 | `THRESH_BINARY` | `>T → maxVal, ≤T → 0` | 大于阈值变白，否则变黑 |
| 反二值化 | `THRESH_BINARY_INV` | `>T → 0, ≤T → maxVal` | 大于阈值变黑，否则变白 |
| 截断 | `THRESH_TRUNC` | `>T → T, ≤T → 不变` | 大于阈值的截断为阈值 |
| 置零 | `THRESH_TOZERO` | `>T → 不变, ≤T → 0` | 小于等于阈值的变为0 |
| 反置零 | `THRESH_TOZERO_INV` | `>T → 0, ≤T → 不变` | 大于阈值的变为0 |

### 3.2 可视化对比

```python
"""
示例3：五种阈值类型的对比
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建一个渐变图像用于演示
gradient = np.tile(np.arange(256, dtype=np.uint8), (100, 1))

# 定义阈值类型
threshold_types = [
    (cv2.THRESH_BINARY, 'BINARY', 'dst = (src > T) ? maxVal : 0'),
    (cv2.THRESH_BINARY_INV, 'BINARY_INV', 'dst = (src > T) ? 0 : maxVal'),
    (cv2.THRESH_TRUNC, 'TRUNC', 'dst = (src > T) ? T : src'),
    (cv2.THRESH_TOZERO, 'TOZERO', 'dst = (src > T) ? src : 0'),
    (cv2.THRESH_TOZERO_INV, 'TOZERO_INV', 'dst = (src > T) ? 0 : src'),
]

T = 127  # 阈值

# 可视化
fig, axes = plt.subplots(2, 3, figsize=(15, 8))
axes = axes.flatten()

# 原图
axes[0].imshow(gradient, cmap='gray')
axes[0].set_title('Original Gradient\n(0 → 255)', fontsize=12)
axes[0].axvline(x=T, color='r', linestyle='--', linewidth=2)
axes[0].text(T+5, 50, f'T={T}', color='r', fontsize=10)
axes[0].axis('off')

# 各种阈值处理结果
for i, (thresh_type, name, formula) in enumerate(threshold_types, 1):
    _, result = cv2.threshold(gradient, T, 255, thresh_type)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'{name}\n{formula}', fontsize=10)
    axes[i].axvline(x=T, color='r', linestyle='--', linewidth=2)
    axes[i].axis('off')

plt.tight_layout()
plt.savefig('threshold_types_comparison.png', dpi=150, bbox_inches='tight')
plt.show()

print("阈值类型对比图已保存为 threshold_types_comparison.png")
```

### 3.3 实际图像效果对比

```python
"""
示例4：在真实图像上对比五种阈值类型
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 读取图像（使用灰度模式）
# 这里我们创建一个模拟的灰度图像
def create_sample_image():
    """创建一个包含渐变和形状的示例图像"""
    img = np.zeros((300, 400), dtype=np.uint8)

    # 背景渐变
    for i in range(300):
        img[i, :] = int(50 + i * 0.3)

    # 添加一些形状
    cv2.circle(img, (100, 150), 60, 255, -1)
    cv2.rectangle(img, (200, 80), (350, 220), 200, -1)
    cv2.ellipse(img, (280, 150), (50, 80), 45, 0, 360, 30, -1)

    # 添加轻微噪声
    noise = np.random.normal(0, 5, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 创建或加载图像
img = create_sample_image()

# 阈值类型
threshold_types = [
    (cv2.THRESH_BINARY, 'BINARY'),
    (cv2.THRESH_BINARY_INV, 'BINARY_INV'),
    (cv2.THRESH_TRUNC, 'TRUNC'),
    (cv2.THRESH_TOZERO, 'TOZERO'),
    (cv2.THRESH_TOZERO_INV, 'TOZERO_INV'),
]

T = 100

# 创建图形
fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.flatten()

# 原图
axes[0].imshow(img, cmap='gray')
axes[0].set_title(f'Original Image\nThreshold T = {T}', fontsize=12)
axes[0].axis('off')

# 处理每种阈值类型
for i, (thresh_type, name) in enumerate(threshold_types, 1):
    _, result = cv2.threshold(img, T, 255, thresh_type)
    axes[i].imshow(result, cmap='gray')
    axes[i].set_title(f'{name}', fontsize=12)
    axes[i].axis('off')

plt.tight_layout()
plt.show()
```

---

## 4. 如何选择合适的阈值？

### 4.1 手动选择阈值

最简单的方法是根据图像的特点手动选择阈值：

```python
"""
示例5：交互式阈值选择（使用滑动条）
"""
import cv2
import numpy as np

def nothing(x):
    pass

def interactive_threshold():
    """交互式阈值调整工具"""
    # 创建测试图像
    img = np.zeros((300, 400), dtype=np.uint8)
    cv2.circle(img, (200, 150), 100, 180, -1)
    cv2.rectangle(img, (50, 50), (150, 250), 120, -1)
    noise = np.random.normal(0, 20, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    cv2.namedWindow('Threshold Adjustment')
    cv2.createTrackbar('Threshold', 'Threshold Adjustment', 127, 255, nothing)
    cv2.createTrackbar('Type', 'Threshold Adjustment', 0, 4, nothing)

    type_names = ['BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV']
    types = [cv2.THRESH_BINARY, cv2.THRESH_BINARY_INV, cv2.THRESH_TRUNC,
             cv2.THRESH_TOZERO, cv2.THRESH_TOZERO_INV]

    while True:
        thresh_val = cv2.getTrackbarPos('Threshold', 'Threshold Adjustment')
        type_idx = cv2.getTrackbarPos('Type', 'Threshold Adjustment')

        _, result = cv2.threshold(img, thresh_val, 255, types[type_idx])

        # 添加文字说明
        display = cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)
        cv2.putText(display, f'T={thresh_val}, Type={type_names[type_idx]}',
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

        # 显示原图和结果
        original_bgr = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        combined = np.hstack([original_bgr, display])
        cv2.imshow('Threshold Adjustment', combined)

        key = cv2.waitKey(1) & 0xFF
        if key == 27:  # ESC退出
            break

    cv2.destroyAllWindows()
    return thresh_val

# 运行交互式工具
# threshold = interactive_threshold()
print("提示：运行 interactive_threshold() 函数可以交互式调整阈值")
print("使用滑动条调整阈值和阈值类型，按ESC退出")
```

### 4.2 自动阈值选择方法

除了手动选择，还有几种自动确定阈值的方法：

| 方法 | 适用场景 | OpenCV实现 |
|------|---------|-----------|
| **Otsu方法** | 双峰分布的图像 | `cv2.THRESH_OTSU` |
| **Triangle方法** | 单峰分布的图像 | `cv2.THRESH_TRIANGLE` |
| **自适应阈值** | 光照不均匀的图像 | `cv2.adaptiveThreshold()` |

这些方法将在后续章节详细讲解。

---

## 5. 阈值处理的应用实例

### 5.1 文档二值化

```python
"""
示例6：文档图像二值化
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def document_binarization(image):
    """
    文档图像二值化处理
    将文档图像转换为黑白二值图，便于OCR识别
    """
    # 转换为灰度图
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 使用Otsu自动阈值
    _, binary_otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # 使用自适应阈值
    binary_adaptive = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2
    )

    return gray, binary_otsu, binary_adaptive

# 创建模拟文档图像
def create_document_image():
    """创建模拟的文档图像"""
    img = np.ones((400, 600), dtype=np.uint8) * 240  # 浅灰色背景

    # 添加模拟文字行
    for i, y in enumerate(range(50, 350, 40)):
        # 模拟不同长度的文字行
        width = np.random.randint(200, 500)
        cv2.rectangle(img, (50, y), (50 + width, y + 20), 30, -1)

    # 添加光照不均匀效果
    rows, cols = img.shape
    gradient = np.zeros_like(img, dtype=np.float32)
    for i in range(rows):
        for j in range(cols):
            gradient[i, j] = 1.0 - 0.3 * (i / rows) - 0.2 * (j / cols)

    img = (img * gradient).astype(np.uint8)

    # 添加噪声
    noise = np.random.normal(0, 5, img.shape)
    img = np.clip(img + noise, 0, 255).astype(np.uint8)

    return img

# 处理文档
doc_img = create_document_image()
gray, binary_otsu, binary_adaptive = document_binarization(doc_img)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

axes[0].imshow(gray, cmap='gray')
axes[0].set_title('Original Document\n(with uneven lighting)', fontsize=12)
axes[0].axis('off')

axes[1].imshow(binary_otsu, cmap='gray')
axes[1].set_title('Otsu Thresholding\n(global threshold)', fontsize=12)
axes[1].axis('off')

axes[2].imshow(binary_adaptive, cmap='gray')
axes[2].set_title('Adaptive Thresholding\n(local threshold)', fontsize=12)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print("对比分析：")
print("- Otsu方法：使用全局阈值，在光照不均时效果较差")
print("- 自适应方法：使用局部阈值，能更好地处理光照不均的情况")
```

### 5.2 目标提取

```python
"""
示例7：使用阈值处理提取目标
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

def extract_bright_objects(image, threshold_value=200):
    """
    提取图像中的亮色目标
    """
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # 二值化
    _, binary = cv2.threshold(gray, threshold_value, 255, cv2.THRESH_BINARY)

    # 形态学处理：去除噪声
    kernel = np.ones((5, 5), np.uint8)
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    # 查找轮廓
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # 在原图上绘制轮廓
    if len(image.shape) == 3:
        result = image.copy()
    else:
        result = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)

    cv2.drawContours(result, contours, -1, (0, 255, 0), 2)

    return binary, result, len(contours)

# 创建测试图像：深色背景上的亮色物体
test_img = np.zeros((400, 600), dtype=np.uint8)
test_img[:] = 30  # 深色背景

# 添加几个亮色目标
cv2.circle(test_img, (100, 200), 50, 220, -1)
cv2.rectangle(test_img, (200, 100), (350, 250), 240, -1)
cv2.ellipse(test_img, (500, 200), (60, 40), 30, 0, 360, 210, -1)

# 添加一些噪声
noise = np.random.normal(0, 10, test_img.shape)
test_img = np.clip(test_img + noise, 0, 255).astype(np.uint8)

# 提取目标
binary, result, count = extract_bright_objects(test_img, 180)

# 可视化
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

axes[0].imshow(test_img, cmap='gray')
axes[0].set_title('Original Image', fontsize=12)
axes[0].axis('off')

axes[1].imshow(binary, cmap='gray')
axes[1].set_title('Binary Mask', fontsize=12)
axes[1].axis('off')

axes[2].imshow(cv2.cvtColor(result, cv2.COLOR_BGR2RGB))
axes[2].set_title(f'Detected Objects: {count}', fontsize=12)
axes[2].axis('off')

plt.tight_layout()
plt.show()

print(f"检测到 {count} 个目标")
```

---

## 6. 本节小结

### 6.1 核心概念回顾

| 概念 | 说明 |
|------|------|
| **阈值处理** | 根据像素值与阈值的比较，将图像分割为不同区域 |
| **阈值T** | 用于判断的临界值，像素值与其比较决定输出 |
| **二值化** | 将图像转换为只有两种像素值（通常是0和255）的图像 |
| **双峰直方图** | 适合阈值分割的图像，直方图有两个明显的峰 |

### 6.2 五种阈值类型速查

```
THRESH_BINARY:     >T → 255,  ≤T → 0      (标准二值化)
THRESH_BINARY_INV: >T → 0,    ≤T → 255    (反向二值化)
THRESH_TRUNC:      >T → T,    ≤T → 不变   (截断)
THRESH_TOZERO:     >T → 不变, ≤T → 0      (置零)
THRESH_TOZERO_INV: >T → 0,    ≤T → 不变   (反置零)
```

### 6.3 下一步学习

在了解了阈值处理的基本理论后，接下来我们将学习：

1. **简单阈值**：`cv2.threshold()` 函数的详细使用
2. **自适应阈值**：处理光照不均匀图像的方法
3. **Otsu阈值**：自动确定最佳阈值的算法

---

## 7. 练习题

### 练习1：基础概念
1. 什么是阈值处理？它的主要作用是什么？
2. 列举三个阈值处理的实际应用场景。
3. 什么样的图像最适合使用阈值分割？

### 练习2：代码实践
```python
"""
练习：尝试不同阈值对分割效果的影响
"""
import cv2
import numpy as np
import matplotlib.pyplot as plt

# 创建练习用图像
img = np.zeros((200, 200), dtype=np.uint8)
img[50:150, 50:150] = 180
img = cv2.GaussianBlur(img, (15, 15), 0)
noise = np.random.normal(0, 15, img.shape)
img = np.clip(img + noise, 0, 255).astype(np.uint8)

# TODO: 尝试使用不同的阈值（50, 100, 150, 200）
# 观察分割效果的变化

# 你的代码：
# thresholds = [50, 100, 150, 200]
# for T in thresholds:
#     _, binary = cv2.threshold(img, T, 255, cv2.THRESH_BINARY)
#     # 显示结果...
```

### 练习3：思考题
1. 如果一张图像的直方图只有一个峰，应该如何选择阈值？
2. 为什么在光照不均匀的情况下，全局阈值效果不好？
3. 阈值处理和边缘检测有什么区别和联系？

---

> **下一节预告**：在下一节中，我们将详细学习 `cv2.threshold()` 函数的使用方法，包括各种参数的含义和实际应用技巧。

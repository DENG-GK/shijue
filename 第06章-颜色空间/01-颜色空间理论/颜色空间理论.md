# 颜色空间理论

> 颜色空间是图像颜色的数学表示方式。不同的颜色空间就像不同的"语言"，从不同角度描述同一种颜色。选择合适的颜色空间，可以让很多图像处理任务变得简单得多！

---

## 📖 理论部分

### 1. 什么是颜色空间？

在日常生活中，我们用"红色""天蓝色""淡黄色"这样的词语描述颜色。但计算机不懂自然语言，它需要用**数字**来精确表示颜色。

**颜色空间**就是一套用数字描述颜色的规则体系——它定义了：
- 用**哪几个分量（通道）**来描述颜色
- 每个分量的**取值范围**是多少
- 分量之间如何**组合**出最终的颜色

```
生活类比：

  描述一个位置，可以用不同的"坐标系"：
  ┌─────────────────────────────────────────────┐
  │  方式1（直角坐标）：向东走3步，向北走4步      │
  │  方式2（极坐标）  ：面朝53°方向，走5步        │
  │  方式3（地址）    ：XX路XX号                   │
  └─────────────────────────────────────────────┘
  三种方式描述的是同一个位置，只是"表达方式"不同。

  颜色空间也一样：
  ┌─────────────────────────────────────────────┐
  │  RGB：红=255，绿=0，蓝=0     → 纯红色        │
  │  HSV：色调=0，饱和度=255，明度=255 → 纯红色   │
  │  Lab：L=53，a=80，b=67       → 纯红色        │
  └─────────────────────────────────────────────┘
  同一种红色，在不同颜色空间中有不同的数值表示。
```

> 💡 **为什么需要多种颜色空间？** 因为不同的任务适合不同的描述方式。就像用"经纬度"适合航海导航，用"街道门牌"适合寄快递。

---

### 2. RGB / BGR 颜色空间

#### 2.1 RGB 基本概念

RGB 是最常见的颜色空间，用**红（Red）、绿（Green）、蓝（Blue）**三种基色的混合来表示颜色：

```
RGB 三原色混合示意：

        红 (R)
        /    \
       /      \
      /  黄色  \
     /  R+G     \
    /            \
   /    白色      \
  /   R+G+B       \
 /                  \
绿 (G) ——— 青色 ——— 蓝 (B)
          G+B

  红 + 绿 = 黄色
  红 + 蓝 = 品红/洋红
  绿 + 蓝 = 青色
  红 + 绿 + 蓝 = 白色
  无光 = 黑色（加色混合）
```

这是一种**加色混合（Additive Mixing）**模型——光线叠加越多越亮，三色全开就是白色，全关就是黑色。这与显示器、手机屏幕的发光原理一致。

#### 2.2 数值范围

在 OpenCV 中（8位图像）：

| 通道 | 含义 | 范围 | 最小值含义 | 最大值含义 |
|------|------|------|------------|------------|
| R | 红色分量 | 0-255 | 无红色 | 最强红色 |
| G | 绿色分量 | 0-255 | 无绿色 | 最强绿色 |
| B | 蓝色分量 | 0-255 | 无蓝色 | 最强蓝色 |

常见颜色的 RGB 值：

```python
# 基本颜色
黑色   = (0,   0,   0)      # 三色全关
白色   = (255, 255, 255)    # 三色全开
红色   = (255, 0,   0)      # 只开红
绿色   = (0,   255, 0)      # 只开绿
蓝色   = (0,   0,   255)    # 只开蓝
黄色   = (255, 255, 0)      # 红+绿
青色   = (0,   255, 255)    # 绿+蓝
品红   = (255, 0,   255)    # 红+蓝

# 其他常见颜色
橙色   = (255, 165, 0)
粉色   = (255, 192, 203)
灰色   = (128, 128, 128)    # 三色相等 → 灰色
```

#### 2.3 BGR 顺序（OpenCV 特殊之处！）

⚠️ **这是 OpenCV 最大的坑之一：**

大多数图像库（如 Pillow、matplotlib）使用 **RGB** 顺序，但 OpenCV 使用 **BGR** 顺序！

```
通道顺序对比：

  通常的 RGB 顺序：
  ┌──────┬──────┬──────┐
  │ R=0  │ G=1  │ B=2  │   → 红、绿、蓝
  └──────┴──────┴──────┘

  OpenCV 的 BGR 顺序：
  ┌──────┬──────┬──────┐
  │ B=0  │ G=1  │ R=2  │   → 蓝、绿、红
  └──────┴──────┴──────┘

  同样是纯红色：
    RGB：(255, 0, 0)     ← Pillow / matplotlib
    BGR：(0, 0, 255)     ← OpenCV
```

> 💡 **为什么 OpenCV 用 BGR？** 历史原因——早期的相机和视频设备使用 BGR 格式，OpenCV 沿用了这个传统。

```python
import cv2
import numpy as np

# 在 OpenCV 中创建纯红色像素
red_pixel_bgr = np.array([0, 0, 255], dtype=np.uint8)   # BGR: 蓝=0, 绿=0, 红=255

# 用 matplotlib 显示时需要转换
img_bgr = cv2.imread("photo.jpg")          # OpenCV 读取 → BGR
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)  # 转为 RGB
# 然后才能用 plt.imshow(img_rgb) 正确显示
```

> ⚠️ **常见错误：** 直接用 `plt.imshow()` 显示 OpenCV 读取的图像，红色会变蓝色、蓝色会变红色！

---

### 3. HSV 颜色空间

#### 3.1 为什么需要 HSV？

RGB 颜色空间虽然直观，但有一个大问题——**三个通道同时影响颜色的感知**：

```
问题示例：如何在 RGB 中找出所有"红色"像素？

  纯红 = (255, 0, 0)     ✓ 没问题
  深红 = (139, 0, 0)     ✓ R大，GB小
  浅红 = (255, 182, 193) ？ 这是"粉色"，算不算红色？
  暗红 = (100, 20, 20)   ？ G和B不是0，但看起来是暗红...
  橙红 = (255, 69, 0)    ？ G=69，算红还是算橙？

  → 在 RGB 中，很难用简单的规则定义"红色的范围"
```

HSV 颜色空间解决了这个问题！它将颜色分解为三个**独立的、符合人类直觉**的维度。

#### 3.2 HSV 三个通道

HSV 代表：**H**ue（色调）、**S**aturation（饱和度）、**V**alue（明度）

```
HSV 圆柱体模型：

          明度 V ↑
          (亮度)  │
                  │
            255   │     ╭───────╮
                  │   ╭─┤ 亮色彩 ├─╮
                  │  │  ╰───┬───╯  │
                  │  │      │      │  ← 饱和度 S
                  │  │ 纯白 │ 鲜艳 │    (从内到外)
                  │  │ S=0  │ S=255│
                  │  ╰──────┴──────╯
              0   │     (黑色)
                  └──────────────────→ 色调 H
                  0°   60° 120° 180°   (绕一圈)

  色调 H（0-179）：决定"是什么颜色"
    → 像色轮上的角度，0°=红，60°=绿，120°=蓝
  饱和度 S（0-255）：决定"颜色有多鲜艳"
    → 0=灰色（无色彩），255=最鲜艳
  明度 V（0-255）：决定"有多亮"
    → 0=全黑，255=最亮
```

#### 3.3 HSV 在 OpenCV 中的范围

⚠️ **这是另一个常见的坑：**

```
不同平台的 H 值范围：

  ┌─────────────┬──────────┬──────────┬──────────┐
  │   平台       │  H 范围  │  S 范围  │  V 范围  │
  ├─────────────┼──────────┼──────────┼──────────┤
  │ 标准 HSV     │ 0°-360° │ 0%-100% │ 0%-100% │
  │ OpenCV (8位) │ 0-179   │ 0-255   │ 0-255   │
  │ Photoshop    │ 0°-360° │ 0%-100% │ 0%-100% │
  │ CSS/Web      │ 0°-360° │ 0%-100% │ 0%-100% │
  └─────────────┴──────────┴──────────┴──────────┘

  OpenCV 的 H 范围是 0-179（而不是 0-360），因为：
  360 超过了 uint8 的最大值 255，所以 OpenCV 将角度除以 2
  标准 H=60° → OpenCV H=30
  标准 H=120° → OpenCV H=60
  标准 H=360° → OpenCV H=180（实际最大存179）
```

#### 3.4 HSV 色轮速查表

这是 OpenCV 中 H 值与颜色的对应关系：

```
OpenCV HSV 色轮（H 值 0-179）：

  H=0         H=15        H=30        H=45
  ┌──┐        ┌──┐        ┌──┐        ┌──┐
  │红│──────→│橙│──────→│黄│──────→│黄绿│
  └──┘        └──┘        └──┘        └──┘

  H=60        H=75        H=90        H=105
  ┌──┐        ┌──┐        ┌──┐        ┌──┐
  │绿│──────→│青绿│────→│青│──────→│蓝青│
  └──┘        └──┘        └──┘        └──┘

  H=120       H=135       H=150       H=165→179
  ┌──┐        ┌──┐        ┌──┐        ┌──┐
  │蓝│──────→│紫│──────→│品红│────→│红紫│→回到红
  └──┘        └──┘        └──┘        └──┘
```

常用颜色的 HSV 范围（OpenCV 中）：

| 颜色 | H 下界 | H 上界 | S 下界 | S 上界 | V 下界 | V 上界 | 备注 |
|------|--------|--------|--------|--------|--------|--------|------|
| 红色① | 0 | 10 | 100 | 255 | 100 | 255 | 低H端 |
| 红色② | 160 | 179 | 100 | 255 | 100 | 255 | 高H端，需取并集 |
| 橙色 | 10 | 25 | 100 | 255 | 100 | 255 | |
| 黄色 | 25 | 35 | 100 | 255 | 100 | 255 | |
| 绿色 | 35 | 85 | 50 | 255 | 50 | 255 | 范围较宽 |
| 青色 | 85 | 100 | 100 | 255 | 100 | 255 | |
| 蓝色 | 100 | 130 | 50 | 255 | 50 | 255 | |
| 紫色 | 130 | 160 | 50 | 255 | 50 | 255 | |

> 💡 **红色的特殊性：** 红色横跨色轮的起点和终点（H=0附近和H=179附近），所以需要两个范围取并集才能完整提取。

---

### 4. YCrCb 颜色空间

#### 4.1 设计动机

YCrCb 颜色空间将颜色信息分为**亮度**和**色度**两部分，这在视频压缩和传输中非常有用：

```
为什么要分离亮度和色度？

  人眼对亮度变化比对颜色变化更敏感！

  ┌─────────────────────────────────────────────┐
  │  实验：                                      │
  │  1. 把一张彩色照片转成灰度 → 还能认出内容     │
  │  2. 只保留颜色、去掉亮度信息 → 很难看清       │
  │                                              │
  │  结论：亮度信息比颜色信息更重要               │
  │  应用：可以对颜色信息做更强的压缩！           │
  └─────────────────────────────────────────────┘

  → JPEG、H.264 视频编码都利用了这一点
  → 亮度通道保留高分辨率，色度通道可以降采样
```

#### 4.2 三个通道

| 通道 | 名称 | 含义 | 范围(OpenCV) |
|------|------|------|-------------|
| Y | 亮度(Luma) | 图像的明暗信息 | 0-255 |
| Cr | 红色色度 | 红色分量与亮度的差值 | 0-255 |
| Cb | 蓝色色度 | 蓝色分量与亮度的差值 | 0-255 |

```
YCrCb 通道分离示意：

  原始彩色图像
  ┌──────────┐
  │  🌅      │
  │  彩色    │
  └──────────┘
       │
       ├── Y 通道 ──→ 灰度图（亮暗信息）
       │                 看起来像黑白照片
       │
       ├── Cr 通道 ─→ 红色偏移量
       │                 亮=偏红，暗=偏青
       │
       └── Cb 通道 ─→ 蓝色偏移量
                        亮=偏蓝，暗=偏黄
```

#### 4.3 典型应用：肤色检测

YCrCb 颜色空间的一个经典应用是**肤色检测**。研究发现，不同肤色在 YCrCb 空间的 Cr-Cb 平面上聚集在相近的区域：

```python
# 肤色在 YCrCb 空间的典型范围
# 不同肤色（白、黄、棕、黑）在 Cr-Cb 上的差异比在 RGB 中小得多
lower_skin = np.array([0, 133, 77])    # [Y_min, Cr_min, Cb_min]
upper_skin = np.array([255, 173, 127])  # [Y_max, Cr_max, Cb_max]

ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)
mask = cv2.inRange(ycrcb, lower_skin, upper_skin)
```

---

### 5. Lab 颜色空间

#### 5.1 感知均匀性

Lab 颜色空间（也叫 CIELAB）的最大特点是**感知均匀（Perceptually Uniform）**：

```
什么是感知均匀？

  在 RGB 空间中：
  ┌─────────────────────────────────────────────┐
  │  (0,0,0) → (10,0,0)  的颜色变化 → 肉眼几乎看不出  │
  │  (200,0,0) → (210,0,0) 的颜色变化 → 肉眼也看不出   │
  │  (0,0,0) → (0,10,0)  的颜色变化 → 好像比红色明显？  │
  │                                                      │
  │  → RGB 中相同的数值差异，感知到的颜色差异不同         │
  └─────────────────────────────────────────────┘

  在 Lab 空间中：
  ┌─────────────────────────────────────────────┐
  │  任何两个颜色之间的"数值距离"                │
  │  ≈ 人眼感知到的"颜色差异"                    │
  │                                              │
  │  → 数值差 10，不管在哪个区域，看起来都差不多  │
  └─────────────────────────────────────────────┘
```

#### 5.2 三个通道

| 通道 | 名称 | 含义 | 范围(OpenCV) |
|------|------|------|-------------|
| L | Lightness(亮度) | 黑(0)到白(255) | 0-255 |
| a | 绿-红轴 | 绿(0)←→红(255)，中间(128)为灰 | 0-255 |
| b | 蓝-黄轴 | 蓝(0)←→黄(255)，中间(128)为灰 | 0-255 |

```
Lab 颜色平面示意（a-b 平面）：

              +b (黄色)
               ↑
               │
    绿黄       │       红黄
               │
  -a ─────────┼─────────→ +a
  (绿色)       │          (红色)
               │
    绿蓝       │       红蓝
               │
               ↓
              -b (蓝色)

  L 轴垂直于平面：
  L=0 → 全黑（最底层）
  L=255 → 全白（最顶层）
```

> 💡 **注意：** OpenCV 中 Lab 的范围经过了缩放——L: 0-255（对应标准 0-100），a 和 b: 0-255（对应标准 -128 到 127，加了 128 的偏移）。

#### 5.3 典型应用

```python
# 应用1：计算两种颜色的"感知差异"
color1_lab = cv2.cvtColor(np.uint8([[[255, 0, 0]]]), cv2.COLOR_BGR2Lab)[0][0]
color2_lab = cv2.cvtColor(np.uint8([[[250, 10, 10]]]), cv2.COLOR_BGR2Lab)[0][0]
delta_e = np.sqrt(np.sum((color1_lab.astype(float) - color2_lab.astype(float))**2))
print(f"颜色差异 ΔE = {delta_e:.2f}")

# 应用2：调整图像亮度（只修改 L 通道，不影响色彩）
lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)
l, a, b = cv2.split(lab)
l = cv2.add(l, 30)        # 增加亮度
lab_bright = cv2.merge([l, a, b])
result = cv2.cvtColor(lab_bright, cv2.COLOR_Lab2BGR)

# 应用3：CLAHE 自适应直方图均衡（在 L 通道上做，避免色彩失真）
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
l = clahe.apply(l)
```

---

### 6. 灰度颜色空间

#### 6.1 从彩色到灰度

灰度图像只有一个通道，每个像素值表示该点的亮度（0=黑，255=白）：

```
彩色 → 灰度的转换公式：

  简单平均法（不推荐）：
  Gray = (R + G + B) / 3

  加权平均法（OpenCV 使用）：
  Gray = 0.299 × R + 0.587 × G + 0.114 × B

  ┌─────────────────────────────────────────────┐
  │  为什么权重不同？                            │
  │                                              │
  │  人眼对绿色最敏感 → 权重最大（0.587）        │
  │  对红色次之       → 权重中等（0.299）        │
  │  对蓝色最不敏感   → 权重最小（0.114）        │
  │                                              │
  │  这组权重来自 ITU-R BT.601 标准              │
  └─────────────────────────────────────────────┘
```

#### 6.2 灰度图的优势

```
为什么很多算法先转灰度？

  ┌─────────────────────────────────────────────┐
  │  1. 数据量减少为 1/3                         │
  │     彩色：H × W × 3 通道                    │
  │     灰度：H × W × 1 通道                    │
  │     → 计算速度快 3 倍                        │
  │                                              │
  │  2. 减少复杂性                               │
  │     边缘检测、特征提取等算法                 │
  │     关心的是"形状和亮度变化"，不需要颜色     │
  │                                              │
  │  3. 很多经典算法只支持灰度输入               │
  │     如：Canny 边缘检测、Harris 角点检测      │
  └─────────────────────────────────────────────┘
```

```python
import cv2

# 方式1：读取时直接转灰度
gray = cv2.imread("photo.jpg", cv2.IMREAD_GRAYSCALE)

# 方式2：读取彩色后转换
img = cv2.imread("photo.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 查看形状
print(f"彩色: {img.shape}")    # (H, W, 3)
print(f"灰度: {gray.shape}")   # (H, W)  ← 注意：没有第三维！
```

---

### 7. 颜色空间选择指南

不同任务该选哪个颜色空间？这是一份实用速查表：

| 任务 | 推荐颜色空间 | 原因 |
|------|-------------|------|
| 图像显示/存储 | BGR/RGB | 标准格式，硬件直接支持 |
| 颜色过滤/检测 | HSV | 可以用 H 直接锁定颜色种类 |
| 目标追踪 | HSV | 对光照变化相对鲁棒 |
| 肤色检测 | YCrCb | 不同肤色在 Cr-Cb 平面聚集 |
| 视频压缩 | YCrCb | 可对色度通道降采样 |
| 颜色对比/匹配 | Lab | 感知均匀，ΔE 有物理意义 |
| 图像增强 | Lab | 只调 L 通道，不影响色彩 |
| 边缘检测 | 灰度 | 只需亮度信息，速度快 |
| 特征提取 | 灰度 | 减少计算量，提高速度 |
| 直方图均衡 | Lab/YCrCb | 均衡亮度通道，保持色彩 |

```
选择决策树：

  需要处理颜色吗？
  ├── 否 → 灰度（最简单最快）
  └── 是 → 需要区分颜色种类吗？
       ├── 是 → HSV（色调 H 直接对应颜色）
       └── 否 → 需要分离亮度和色彩吗？
            ├── 是 → 需要感知均匀吗？
            │    ├── 是 → Lab
            │    └── 否 → YCrCb
            └── 否 → BGR/RGB（默认即可）
```

---

### 8. 各颜色空间总结对比

```
五种颜色空间一览：

  ┌────────┬─────────────┬──────────────────────┬───────────────────┐
  │ 空间    │ 通道         │ 特点                  │ 典型应用          │
  ├────────┼─────────────┼──────────────────────┼───────────────────┤
  │ BGR    │ B, G, R      │ 加色混合，硬件友好     │ 显示、存储        │
  │ HSV    │ H, S, V      │ 接近人类感知           │ 颜色过滤、追踪    │
  │ YCrCb  │ Y, Cr, Cb   │ 亮度/色度分离          │ 视频压缩、肤色    │
  │ Lab    │ L, a, b      │ 感知均匀               │ 颜色对比、增强    │
  │ 灰度   │ 单通道       │ 仅亮度，数据量小       │ 边缘检测、特征    │
  └────────┴─────────────┴──────────────────────┴───────────────────┘
```

---

## 💻 代码实战

运行以下代码生成测试图片，后续章节会用到：

```bash
python code/generate_images.py
```

> 💡 这个脚本会在 `images/` 文件夹中生成一张包含红、绿、蓝、黄、青、紫色块的测试图。

---

## 🧠 小测验

1. OpenCV 中图像默认使用什么颜色空间？（答：BGR）
2. OpenCV HSV 中，H 的范围是多少？（答：0-179）
3. 想提取图像中的"蓝色区域"，应该用哪个颜色空间？（答：HSV）
4. 灰度转换公式中，哪个颜色的权重最大？（答：绿色，0.587）
5. 红色在 HSV 中为什么需要两个范围？（答：因为红色横跨 H=0 和 H=179）

---

## 📌 本节要点

```
✅ 颜色空间 = 用数字描述颜色的规则体系
✅ OpenCV 使用 BGR（不是 RGB！）
✅ HSV 用色调 H 直接表示颜色种类，适合颜色过滤
✅ YCrCb 分离亮度和色度，适合压缩和肤色检测
✅ Lab 感知均匀，颜色差异可以直接用数值距离衡量
✅ 灰度图数据量小、计算快，适合形状和亮度分析
✅ 选择颜色空间的核心：根据任务需求选最合适的
```

---

**下一步：** 👉 [02 - 颜色空间转换](../02-颜色空间转换/颜色空间转换.md)

# 颜色空间应用

> 颜色空间的理论终于要派上用场了！本节将通过实际案例展示如何利用 HSV 颜色过滤提取特定颜色的物体、用 YCrCb 进行肤色检测，以及用 Lab 空间做图像增强。这些都是计算机视觉中最常用的技巧！

---

## 📖 理论部分

### 1. HSV 颜色过滤：核心流程

利用 HSV 颜色空间提取特定颜色的物体，是最常见的实际应用之一。整个流程只需要 4 步：

```
HSV 颜色过滤流程：

  步骤1：转换颜色空间
  ┌──────────┐      cv2.cvtColor()       ┌──────────┐
  │ BGR 图像  │  ─────────────────────→  │ HSV 图像  │
  └──────────┘      COLOR_BGR2HSV        └──────────┘

  步骤2：定义颜色范围
  ┌──────────────────────────────────────────────┐
  │  lower = np.array([H_min, S_min, V_min])     │
  │  upper = np.array([H_max, S_max, V_max])     │
  └──────────────────────────────────────────────┘

  步骤3：生成掩码
  ┌──────────┐      cv2.inRange()        ┌──────────┐
  │ HSV 图像  │  ─────────────────────→  │ 二值掩码  │
  └──────────┘                           │ (0或255)  │
                                         └──────────┘

  步骤4：应用掩码
  ┌──────────┐                           ┌──────────┐
  │ 原图      │   cv2.bitwise_and()      │ 提取结果  │
  │    ＋     │  ─────────────────────→  │ (只保留   │
  │ 二值掩码  │                           │  目标颜色)│
  └──────────┘                           └──────────┘
```

#### 1.1 cv2.inRange() 详解

这是颜色过滤的核心函数：

```python
import cv2
import numpy as np

# 函数签名
mask = cv2.inRange(src, lowerb, upperb)

# 参数说明：
# src    - 输入图像（通常是 HSV 图像）
# lowerb - 下界数组 [H_min, S_min, V_min]
# upperb - 上界数组 [H_max, S_max, V_max]
# mask   - 输出的二值掩码（uint8，值为 0 或 255）
```

```
cv2.inRange() 的逐像素判断逻辑：

  对于每个像素 (h, s, v)：
  ┌─────────────────────────────────────────────────┐
  │  如果 H_min ≤ h ≤ H_max                         │
  │  且 S_min ≤ s ≤ S_max                            │
  │  且 V_min ≤ v ≤ V_max                            │
  │  → mask 值 = 255（白色，表示"在范围内"）        │
  │                                                   │
  │  否则                                             │
  │  → mask 值 = 0  （黑色，表示"不在范围内"）      │
  └─────────────────────────────────────────────────┘

  结果是一张二值图：
  白色区域 = 目标颜色区域
  黑色区域 = 非目标区域
```

#### 1.2 cv2.bitwise_and() 详解

用掩码从原图中"挖出"目标区域：

```python
# 函数签名
result = cv2.bitwise_and(src1, src2, mask=mask)

# 常用方式：src1 和 src2 传同一张图
result = cv2.bitwise_and(img, img, mask=mask)
```

```
bitwise_and 与掩码的工作原理：

  原图像素        掩码值         结果
  ┌──────┐      ┌──────┐      ┌──────┐
  │[B,G,R]│  ×  │ 255  │  =  │[B,G,R]│  ← 保留
  │[B,G,R]│  ×  │  0   │  =  │[0,0,0]│  ← 变黑
  │[B,G,R]│  ×  │ 255  │  =  │[B,G,R]│  ← 保留
  └──────┘      └──────┘      └──────┘

  掩码 = 255 的位置 → 保留原始像素
  掩码 = 0   的位置 → 变为黑色（全零）
```

---

### 2. 常用颜色的 HSV 范围

这是实际开发中最常用的参考表：

#### 2.1 基本颜色范围表

| 颜色 | H 下界 | H 上界 | S 下界 | S 上界 | V 下界 | V 上界 | 特殊说明 |
|------|--------|--------|--------|--------|--------|--------|----------|
| 红色（低） | 0 | 10 | 100 | 255 | 100 | 255 | 需要两个范围 |
| 红色（高） | 160 | 179 | 100 | 255 | 100 | 255 | 取并集 |
| 橙色 | 10 | 25 | 100 | 255 | 100 | 255 | |
| 黄色 | 25 | 35 | 100 | 255 | 100 | 255 | |
| 绿色 | 35 | 85 | 50 | 255 | 50 | 255 | 范围较宽 |
| 青色 | 85 | 100 | 100 | 255 | 100 | 255 | |
| 蓝色 | 100 | 130 | 50 | 255 | 50 | 255 | |
| 紫色 | 130 | 160 | 50 | 255 | 50 | 255 | |
| 白色 | 0 | 179 | 0 | 30 | 200 | 255 | 低饱和度 + 高明度 |
| 黑色 | 0 | 179 | 0 | 255 | 0 | 50 | 低明度 |
| 灰色 | 0 | 179 | 0 | 50 | 50 | 200 | 低饱和度 + 中等明度 |

#### 2.2 红色的特殊处理

```
为什么红色需要特殊处理？

  HSV 色轮是一个环形：

  H=0 ──→ H=30 ──→ H=60 ──→ ... ──→ H=150 ──→ H=179 ─┐
  红色      黄色      绿色              品红      红紫     │
  ↑                                                       │
  └───────────────── 红色跨越了这里！ ←──────────────────┘

  红色在 H=0 附近和 H=179 附近都有分布
  → 必须用两个范围取并集！
```

```python
import cv2
import numpy as np

def extract_red(img):
    """提取图像中的红色区域"""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # 范围1：H = 0-10（红色的低端）
    lower_red1 = np.array([0, 100, 100])
    upper_red1 = np.array([10, 255, 255])
    mask1 = cv2.inRange(hsv, lower_red1, upper_red1)

    # 范围2：H = 160-179（红色的高端）
    lower_red2 = np.array([160, 100, 100])
    upper_red2 = np.array([179, 255, 255])
    mask2 = cv2.inRange(hsv, lower_red2, upper_red2)

    # 两个掩码取并集
    mask = mask1 | mask2    # 或：mask = cv2.bitwise_or(mask1, mask2)

    # 应用掩码
    result = cv2.bitwise_and(img, img, mask=mask)
    return result, mask
```

---

### 3. 完整的颜色过滤示例

#### 3.1 提取单一颜色

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("color_shapes.png")
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# === 提取蓝色区域 ===
lower_blue = np.array([100, 50, 50])
upper_blue = np.array([130, 255, 255])

mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)
result_blue = cv2.bitwise_and(img, img, mask=mask_blue)

print(f"掩码 shape: {mask_blue.shape}")     # (H, W) — 单通道
print(f"掩码 dtype: {mask_blue.dtype}")      # uint8
print(f"掩码值范围: {mask_blue.min()} - {mask_blue.max()}")  # 0 - 255
print(f"白色像素比例: {(mask_blue > 0).sum() / mask_blue.size * 100:.1f}%")
```

#### 3.2 提取多种颜色

```python
import cv2
import numpy as np

img = cv2.imread("color_shapes.png")
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# 定义多种颜色的范围
color_ranges = {
    "红色": ([0, 100, 100], [10, 255, 255], [160, 100, 100], [179, 255, 255]),
    "绿色": ([35, 50, 50], [85, 255, 255]),
    "蓝色": ([100, 50, 50], [130, 255, 255]),
    "黄色": ([25, 100, 100], [35, 255, 255]),
}

for name, ranges in color_ranges.items():
    if len(ranges) == 4:
        # 红色需要两个范围
        mask1 = cv2.inRange(hsv, np.array(ranges[0]), np.array(ranges[1]))
        mask2 = cv2.inRange(hsv, np.array(ranges[2]), np.array(ranges[3]))
        mask = mask1 | mask2
    else:
        mask = cv2.inRange(hsv, np.array(ranges[0]), np.array(ranges[1]))

    result = cv2.bitwise_and(img, img, mask=mask)
    pixel_count = (mask > 0).sum()
    print(f"{name}: 检测到 {pixel_count} 个像素")
```

---

### 4. 用滑动条调试颜色范围

在实际开发中，很难一次就找到准确的 HSV 范围。OpenCV 提供了 `createTrackbar()` 来创建滑动条，方便实时调试：

```python
import cv2
import numpy as np

def nothing(x):
    """滑动条的回调函数（必须有，但可以为空）"""
    pass

# 读取图像
img = cv2.imread("photo.jpg")
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# 创建窗口和滑动条
cv2.namedWindow("HSV Tuner")
cv2.createTrackbar("H min", "HSV Tuner", 0, 179, nothing)
cv2.createTrackbar("H max", "HSV Tuner", 179, 179, nothing)
cv2.createTrackbar("S min", "HSV Tuner", 0, 255, nothing)
cv2.createTrackbar("S max", "HSV Tuner", 255, 255, nothing)
cv2.createTrackbar("V min", "HSV Tuner", 0, 255, nothing)
cv2.createTrackbar("V max", "HSV Tuner", 255, 255, nothing)

while True:
    # 获取滑动条的当前值
    h_min = cv2.getTrackbarPos("H min", "HSV Tuner")
    h_max = cv2.getTrackbarPos("H max", "HSV Tuner")
    s_min = cv2.getTrackbarPos("S min", "HSV Tuner")
    s_max = cv2.getTrackbarPos("S max", "HSV Tuner")
    v_min = cv2.getTrackbarPos("V min", "HSV Tuner")
    v_max = cv2.getTrackbarPos("V max", "HSV Tuner")

    # 创建掩码
    lower = np.array([h_min, s_min, v_min])
    upper = np.array([h_max, s_max, v_max])
    mask = cv2.inRange(hsv, lower, upper)

    # 应用掩码
    result = cv2.bitwise_and(img, img, mask=mask)

    # 显示结果
    cv2.imshow("Original", img)
    cv2.imshow("Mask", mask)
    cv2.imshow("Result", result)

    # 按 ESC 退出
    if cv2.waitKey(1) & 0xFF == 27:
        print(f"最终范围: H=[{h_min},{h_max}], S=[{s_min},{s_max}], V=[{v_min},{v_max}]")
        break

cv2.destroyAllWindows()
```

```
滑动条调试技巧：

  ┌─────────────────────────────────────────────────┐
  │  1. 先调 H（色调），锁定颜色种类                │
  │     → 把 S/V 范围先设到最大                      │
  │     → 只调 H_min 和 H_max                        │
  │                                                   │
  │  2. 再调 S（饱和度），排除灰色区域              │
  │     → S_min 提高可以去掉浅色/灰色               │
  │                                                   │
  │  3. 最后调 V（明度），排除过暗/过亮区域         │
  │     → V_min 提高可以去掉阴影                     │
  │     → V_max 降低可以去掉高光                     │
  │                                                   │
  │  4. 记录最终的 6 个值，用在代码中               │
  └─────────────────────────────────────────────────┘
```

---

### 5. 掩码的后处理

直接用 `inRange()` 生成的掩码通常有噪点和空洞，需要做后处理：

#### 5.1 形态学操作清理掩码

```python
import cv2
import numpy as np

# 假设 mask 是 inRange 生成的二值掩码

# === 去噪：开运算（先腐蚀后膨胀）===
kernel = np.ones((5, 5), np.uint8)
mask_clean = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

# === 填充空洞：闭运算（先膨胀后腐蚀）===
mask_filled = cv2.morphologyEx(mask_clean, cv2.MORPH_CLOSE, kernel)

# === 或者分步操作 ===
# 腐蚀：去掉小噪点
mask_erode = cv2.erode(mask, kernel, iterations=1)
# 膨胀：恢复边缘
mask_dilate = cv2.dilate(mask_erode, kernel, iterations=1)
```

```
形态学操作效果：

  原始掩码           开运算后          闭运算后
  ┌──────────┐     ┌──────────┐     ┌──────────┐
  │ ██ . █ . │     │ ██       │     │ ████     │
  │ ██ . . . │ ──→ │ ██       │ ──→ │ ████     │
  │ .  . . █ │     │          │     │          │
  └──────────┘     └──────────┘     └──────────┘
    有噪点和空洞     噪点被去除       空洞被填充

  . = 黑色（0），█ = 白色（255）
```

#### 5.2 高斯模糊平滑边缘

```python
# 对掩码做高斯模糊，使边缘更平滑
mask_smooth = cv2.GaussianBlur(mask_filled, (7, 7), 0)

# 重新二值化（模糊后值不再是严格的 0/255）
_, mask_smooth = cv2.threshold(mask_smooth, 127, 255, cv2.THRESH_BINARY)
```

---

### 6. YCrCb 肤色检测

#### 6.1 原理

不同肤色在 YCrCb 空间的 Cr-Cb 平面上聚集在一个相对固定的区域，这使得肤色检测变得简单：

```
肤色在 YCrCb 空间的分布：

  Cb (蓝色色度)
  255 ┌─────────────────────────┐
      │                         │
      │                         │
  127 │       ┌─────────┐       │
      │       │ 肤色区域 │       │
   77 │       │ Cr:133-173│      │
      │       │ Cb: 77-127│      │
      │       └─────────┘       │
    0 └─────────────────────────┘
      0       133      173     255
                  Cr (红色色度)

  Y 通道（亮度）不受限制 → 不同肤色深浅都能检测到
```

#### 6.2 实现代码

```python
import cv2
import numpy as np

def detect_skin(img):
    """使用 YCrCb 颜色空间检测肤色"""
    # 转换到 YCrCb
    ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

    # 肤色范围（适用于大多数肤色）
    lower_skin = np.array([0, 133, 77])
    upper_skin = np.array([255, 173, 127])

    # 生成掩码
    mask = cv2.inRange(ycrcb, lower_skin, upper_skin)

    # 形态学清理
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    # 应用掩码
    result = cv2.bitwise_and(img, img, mask=mask)

    return result, mask

# 使用
img = cv2.imread("portrait.jpg")
skin_result, skin_mask = detect_skin(img)
cv2.imwrite("skin_detected.png", skin_result)
```

#### 6.3 HSV 肤色检测（替代方案）

```python
def detect_skin_hsv(img):
    """使用 HSV 颜色空间检测肤色"""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # HSV 中的肤色范围
    lower_skin = np.array([0, 20, 70])
    upper_skin = np.array([20, 255, 255])

    mask = cv2.inRange(hsv, lower_skin, upper_skin)
    result = cv2.bitwise_and(img, img, mask=mask)
    return result, mask
```

```
两种肤色检测方法对比：

  ┌───────────────┬──────────────┬──────────────┐
  │               │ YCrCb 方法   │ HSV 方法     │
  ├───────────────┼──────────────┼──────────────┤
  │ 光照敏感性    │ 较低          │ 较高         │
  │ 检测准确度    │ 较高          │ 中等         │
  │ 误检率        │ 较低          │ 较高         │
  │ 适用场景      │ 人脸/手势检测 │ 简单应用     │
  └───────────────┴──────────────┴──────────────┘

  推荐：优先使用 YCrCb 方法
```

---

### 7. Lab 空间图像增强

#### 7.1 CLAHE 自适应直方图均衡

在 Lab 空间的 L 通道上做直方图均衡，可以增强对比度而不影响色彩：

```python
import cv2

def enhance_contrast(img):
    """使用 CLAHE 增强图像对比度"""
    # 转换到 Lab
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)

    # 分离通道
    l, a, b = cv2.split(lab)

    # 创建 CLAHE 对象
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))

    # 只对 L 通道做均衡
    l_enhanced = clahe.apply(l)

    # 合并回去
    lab_enhanced = cv2.merge([l_enhanced, a, b])

    # 转回 BGR
    result = cv2.cvtColor(lab_enhanced, cv2.COLOR_Lab2BGR)
    return result
```

```
为什么在 Lab 空间做均衡？

  ❌ 在 BGR 空间直接做均衡：
  ┌─────────────────────────────────────────────────┐
  │  对 B、G、R 三个通道分别均衡                    │
  │  → 三个通道独立变化 → 颜色失真！               │
  │  原本是橙色的物体可能变成绿色                   │
  └─────────────────────────────────────────────────┘

  ✅ 在 Lab 空间做均衡：
  ┌─────────────────────────────────────────────────┐
  │  只对 L 通道（亮度）做均衡                      │
  │  a 和 b 通道（色彩信息）保持不变                │
  │  → 对比度增强 + 颜色保持！                      │
  └─────────────────────────────────────────────────┘
```

#### 7.2 自动白平衡

```python
import cv2
import numpy as np

def auto_white_balance(img):
    """使用 Lab 空间的简单白平衡算法"""
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab).astype(np.float32)

    # 计算 a 和 b 通道的均值
    avg_a = np.mean(lab[:, :, 1])
    avg_b = np.mean(lab[:, :, 2])

    # 将均值调整到中性灰（128）
    lab[:, :, 1] = lab[:, :, 1] - ((avg_a - 128) * (lab[:, :, 0] / 255.0) * 1.1)
    lab[:, :, 2] = lab[:, :, 2] - ((avg_b - 128) * (lab[:, :, 0] / 255.0) * 1.1)

    # 裁剪到有效范围
    lab = np.clip(lab, 0, 255).astype(np.uint8)

    # 转回 BGR
    result = cv2.cvtColor(lab, cv2.COLOR_Lab2BGR)
    return result
```

---

### 8. 实用技巧总结

#### 8.1 选择颜色空间的实战指南

```
任务 → 颜色空间的选择路径：

  "我想提取某种颜色的物体"
  └→ HSV 颜色过滤（用 H 锁定颜色，S/V 排除噪声）

  "我想检测人的皮肤/手/脸"
  └→ YCrCb 肤色检测（Cr-Cb 平面上肤色聚集）

  "我想增强图像对比度但不改变颜色"
  └→ Lab 空间（只处理 L 通道）

  "我想比较两种颜色的相似度"
  └→ Lab 空间（计算欧氏距离 = 感知差异 ΔE）

  "我想去掉彩色噪声"
  └→ YCrCb 或 Lab（在色度通道上做降噪）
```

#### 8.2 常见坑和解决方案

```
常见问题排查清单：

  ┌─────────────────────────────────────────────────┐
  │  ❓ 问题：检测不到任何颜色                      │
  │  ✅ 检查：HSV 范围是否正确？数据类型是 uint8？  │
  │          是否忘记了 cvtColor 转换？              │
  │                                                   │
  │  ❓ 问题：检测到太多噪声                        │
  │  ✅ 检查：S_min 和 V_min 是否设得太低？         │
  │          试试增加形态学后处理                     │
  │                                                   │
  │  ❓ 问题：目标区域有空洞                        │
  │  ✅ 检查：颜色范围是否太窄？                    │
  │          用闭运算填充空洞                         │
  │                                                   │
  │  ❓ 问题：光照变化导致检测不稳定                │
  │  ✅ 检查：V 的范围是否太窄？                    │
  │          试试放宽 V 的范围或做预处理              │
  │                                                   │
  │  ❓ 问题：红色检测不完整                        │
  │  ✅ 检查：是否用了两个范围取并集？              │
  └─────────────────────────────────────────────────┘
```

---

## 💻 代码实战

### 实战1：基本颜色过滤

```python
import cv2
import numpy as np
import os

IMAGES_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "images")
SRC_IMG = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                       "..", "..", "01-颜色空间理论", "images", "color_shapes.png")

# 读取图像
if not os.path.exists(SRC_IMG):
    print("创建测试图像...")
    img = np.zeros((400, 600, 3), dtype=np.uint8)
    cv2.circle(img, (100, 100), 60, (0, 0, 255), -1)    # 红色圆
    cv2.circle(img, (300, 100), 60, (0, 255, 0), -1)    # 绿色圆
    cv2.circle(img, (500, 100), 60, (255, 0, 0), -1)    # 蓝色圆
    cv2.rectangle(img, (40, 220), (180, 360), (0, 255, 255), -1)   # 黄色矩形
else:
    img = cv2.imread(SRC_IMG)

os.makedirs(IMAGES_DIR, exist_ok=True)

# 转换到 HSV
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# === 提取红色 ===
lower_red1 = np.array([0, 100, 100])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([160, 100, 100])
upper_red2 = np.array([179, 255, 255])
mask_red = cv2.inRange(hsv, lower_red1, upper_red1) | cv2.inRange(hsv, lower_red2, upper_red2)
result_red = cv2.bitwise_and(img, img, mask=mask_red)
cv2.imwrite(os.path.join(IMAGES_DIR, "result_red.png"), result_red)
print(f"红色像素: {(mask_red > 0).sum()}")

# === 提取绿色 ===
mask_green = cv2.inRange(hsv, np.array([35, 50, 50]), np.array([85, 255, 255]))
result_green = cv2.bitwise_and(img, img, mask=mask_green)
cv2.imwrite(os.path.join(IMAGES_DIR, "result_green.png"), result_green)
print(f"绿色像素: {(mask_green > 0).sum()}")

# === 提取蓝色 ===
mask_blue = cv2.inRange(hsv, np.array([100, 50, 50]), np.array([130, 255, 255]))
result_blue = cv2.bitwise_and(img, img, mask=mask_blue)
cv2.imwrite(os.path.join(IMAGES_DIR, "result_blue.png"), result_blue)
print(f"蓝色像素: {(mask_blue > 0).sum()}")

# === 提取黄色 ===
mask_yellow = cv2.inRange(hsv, np.array([20, 100, 100]), np.array([35, 255, 255]))
result_yellow = cv2.bitwise_and(img, img, mask=mask_yellow)
cv2.imwrite(os.path.join(IMAGES_DIR, "result_yellow.png"), result_yellow)
print(f"黄色像素: {(mask_yellow > 0).sum()}")

# 保存对比图
comparison = np.hstack([img, result_red, result_green, result_blue])
cv2.imwrite(os.path.join(IMAGES_DIR, "color_filter_comparison.png"), comparison)
print(f"对比图已保存: {os.path.join(IMAGES_DIR, 'color_filter_comparison.png')}")
```

### 实战2：颜色替换

```python
import cv2
import numpy as np

def replace_color(img, old_lower, old_upper, new_color_bgr):
    """将图像中的某种颜色替换为另一种颜色"""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # 找到目标颜色区域
    mask = cv2.inRange(hsv, np.array(old_lower), np.array(old_upper))

    # 形态学清理
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    # 替换颜色
    result = img.copy()
    result[mask > 0] = new_color_bgr

    return result

# 将绿色替换为紫色
img = cv2.imread("color_shapes.png")
if img is not None:
    result = replace_color(img,
                          old_lower=[35, 50, 50],
                          old_upper=[85, 255, 255],
                          new_color_bgr=[255, 0, 255])  # 紫色 (BGR)
    cv2.imwrite("color_replaced.png", result)
    print("颜色替换完成")
```

### 实战3：颜色统计分析

```python
import cv2
import numpy as np

def analyze_colors(img):
    """分析图像中各颜色的占比"""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    total_pixels = img.shape[0] * img.shape[1]

    color_ranges = {
        "红色":   {"ranges": [([0,100,100],[10,255,255]), ([160,100,100],[179,255,255])]},
        "橙色":   {"ranges": [([10,100,100],[25,255,255])]},
        "黄色":   {"ranges": [([25,100,100],[35,255,255])]},
        "绿色":   {"ranges": [([35,50,50],[85,255,255])]},
        "青色":   {"ranges": [([85,100,100],[100,255,255])]},
        "蓝色":   {"ranges": [([100,50,50],[130,255,255])]},
        "紫色":   {"ranges": [([130,50,50],[160,255,255])]},
    }

    print(f"图像尺寸: {img.shape[:2]}, 总像素: {total_pixels}")
    print("-" * 40)

    for name, info in color_ranges.items():
        mask = np.zeros(img.shape[:2], dtype=np.uint8)
        for lower, upper in info["ranges"]:
            m = cv2.inRange(hsv, np.array(lower), np.array(upper))
            mask = mask | m

        count = (mask > 0).sum()
        ratio = count / total_pixels * 100
        bar = "█" * int(ratio / 2) + "░" * (50 - int(ratio / 2))
        print(f"  {name}: {bar} {ratio:5.1f}% ({count} px)")

# 使用
img = cv2.imread("color_shapes.png")
if img is not None:
    analyze_colors(img)
```

### 实战4：Lab 对比度增强

```python
import cv2
import numpy as np

def enhance_image(img, clip_limit=2.0, tile_size=8):
    """使用 CLAHE 在 Lab 空间增强图像"""
    # BGR → Lab
    lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)
    l, a, b = cv2.split(lab)

    # 对 L 通道应用 CLAHE
    clahe = cv2.createCLAHE(clipLimit=clip_limit,
                            tileGridSize=(tile_size, tile_size))
    l_enhanced = clahe.apply(l)

    # 合并并转回 BGR
    lab_enhanced = cv2.merge([l_enhanced, a, b])
    result = cv2.cvtColor(lab_enhanced, cv2.COLOR_Lab2BGR)

    return result

# 对比不同参数
img = cv2.imread("dark_photo.jpg")
if img is not None:
    enhanced_mild = enhance_image(img, clip_limit=1.0)    # 轻度增强
    enhanced_strong = enhance_image(img, clip_limit=4.0)  # 强力增强

    comparison = np.hstack([img, enhanced_mild, enhanced_strong])
    cv2.imwrite("enhancement_comparison.png", comparison)
    print("对比度增强对比图已保存")
```

### 实战5：综合应用 - 颜色目标追踪框架

```python
import cv2
import numpy as np

def track_color_object(img, lower_hsv, upper_hsv, min_area=500):
    """
    检测图像中特定颜色的物体，返回边界框

    参数:
        img: BGR 图像
        lower_hsv: HSV 下界
        upper_hsv: HSV 上界
        min_area: 最小面积阈值（过滤噪声）

    返回:
        result: 标注了检测结果的图像
        bboxes: 检测到的边界框列表 [(x,y,w,h), ...]
    """
    result = img.copy()
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # 生成掩码
    mask = cv2.inRange(hsv, np.array(lower_hsv), np.array(upper_hsv))

    # 形态学后处理
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    # 查找轮廓
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    bboxes = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area > min_area:
            x, y, w, h = cv2.boundingRect(cnt)
            bboxes.append((x, y, w, h))

            # 绘制边界框和面积
            cv2.rectangle(result, (x, y), (x+w, y+h), (0, 255, 0), 2)
            cv2.putText(result, f"Area:{area:.0f}",
                       (x, y-10), cv2.FONT_HERSHEY_SIMPLEX,
                       0.5, (0, 255, 0), 1)

    return result, bboxes

# 检测红色物体
img = cv2.imread("color_shapes.png")
if img is not None:
    # 红色的两个范围需要分别处理
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    mask1 = cv2.inRange(hsv, np.array([0, 100, 100]), np.array([10, 255, 255]))
    mask2 = cv2.inRange(hsv, np.array([160, 100, 100]), np.array([179, 255, 255]))
    mask_red = mask1 | mask2

    result = img.copy()
    contours, _ = cv2.findContours(mask_red, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for cnt in contours:
        if cv2.contourArea(cnt) > 100:
            x, y, w, h = cv2.boundingRect(cnt)
            cv2.rectangle(result, (x, y), (x+w, y+h), (0, 255, 0), 2)
            print(f"检测到红色物体: x={x}, y={y}, w={w}, h={h}")

    cv2.imwrite("red_detection.png", result)
    print("红色物体检测完成")
```

---

运行完整示例：

```bash
python code/color_application.py
```

---

## 🧠 小测验

1. HSV 颜色过滤的四个步骤是什么？（答：转HSV → 定义范围 → inRange生成掩码 → bitwise_and应用掩码）
2. 为什么红色需要两个 HSV 范围？（答：红色横跨色轮的0°和360°边界，在OpenCV中是H=0和H=179）
3. `cv2.inRange()` 返回的掩码是什么类型？（答：uint8单通道，值为0或255）
4. 用什么形态学操作去除掩码中的小噪点？（答：开运算 MORPH_OPEN = 先腐蚀后膨胀）
5. 为什么在 Lab 空间而不是 BGR 空间做直方图均衡？（答：Lab只调L通道不影响色彩，BGR会导致色彩失真）

---

## 📌 本节要点

```
✅ HSV 颜色过滤：cvtColor → inRange → bitwise_and
✅ 红色需要两个范围取并集（H=0~10 和 H=160~179）
✅ 用滑动条实时调试 HSV 范围（createTrackbar）
✅ 形态学后处理清理掩码噪点（开运算 + 闭运算）
✅ YCrCb 肤色检测：Cr=133-173, Cb=77-127
✅ Lab 对比度增强：只处理 L 通道，保持色彩
✅ CLAHE 是最佳的自适应直方图均衡算法
✅ 选择颜色空间的核心：任务驱动
```

---

**返回：** 👉 [第06章 - 颜色空间](../颜色空间.md) | [第07章 - 图像滤波](../../第07章-图像滤波/图像滤波.md)

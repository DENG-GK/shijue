# 颜色空间转换

> `cv2.cvtColor()` 是 OpenCV 中颜色空间转换的核心函数。本节将详细讲解各种颜色空间之间的转换方法、背后的数学原理，以及实际开发中的注意事项。

---

## 📖 理论部分

### 1. cvtColor() 函数详解

`cv2.cvtColor()` 是执行颜色空间转换的唯一入口函数：

```python
import cv2

# 函数签名
dst = cv2.cvtColor(src, code)

# 参数说明：
# src  - 输入图像（NumPy 数组）
# code - 转换代码（如 cv2.COLOR_BGR2GRAY）
# dst  - 输出图像（自动创建，无需预分配）
```

```
函数工作流程：

  输入图像 (src)          转换代码 (code)          输出图像 (dst)
  ┌──────────┐          ┌──────────────┐         ┌──────────┐
  │ BGR 图像  │  ──────→ │ COLOR_BGR2HSV │ ──────→ │ HSV 图像  │
  │ (H,W,3)  │          └──────────────┘         │ (H,W,3)  │
  └──────────┘                                    └──────────┘

  注意：
  1. src 不会被修改（创建新数组返回）
  2. 输出的 shape 可能改变（如 BGR→GRAY：3通道→1通道）
  3. 数据类型保持不变（uint8 进 → uint8 出）
```

---

### 2. 常用转换代码一览

OpenCV 提供了 200+ 种转换代码，但日常开发中最常用的只有十几种：

#### 2.1 BGR 与其他空间的互转

```python
import cv2
import numpy as np

# 假设 img 是一张 BGR 图像
img = cv2.imread("photo.jpg")

# === BGR → 其他颜色空间 ===
gray  = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    # BGR → 灰度
rgb   = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)      # BGR → RGB
hsv   = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)      # BGR → HSV
lab   = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)      # BGR → Lab
ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)    # BGR → YCrCb
hls   = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)      # BGR → HLS

# === 其他颜色空间 → BGR ===
img1 = cv2.cvtColor(hsv,   cv2.COLOR_HSV2BGR)     # HSV → BGR
img2 = cv2.cvtColor(lab,   cv2.COLOR_Lab2BGR)      # Lab → BGR
img3 = cv2.cvtColor(ycrcb, cv2.COLOR_YCrCb2BGR)   # YCrCb → BGR
img4 = cv2.cvtColor(hls,   cv2.COLOR_HLS2BGR)     # HLS → BGR
```

```
转换代码命名规则：

  cv2.COLOR_  +  源空间  +  2  +  目标空间
  │              │          │      │
  │              │          │      └─ 目标颜色空间
  │              │          └──── "to"的缩写
  │              └───────── 源颜色空间
  └──────────── 固定前缀

  示例：
  COLOR_BGR2GRAY  → BGR 转 灰度
  COLOR_BGR2HSV   → BGR 转 HSV
  COLOR_HSV2BGR   → HSV 转 BGR
  COLOR_GRAY2BGR  → 灰度 转 BGR（单通道→三通道）
```

#### 2.2 常用转换代码速查表

| 转换方向 | 代码 | 通道变化 | 说明 |
|----------|------|----------|------|
| BGR → 灰度 | `COLOR_BGR2GRAY` | 3→1 | 最常用，边缘检测必备 |
| 灰度 → BGR | `COLOR_GRAY2BGR` | 1→3 | 灰度值复制到三个通道 |
| BGR → RGB | `COLOR_BGR2RGB` | 3→3 | matplotlib 显示必备 |
| RGB → BGR | `COLOR_RGB2BGR` | 3→3 | 从 Pillow 转到 OpenCV |
| BGR → HSV | `COLOR_BGR2HSV` | 3→3 | 颜色过滤必备 |
| HSV → BGR | `COLOR_HSV2BGR` | 3→3 | HSV 处理后转回显示 |
| BGR → Lab | `COLOR_BGR2Lab` | 3→3 | 颜色对比、增强 |
| Lab → BGR | `COLOR_Lab2BGR` | 3→3 | Lab 处理后转回 |
| BGR → YCrCb | `COLOR_BGR2YCrCb` | 3→3 | 肤色检测 |
| YCrCb → BGR | `COLOR_YCrCb2BGR` | 3→3 | 处理后转回 |
| BGR → HLS | `COLOR_BGR2HLS` | 3→3 | 类似 HSV 的替代方案 |

> 💡 **小技巧：** 在 IDE 中输入 `cv2.COLOR_` 然后按 Tab 键，可以查看所有可用的转换代码。

---

### 3. 各转换的数学原理

了解转换公式有助于理解"为什么"以及"什么情况下可能出问题"。

#### 3.1 BGR → 灰度

```
转换公式（加权平均法）：

  Gray = 0.299 × R + 0.587 × G + 0.114 × B

  直觉理解：
  ┌─────────────────────────────────────────────────┐
  │  绿色权重最大（0.587）→ 人眼对绿色最敏感         │
  │  红色权重中等（0.299）→ 人眼对红色次之            │
  │  蓝色权重最小（0.114）→ 人眼对蓝色最不敏感        │
  │                                                   │
  │  所以：纯绿色看起来比纯蓝色更"亮"               │
  │  绿色灰度值 ≈ 150，蓝色灰度值 ≈ 29                │
  └─────────────────────────────────────────────────┘
```

```python
import cv2
import numpy as np

# 验证灰度转换公式
pixel_bgr = np.array([[[255, 0, 0]]], dtype=np.uint8)  # 纯蓝 (BGR)
gray = cv2.cvtColor(pixel_bgr, cv2.COLOR_BGR2GRAY)
print(f"纯蓝的灰度值: {gray[0][0]}")    # 29（= 0.114 × 255）

pixel_bgr = np.array([[[0, 255, 0]]], dtype=np.uint8)  # 纯绿 (BGR)
gray = cv2.cvtColor(pixel_bgr, cv2.COLOR_BGR2GRAY)
print(f"纯绿的灰度值: {gray[0][0]}")    # 150（= 0.587 × 255）

pixel_bgr = np.array([[[0, 0, 255]]], dtype=np.uint8)  # 纯红 (BGR)
gray = cv2.cvtColor(pixel_bgr, cv2.COLOR_BGR2GRAY)
print(f"纯红的灰度值: {gray[0][0]}")    # 76（= 0.299 × 255）
```

> ⚠️ **注意：** 灰度转换是**不可逆的**！三个通道的信息被压缩成一个值，无法恢复原始颜色。虽然可以用 `COLOR_GRAY2BGR` 把灰度图变成三通道，但每个通道都是相同的灰度值。

#### 3.2 BGR → HSV

```
转换步骤：

  1. 归一化 BGR 到 [0, 1]：
     B' = B/255,  G' = G/255,  R' = R/255

  2. 计算中间变量：
     Cmax = max(R', G', B')
     Cmin = min(R', G', B')
     Δ = Cmax - Cmin

  3. 计算 H（色调）：
     ┌ 0                        , 若 Δ = 0
     │ 60° × (G'-B')/Δ          , 若 Cmax = R'
  H =│ 60° × (B'-R')/Δ + 120°   , 若 Cmax = G'
     └ 60° × (R'-G')/Δ + 240°   , 若 Cmax = B'
     若 H < 0，则 H += 360°

     OpenCV 中：H = H / 2（缩放到 0-179）

  4. 计算 S（饱和度）：
     S = 0           , 若 Cmax = 0
     S = Δ / Cmax    , 否则
     OpenCV 中：S = S × 255（缩放到 0-255）

  5. 计算 V（明度）：
     V = Cmax
     OpenCV 中：V = V × 255（缩放到 0-255）
```

```python
# 验证 HSV 转换
import cv2
import numpy as np

# 纯红色 BGR = (0, 0, 255)
red_bgr = np.array([[[0, 0, 255]]], dtype=np.uint8)
red_hsv = cv2.cvtColor(red_bgr, cv2.COLOR_BGR2HSV)
print(f"红色 HSV: {red_hsv[0][0]}")    # [0, 255, 255] → H=0, S=255, V=255

# 纯绿色 BGR = (0, 255, 0)
green_bgr = np.array([[[0, 255, 0]]], dtype=np.uint8)
green_hsv = cv2.cvtColor(green_bgr, cv2.COLOR_BGR2HSV)
print(f"绿色 HSV: {green_hsv[0][0]}")  # [60, 255, 255] → H=60, S=255, V=255

# 纯蓝色 BGR = (255, 0, 0)
blue_bgr = np.array([[[255, 0, 0]]], dtype=np.uint8)
blue_hsv = cv2.cvtColor(blue_bgr, cv2.COLOR_BGR2HSV)
print(f"蓝色 HSV: {blue_hsv[0][0]}")   # [120, 255, 255] → H=120, S=255, V=255

# 灰色 BGR = (128, 128, 128)
gray_bgr = np.array([[[128, 128, 128]]], dtype=np.uint8)
gray_hsv = cv2.cvtColor(gray_bgr, cv2.COLOR_BGR2HSV)
print(f"灰色 HSV: {gray_hsv[0][0]}")   # [0, 0, 128] → H=0, S=0（无色彩！）, V=128
```

#### 3.3 BGR → YCrCb

```
转换公式：

  Y  =  0.299 × R + 0.587 × G + 0.114 × B
  Cr = (R - Y) × 0.713 + 128
  Cb = (B - Y) × 0.564 + 128

  注意：
  - Y 通道 = 灰度值（和灰度转换公式一样！）
  - Cr、Cb 加了 128 的偏移，避免出现负数
  - 范围都是 0-255
```

#### 3.4 BGR → Lab

```
转换流程（两步走）：

  BGR → XYZ → Lab

  第一步：BGR → XYZ（线性变换）
  ┌ X ┐   ┌ 0.412  0.358  0.180 ┐   ┌ R' ┐
  │ Y │ = │ 0.213  0.715  0.072 │ × │ G' │
  └ Z ┘   └ 0.019  0.119  0.950 ┘   └ B' │
  （R', G', B' 需要先做 gamma 校正）

  第二步：XYZ → Lab（非线性变换）
  L = 116 × f(Y/Yn) - 16
  a = 500 × [f(X/Xn) - f(Y/Yn)]
  b = 200 × [f(Y/Yn) - f(Z/Zn)]
  其中 f(t) = t^(1/3) 当 t > 0.008856，否则 f(t) = 7.787t + 16/116

  → 这就是为什么 Lab 能实现"感知均匀"——非线性变换模拟了人眼的响应曲线
```

---

### 4. 灰度转换的两种方式

灰度图是最常用的转换目标，OpenCV 提供了两种获取灰度图的方式：

```python
import cv2

# === 方式1：读取时直接加载为灰度 ===
gray1 = cv2.imread("photo.jpg", cv2.IMREAD_GRAYSCALE)
print(f"直接灰度读取: {gray1.shape}")    # (H, W)
print(f"数据类型: {gray1.dtype}")        # uint8

# === 方式2：读取彩色后转换 ===
img = cv2.imread("photo.jpg")            # BGR, (H, W, 3)
gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
print(f"转换后灰度: {gray2.shape}")      # (H, W)

# 两种方式的结果是一样的
print(f"结果相同: {np.array_equal(gray1, gray2)}")  # True
```

```
两种方式对比：

  ┌──────────────┬─────────────────┬───────────────────┐
  │              │ 方式1（读取时）  │ 方式2（读取后转）  │
  ├──────────────┼─────────────────┼───────────────────┤
  │ 内存占用      │ 小（只读1通道） │ 大（先读3通道）   │
  │ 是否保留彩色  │ 否（丢弃了）    │ 是（img 仍可用）  │
  │ 灵活性        │ 低              │ 高                │
  │ 适用场景      │ 只需要灰度      │ 同时需要彩色和灰度│
  └──────────────┴─────────────────┴───────────────────┘
```

---

### 5. BGR ↔ RGB 转换

这是最容易被忽略但又最容易出错的转换：

```python
import cv2
import numpy as np

# === 场景1：OpenCV → matplotlib 显示 ===
img_bgr = cv2.imread("photo.jpg")       # OpenCV: BGR
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

import matplotlib.pyplot as plt
# plt.imshow(img_bgr)   # ❌ 错误！红蓝互换
plt.imshow(img_rgb)      # ✅ 正确！
plt.show()

# === 场景2：Pillow → OpenCV ===
from PIL import Image
pil_img = Image.open("photo.jpg")       # Pillow: RGB
cv_img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

# === 场景3：手动翻转通道（等价但不推荐） ===
img_rgb_manual = img_bgr[:, :, ::-1]    # 反转通道顺序
# 注意：这返回的是视图（view），修改会影响原数组！
# 推荐用 cvtColor，它会创建独立的副本
```

```
BGR 和 RGB 的"坑"总结：

  ┌─────────────────────────────────────────────────┐
  │  🔴 这些库用 RGB：                               │
  │     matplotlib、Pillow(PIL)、scikit-image         │
  │     PyTorch(torchvision)、TensorFlow              │
  │                                                   │
  │  🔵 这些库用 BGR：                               │
  │     OpenCV (cv2)                                  │
  │                                                   │
  │  → 跨库操作时，一定要注意转换！                   │
  │  → 忘记转换不会报错，只会颜色显示异常            │
  └─────────────────────────────────────────────────┘
```

---

### 6. 转换的注意事项和常见错误

#### 6.1 不支持直接跨空间转换

```python
# ❌ 错误：不能直接从 HSV 转到 Lab
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
# lab = cv2.cvtColor(hsv, cv2.COLOR_HSV2Lab)   # 没有这个转换代码！

# ✅ 正确：需要先转回 BGR，再转到 Lab
bgr = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2Lab)
```

```
允许的转换路径：

  大多数转换都以 BGR/RGB 为中心：

                  灰度
                   ↑↓
       HLS ←→ BGR/RGB ←→ HSV
                ↑↓   ↑↓
            YCrCb     Lab

  → 几乎所有转换都要经过 BGR/RGB 这个"中转站"
  → 不存在 HSV→Lab、YCrCb→HSV 等直接转换
```

#### 6.2 输入图像通道数必须匹配

```python
import cv2

img = cv2.imread("photo.jpg")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# ❌ 错误：灰度图只有1个通道，不能当3通道来转
# hsv = cv2.cvtColor(gray, cv2.COLOR_BGR2HSV)  # 会报错！

# ✅ 正确：先转为3通道，再转 HSV
gray_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)  # 1通道 → 3通道
hsv = cv2.cvtColor(gray_bgr, cv2.COLOR_BGR2HSV)     # 3通道 → 3通道
# 但这没什么意义，因为灰度图没有颜色信息，HSV 的 S 通道会全为 0
```

#### 6.3 数据类型的影响

```python
import cv2
import numpy as np

# uint8 图像（范围 0-255）— 最常见
img_uint8 = cv2.imread("photo.jpg")  # dtype=uint8
hsv_uint8 = cv2.cvtColor(img_uint8, cv2.COLOR_BGR2HSV)
print(f"uint8 HSV: H范围 0-179, S范围 0-255, V范围 0-255")

# float32 图像（范围 0.0-1.0）
img_float = img_uint8.astype(np.float32) / 255.0
hsv_float = cv2.cvtColor(img_float, cv2.COLOR_BGR2HSV)
print(f"float32 HSV: H范围 0-360, S范围 0-1, V范围 0-1")
# 注意：float32 输入时，H 的范围变成了 0-360！不再是 0-179！
```

```
数据类型对 HSV 范围的影响：

  ┌───────────┬──────────┬──────────┬──────────┐
  │ 数据类型   │  H 范围  │  S 范围  │  V 范围  │
  ├───────────┼──────────┼──────────┼──────────┤
  │ uint8     │ 0-179    │ 0-255    │ 0-255    │
  │ float32   │ 0-360    │ 0-1      │ 0-1      │
  │ float64   │ 0-360    │ 0-1      │ 0-1      │
  └───────────┴──────────┴──────────┴──────────┘

  ⚠️ 混用数据类型是常见的 bug 来源！
  建议：统一使用 uint8，在需要时再转 float
```

#### 6.4 转换的可逆性

```python
# 大多数转换是可逆的（但可能有精度损失）
img = cv2.imread("photo.jpg")

# BGR → HSV → BGR
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
img_back = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

# 检查是否完全一致
diff = cv2.absdiff(img, img_back)
print(f"最大差异: {diff.max()}")    # 可能有 1-2 的误差（整数取整导致）
print(f"平均差异: {diff.mean():.4f}")

# BGR → GRAY → BGR（不可逆！）
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
img_back2 = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
# img_back2 是"灰色图"，不是彩色图！信息已丢失
```

```
转换可逆性一览：

  ┌──────────────────┬────────┬──────────────────────┐
  │ 转换              │ 可逆？ │ 说明                  │
  ├──────────────────┼────────┼──────────────────────┤
  │ BGR ↔ RGB        │ ✅ 完全 │ 只是通道顺序互换      │
  │ BGR ↔ HSV        │ ≈ 近似 │ 整数取整有微小误差     │
  │ BGR ↔ Lab        │ ≈ 近似 │ 非线性变换有精度损失   │
  │ BGR ↔ YCrCb      │ ≈ 近似 │ 整数取整有微小误差     │
  │ BGR → GRAY       │ ❌ 不可逆│ 3通道→1通道，信息丢失 │
  └──────────────────┴────────┴──────────────────────┘
```

---

### 7. 批量查看所有转换代码

如果你好奇 OpenCV 到底支持多少种颜色空间转换：

```python
import cv2

# 列出所有 COLOR_ 开头的常量
color_codes = [attr for attr in dir(cv2) if attr.startswith("COLOR_")]
print(f"总共有 {len(color_codes)} 种转换代码")

# 只看 BGR 相关的
bgr_codes = [c for c in color_codes if "BGR" in c]
print(f"BGR 相关: {len(bgr_codes)} 种")
for code in bgr_codes[:10]:  # 只显示前 10 个
    print(f"  {code}")
```

---

## 💻 代码实战

### 实战1：基本颜色空间转换

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("images/color_shapes.png")
if img is None:
    # 创建测试图像
    img = np.zeros((400, 600, 3), dtype=np.uint8)
    cv2.circle(img, (100, 200), 80, (0, 0, 255), -1)    # 红
    cv2.circle(img, (300, 200), 80, (0, 255, 0), -1)    # 绿
    cv2.circle(img, (500, 200), 80, (255, 0, 0), -1)    # 蓝

print(f"原图: shape={img.shape}, dtype={img.dtype}")

# 转换到各种颜色空间
gray  = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
hsv   = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
lab   = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)
ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

print(f"灰度: shape={gray.shape}")     # (H, W) — 少了一维！
print(f"HSV:  shape={hsv.shape}")      # (H, W, 3)
print(f"Lab:  shape={lab.shape}")      # (H, W, 3)
print(f"YCrCb: shape={ycrcb.shape}")   # (H, W, 3)
```

### 实战2：查看单个像素在不同颜色空间的值

```python
import cv2
import numpy as np

# 创建一些纯色像素来观察转换结果
colors = {
    "红色": np.array([[[0, 0, 255]]], dtype=np.uint8),      # BGR
    "绿色": np.array([[[0, 255, 0]]], dtype=np.uint8),
    "蓝色": np.array([[[255, 0, 0]]], dtype=np.uint8),
    "黄色": np.array([[[0, 255, 255]]], dtype=np.uint8),
    "白色": np.array([[[255, 255, 255]]], dtype=np.uint8),
    "灰色": np.array([[[128, 128, 128]]], dtype=np.uint8),
}

print(f"{'颜色':^6} | {'BGR':^15} | {'HSV':^15} | {'Lab':^15} | {'YCrCb':^15}")
print("-" * 75)

for name, pixel in colors.items():
    bgr = pixel[0][0]
    hsv = cv2.cvtColor(pixel, cv2.COLOR_BGR2HSV)[0][0]
    lab = cv2.cvtColor(pixel, cv2.COLOR_BGR2Lab)[0][0]
    ycrcb = cv2.cvtColor(pixel, cv2.COLOR_BGR2YCrCb)[0][0]
    print(f"{name:^6} | {str(bgr):^15} | {str(hsv):^15} | {str(lab):^15} | {str(ycrcb):^15}")
```

输出示例：
```
  颜色  |       BGR       |       HSV       |       Lab       |      YCrCb
---------------------------------------------------------------------------
  红色  | [  0   0 255]   | [  0 255 255]   | [ 53 160 196]   | [ 76 255 84]
  绿色  | [  0 255   0]   | [ 60 255 255]   | [136  87 202]   | [150  44 21]
  蓝色  | [255   0   0]   | [120 255 255]   | [ 32 179  75]   | [ 29 107 255]
  黄色  | [  0 255 255]   | [ 30 255 255]   | [226 128 211]   | [226  44 142]
  白色  | [255 255 255]   | [  0   0 255]   | [255 128 128]   | [255 128 128]
  灰色  | [128 128 128]   | [  0   0 128]   | [138 128 128]   | [128 128 128]
```

### 实战3：转换的可逆性测试

```python
import cv2
import numpy as np

img = cv2.imread("images/color_shapes.png")
if img is None:
    img = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)

# 测试各种转换的可逆性
conversions = [
    ("BGR→HSV→BGR", cv2.COLOR_BGR2HSV, cv2.COLOR_HSV2BGR),
    ("BGR→Lab→BGR", cv2.COLOR_BGR2Lab, cv2.COLOR_Lab2BGR),
    ("BGR→YCrCb→BGR", cv2.COLOR_BGR2YCrCb, cv2.COLOR_YCrCb2BGR),
    ("BGR→RGB→BGR", cv2.COLOR_BGR2RGB, cv2.COLOR_RGB2BGR),
]

for name, forward, backward in conversions:
    converted = cv2.cvtColor(img, forward)
    restored = cv2.cvtColor(converted, backward)
    diff = cv2.absdiff(img, restored)
    print(f"{name:20s} | 最大误差: {diff.max():3d} | 平均误差: {diff.mean():.4f}")
```

### 实战4：跨库图像传递

```python
import cv2
import numpy as np

# === OpenCV → matplotlib ===
img_bgr = cv2.imread("photo.jpg")
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
# plt.imshow(img_rgb)  # 正确显示

# === OpenCV → Pillow ===
from PIL import Image
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
pil_img = Image.fromarray(img_rgb)
# pil_img.save("output.jpg")

# === Pillow → OpenCV ===
pil_img = Image.open("photo.jpg")
img_bgr = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

# === OpenCV → PyTorch (torchvision) ===
# torchvision 期望 RGB 格式
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
# tensor = transforms.ToTensor()(img_rgb)
```

---

运行完整示例：

```bash
python code/color_convert.py
```

---

## 🧠 小测验

1. `cv2.cvtColor()` 的两个参数分别是什么？（答：源图像和转换代码）
2. BGR→灰度转换后，图像的 shape 会怎么变？（答：(H,W,3) → (H,W)，少了第三维）
3. 能否直接从 HSV 转到 Lab？（答：不能，需先转回 BGR 再转 Lab）
4. float32 输入时，HSV 的 H 范围是多少？（答：0-360，不是 0-179）
5. BGR→GRAY→BGR 后，图像还是彩色的吗？（答：不是，变成灰色的三通道图）

---

## 📌 本节要点

```
✅ cv2.cvtColor(src, code) 是颜色空间转换的唯一函数
✅ 转换代码命名规则：COLOR_源空间2目标空间
✅ 大多数转换以 BGR/RGB 为中心，不支持跨空间直接转换
✅ uint8 和 float32 输入会导致 HSV 的值范围不同
✅ BGR→灰度 是不可逆转换，其他大多数转换近似可逆
✅ OpenCV 用 BGR，其他库（matplotlib/Pillow/PyTorch）用 RGB
✅ 跨库传递图像时，一定要做 BGR↔RGB 转换
```

---

**下一步：** 👉 [03 - 通道分离与合并](../03-通道分离与合并/通道分离与合并.md)

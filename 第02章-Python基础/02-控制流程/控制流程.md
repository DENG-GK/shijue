# 控制流程

> 控制流程决定程序的执行顺序，是编写复杂逻辑的基础。学会控制流程，你的程序就能"思考"和"做决定"了。

---

## 📖 理论部分

### 1. 什么是控制流程？

默认情况下，Python 代码是**从上到下，逐行执行**的：

```python
print("第一步")
print("第二步")
print("第三步")
# 输出: 第一步 → 第二步 → 第三步
```

但实际编程中，我们需要：
- **做判断**：如果置信度 > 0.5，就认为检测成功 → 用 `if`
- **做重复**：对 1000 张图片逐一处理 → 用 `for` / `while`
- **做控制**：遇到错误图片就跳过 → 用 `continue` / `break`

这就是**控制流程**的三大核心：**选择（条件判断）**、**循环（重复执行）**、**跳转（流程控制）**。

---

### 2. 条件判断：if-elif-else

条件判断让程序根据不同情况执行不同的代码，就像岔路口选择走哪条路。

#### 2.1 基本语法

```python
if 条件:
    # 条件为 True 时执行这里
```

**最简单的例子：**

```python
score = 0.85

if score > 0.5:
    print("检测成功！")
# 输出: 检测成功！
```

> ⚠️ **注意缩进！** Python 用缩进（4个空格）来表示代码块，而不是大括号 `{}`。缩进错误是新手最常见的报错之一。

```python
# ❌ 错误：缩进不对
if score > 0.5:
print("检测成功")    # IndentationError!

# ✅ 正确：缩进4个空格
if score > 0.5:
    print("检测成功")
```

#### 2.2 if-else（二选一）

```python
score = 0.35

if score > 0.5:
    print("检测成功 ✅")
else:
    print("检测失败 ❌")
# 输出: 检测失败 ❌
```

**通俗理解：** "如果及格了就通过，否则就不通过"。

#### 2.3 if-elif-else（多选一）

当有多个条件需要判断时，用 `elif`（else if 的缩写）：

```python
score = 0.75

if score >= 0.9:
    level = "优秀"
elif score >= 0.7:
    level = "良好"
elif score >= 0.5:
    level = "及格"
else:
    level = "不及格"

print(f"置信度 {score} → 评级: {level}")
# 输出: 置信度 0.75 → 评级: 良好
```

**执行流程图：**

```
score = 0.75
    │
    ▼
score >= 0.9 ?  ──否──→  score >= 0.7 ?  ──否──→  score >= 0.5 ?  ──否──→  "不及格"
    │                        │                        │
   是                       是                       是
    │                        │                        │
    ▼                        ▼                        ▼
 "优秀"                   "良好" ✅                "及格"
```

> 💡 **重要：** `elif` 的判断是有顺序的！一旦某个条件成立，后面的 `elif` 和 `else` 都不会再执行。所以要把更严格的条件放在前面。

#### 2.4 比较运算符

条件判断离不开比较运算符，它们返回 `True` 或 `False`：

| 运算符 | 含义 | 示例 | 结果 |
|--------|------|------|------|
| `==` | 等于 | `5 == 5` | `True` |
| `!=` | 不等于 | `5 != 3` | `True` |
| `>` | 大于 | `5 > 3` | `True` |
| `<` | 小于 | `5 < 3` | `False` |
| `>=` | 大于等于 | `5 >= 5` | `True` |
| `<=` | 小于等于 | `3 <= 5` | `True` |

> ⚠️ **新手常见错误：** `=` 是赋值，`==` 才是比较！
> ```python
> x = 5      # 赋值：把 5 放进变量 x
> x == 5     # 比较：x 是否等于 5？返回 True
> ```

#### 2.5 逻辑运算符

当需要组合多个条件时，用逻辑运算符：

| 运算符 | 含义 | 说明 | 示例 |
|--------|------|------|------|
| `and` | 与 | **两个都为真**才是真 | `True and False → False` |
| `or` | 或 | **有一个为真**就是真 | `True or False → True` |
| `not` | 非 | **取反** | `not True → False` |

**实际应用：**

```python
width = 640
height = 480
channels = 3

# 同时满足多个条件
if width > 0 and height > 0:
    print("图像尺寸有效")

# 满足其中一个条件
if width > 1920 or height > 1080:
    print("图像太大，需要缩放")
else:
    print("图像尺寸正常")

# 取反
is_grayscale = channels == 1
if not is_grayscale:
    print("这是彩色图像")

# 组合使用
confidence = 0.85
class_name = "person"
if confidence > 0.7 and class_name == "person":
    print("高置信度检测到行人！")
```

#### 2.6 条件表达式（三元运算符）

简单的 if-else 可以写成一行：

```python
# 完整写法
if score > 0.5:
    result = "成功"
else:
    result = "失败"

# 一行写法（三元运算符）
result = "成功" if score > 0.5 else "失败"

# 实际应用
label = "彩色" if channels == 3 else "灰度"
print(f"图像类型: {label}")
```

> 💡 **建议：** 三元运算符适合简单的赋值场景。如果逻辑复杂，还是用标准 if-else，可读性更好。

#### 2.7 成员运算符：in

`in` 用来判断一个元素是否在某个序列中，非常实用：

```python
# 判断是否在列表中
supported_formats = ["jpg", "png", "bmp", "tiff"]
file_format = "jpg"

if file_format in supported_formats:
    print(f"✅ 支持 {file_format} 格式")
else:
    print(f"❌ 不支持 {file_format} 格式")

# 判断是否在字符串中
filename = "test_image_2024.jpg"
if "image" in filename:
    print("文件名包含 'image'")

# 判断是否在字典的键中
config = {"width": 640, "height": 480}
if "width" in config:
    print(f"宽度: {config['width']}")

# 取反：not in
if "depth" not in config:
    print("配置中没有 depth 参数")
```

---

### 3. for 循环：遍历序列

`for` 循环用于**逐一处理**序列中的每个元素。这在计算机视觉中极其常用——处理每张图片、每个像素、每个检测结果。

#### 3.1 基本语法

```python
for 变量 in 序列:
    # 对每个元素执行的操作
```

**遍历列表：**

```python
# 处理每个检测类别
classes = ["person", "car", "dog"]

for cls in classes:
    print(f"检测到: {cls}")
# 输出:
# 检测到: person
# 检测到: car
# 检测到: dog
```

**执行流程图解：**

```
classes = ["person", "car", "dog"]
              │
              ▼
    ┌─→ 取出下一个元素 ──→ 没有了？ ──→ 结束循环
    │         │
    │        有
    │         │
    │         ▼
    │   cls = "person" → 执行循环体 → print(...)
    │         │
    └─────────┘（回到取出下一个元素）
```

#### 3.2 遍历不同类型的数据

```python
# 遍历字符串（逐字符）
for char in "OpenCV":
    print(char, end=" ")
# 输出: O p e n C V

# 遍历字典
config = {"width": 640, "height": 480, "fps": 30}

# 遍历键（默认行为）
for key in config:
    print(key)

# 遍历键值对（最常用）
for key, value in config.items():
    print(f"  {key}: {value}")
# 输出:
#   width: 640
#   height: 480
#   fps: 30

# 遍历元组列表
points = [(100, 200), (300, 400), (500, 600)]
for x, y in points:
    print(f"坐标: ({x}, {y})")
```

#### 3.3 range() 函数：生成数字序列

当你需要循环固定次数，或者需要数字索引时，用 `range()`：

```python
# range(n) → 生成 0, 1, 2, ..., n-1
for i in range(5):
    print(i, end=" ")
# 输出: 0 1 2 3 4

# range(start, stop) → 生成 start, start+1, ..., stop-1
for i in range(2, 6):
    print(i, end=" ")
# 输出: 2 3 4 5

# range(start, stop, step) → 带步长
for i in range(0, 10, 2):
    print(i, end=" ")
# 输出: 0 2 4 6 8

# 倒序
for i in range(5, 0, -1):
    print(i, end=" ")
# 输出: 5 4 3 2 1
```

**实际应用：处理多张图片**

```python
total_images = 100
for i in range(total_images):
    filename = f"image_{i:04d}.jpg"  # image_0000.jpg, image_0001.jpg, ...
    # 这里可以放图像处理代码
    if i % 20 == 0:  # 每处理 20 张打印一次进度
        print(f"进度: {i}/{total_images} ({i/total_images:.0%})")
```

#### 3.4 enumerate()：同时获取索引和值

经常需要知道"这是第几个元素"，用 `enumerate()`：

```python
classes = ["person", "car", "dog", "cat"]

# ❌ 不推荐：手动维护索引
i = 0
for cls in classes:
    print(f"[{i}] {cls}")
    i += 1

# ✅ 推荐：使用 enumerate
for i, cls in enumerate(classes):
    print(f"[{i}] {cls}")
# 输出:
# [0] person
# [1] car
# [2] dog
# [3] cat

# 可以指定起始编号
for i, cls in enumerate(classes, start=1):
    print(f"第{i}个: {cls}")
# 输出:
# 第1个: person
# 第2个: car
# ...
```

#### 3.5 zip()：并行遍历多个序列

当你有多个相关的列表，想同时遍历时：

```python
names = ["person", "car", "dog"]
scores = [0.95, 0.88, 0.76]
colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]

for name, score, color in zip(names, scores, colors):
    print(f"{name}: {score:.0%}, 颜色={color}")
# 输出:
# person: 95%, 颜色=(255, 0, 0)
# car: 88%, 颜色=(0, 255, 0)
# dog: 76%, 颜色=(0, 0, 255)

# 结合 enumerate 使用
for i, (name, score) in enumerate(zip(names, scores)):
    print(f"[{i}] {name} → {score}")
```

> 💡 **注意：** `zip()` 以最短的序列为准。如果两个列表长度不同，多余的元素会被忽略。

---

### 4. while 循环：条件循环

`while` 循环在条件为 `True` 时**持续执行**，适用于不确定循环次数的场景。

#### 4.1 基本语法

```python
while 条件:
    # 条件为 True 时重复执行
    # 必须有某种方式让条件最终变为 False，否则死循环！
```

**简单示例：**

```python
count = 0
while count < 5:
    print(f"第 {count} 次循环")
    count += 1       # 别忘了这行！否则死循环
print("循环结束")
```

**执行流程：**

```
count = 0
    │
    ▼
┌─→ count < 5 ?
│       │
│     是(True)         否(False)
│       │                  │
│       ▼                  ▼
│   执行循环体          退出循环
│   count += 1
│       │
└───────┘
```

#### 4.2 实际应用场景

```python
# 场景1：等待用户输入正确的值
while True:
    value = input("请输入阈值 (0-255): ")
    if value.isdigit() and 0 <= int(value) <= 255:
        threshold = int(value)
        print(f"阈值设置为: {threshold}")
        break    # 输入正确，退出循环
    else:
        print("输入无效，请重新输入！")

# 场景2：逐步降低阈值直到找到足够的目标
threshold = 0.9
min_detections = 5
detections_count = 2  # 假设初始检测到2个

while detections_count < min_detections and threshold > 0.1:
    threshold -= 0.1
    # 这里放重新检测的代码
    detections_count += 1  # 模拟：每降低阈值多检测到1个
    print(f"阈值={threshold:.1f}, 检测到 {detections_count} 个目标")

print(f"最终: 阈值={threshold:.1f}, 共检测到 {detections_count} 个目标")
```

> ⚠️ **死循环警告：** 使用 `while` 时一定要确保条件最终会变为 `False`。如果不小心写了死循环，按 `Ctrl + C` 强制终止程序。

```python
# ❌ 死循环！count 永远不会变
count = 0
while count < 5:
    print(count)
    # 忘了写 count += 1

# ✅ 正确
count = 0
while count < 5:
    print(count)
    count += 1
```

---

### 5. 循环控制：break、continue、pass

#### 5.1 break：立即退出整个循环

```python
# 在文件列表中找到第一个 jpg 文件就停止
files = ["data.csv", "readme.md", "photo.jpg", "image.png", "doc.pdf"]

for f in files:
    print(f"检查: {f}")
    if f.endswith(".jpg"):
        print(f"✅ 找到 JPG 文件: {f}")
        break    # 找到了，不用继续找了
# 输出:
# 检查: data.csv
# 检查: readme.md
# 检查: photo.jpg
# ✅ 找到 JPG 文件: photo.jpg
```

#### 5.2 continue：跳过本次，继续下一次

```python
# 跳过不支持的文件格式，只处理图片
files = ["img1.jpg", "data.csv", "img2.png", "readme.md", "img3.jpg"]
image_extensions = (".jpg", ".png", ".bmp")

for f in files:
    # 不是图片文件就跳过
    if not f.endswith(image_extensions):
        print(f"⏭️ 跳过非图片文件: {f}")
        continue

    # 只有图片文件才会执行到这里
    print(f"🖼️ 正在处理: {f}")
# 输出:
# 🖼️ 正在处理: img1.jpg
# ⏭️ 跳过非图片文件: data.csv
# 🖼️ 正在处理: img2.png
# ⏭️ 跳过非图片文件: readme.md
# 🖼️ 正在处理: img3.jpg
```

#### 5.3 pass：什么都不做（占位符）

```python
# 还没想好怎么处理，先用 pass 占个位
for i in range(10):
    if i % 2 == 0:
        pass    # TODO: 以后再实现偶数的处理
    else:
        print(f"奇数: {i}")

# 常用于定义空函数或空类
def process_image(img):
    pass    # 之后再实现

class ImageFilter:
    pass    # 之后再实现
```

**break vs continue 对比图解：**

```
for i in range(5):
    if i == 2:
        break/continue
    print(i)

使用 break:          使用 continue:
输出: 0, 1           输出: 0, 1, 3, 4
(i=2时退出整个循环)   (i=2时跳过，继续i=3)
```

---

### 6. 列表推导式

列表推导式是 Python 的一大特色语法，可以用**一行代码**生成列表，非常简洁。

#### 6.1 基本语法

```python
# 标准写法
新列表 = [表达式 for 变量 in 序列]

# 等价的 for 循环写法
新列表 = []
for 变量 in 序列:
    新列表.append(表达式)
```

**对比示例：**

```python
# 需求：将每个像素值归一化到 0~1
pixels = [255, 128, 64, 32, 0]

# 普通 for 循环（4行）
normalized = []
for p in pixels:
    normalized.append(p / 255.0)

# 列表推导式（1行！）
normalized = [p / 255.0 for p in pixels]

print(normalized)
# [1.0, 0.502, 0.251, 0.125, 0.0]
```

#### 6.2 带条件的列表推导式

```python
# 语法: [表达式 for 变量 in 序列 if 条件]

scores = [0.95, 0.32, 0.88, 0.41, 0.76, 0.15]

# 筛选出高置信度的分数（> 0.5）
high_scores = [s for s in scores if s > 0.5]
print(high_scores)   # [0.95, 0.88, 0.76]

# 筛选出图片文件
files = ["img.jpg", "data.csv", "photo.png", "doc.txt"]
images = [f for f in files if f.endswith((".jpg", ".png"))]
print(images)   # ['img.jpg', 'photo.png']
```

#### 6.3 带 if-else 的列表推导式

```python
# 注意：带 else 时，if-else 要放在 for 前面！
# 语法: [值1 if 条件 else 值2 for 变量 in 序列]

scores = [0.95, 0.32, 0.88, 0.41, 0.76]

# 将分数转为标签
labels = ["高" if s > 0.5 else "低" for s in scores]
print(labels)   # ['高', '低', '高', '低', '高']

# 像素值裁剪：超过200的设为200，其余不变
pixels = [255, 180, 220, 90, 200]
clipped = [200 if p > 200 else p for p in pixels]
print(clipped)   # [200, 180, 200, 90, 200]
```

> ⚠️ **语法区别要记清：**
> - 只有 if（筛选）：`[x for x in lst if 条件]` — if 在后面
> - if-else（转换）：`[A if 条件 else B for x in lst]` — if-else 在前面

#### 6.4 嵌套列表推导式

```python
# 生成 3x3 的二维列表（类似矩阵）
matrix = [[0 for col in range(3)] for row in range(3)]
print(matrix)
# [[0, 0, 0],
#  [0, 0, 0],
#  [0, 0, 0]]

# 将二维列表展平为一维
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(flat)   # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

> 💡 **建议：** 嵌套列表推导式容易让人看不懂。如果逻辑复杂，宁可用普通 for 循环，可读性更重要！

#### 6.5 字典推导式和集合推导式

同样的思路也适用于字典和集合：

```python
# 字典推导式
names = ["person", "car", "dog"]
scores = [0.95, 0.88, 0.76]
result = {name: score for name, score in zip(names, scores)}
print(result)   # {'person': 0.95, 'car': 0.88, 'dog': 0.76}

# 集合推导式（自动去重）
words = ["cat", "dog", "cat", "bird", "dog"]
unique = {w.upper() for w in words}
print(unique)   # {'CAT', 'DOG', 'BIRD'}
```

---

## 💻 代码实战

### 实战练习：图像批处理流水线

下面这个综合示例展示了条件判断、循环、列表推导式在图像处理场景中的综合应用。运行 `code/control_flow.py` 查看完整示例。

```python
# ===================================================================
# 实战练习：图像批处理流水线
# 目标：综合运用 if/for/while/列表推导式
# ===================================================================

# ---------- 1. 条件判断：图像格式验证 ----------
print("=" * 50)
print("📁 第一步：文件格式验证")
print("=" * 50)

files = [
    "photo_001.jpg",
    "photo_002.png",
    "document.pdf",
    "photo_003.bmp",
    "notes.txt",
    "photo_004.jpg",
    "data.csv",
]
supported = (".jpg", ".png", ".bmp", ".tiff")

valid_images = []
for f in files:
    if f.endswith(supported):
        valid_images.append(f)
        print(f"  ✅ {f}")
    else:
        print(f"  ❌ {f} (不支持的格式，跳过)")

print(f"\n有效图片: {len(valid_images)}/{len(files)} 个")

# ---------- 2. for 循环 + enumerate：模拟图像处理 ----------
print("\n" + "=" * 50)
print("🔧 第二步：图像处理")
print("=" * 50)

# 模拟图像属性
image_data = [
    {"name": "photo_001.jpg", "width": 1920, "height": 1080, "brightness": 0.85},
    {"name": "photo_002.png", "width": 640,  "height": 480,  "brightness": 0.25},
    {"name": "photo_003.bmp", "width": 3840, "height": 2160, "brightness": 0.60},
    {"name": "photo_004.jpg", "width": 800,  "height": 600,  "brightness": 0.10},
]

MAX_WIDTH = 1920
MIN_BRIGHTNESS = 0.3
processed = []

for i, img in enumerate(image_data, start=1):
    print(f"\n[{i}/{len(image_data)}] 处理: {img['name']}")

    # 检查是否需要缩放
    if img["width"] > MAX_WIDTH:
        scale = MAX_WIDTH / img["width"]
        new_w = int(img["width"] * scale)
        new_h = int(img["height"] * scale)
        print(f"  📐 缩放: {img['width']}x{img['height']} → {new_w}x{new_h}")
    else:
        print(f"  📐 尺寸正常: {img['width']}x{img['height']}")

    # 检查亮度
    if img["brightness"] < MIN_BRIGHTNESS:
        print(f"  💡 亮度过低 ({img['brightness']:.0%})，需要增强")
        status = "已增强"
    elif img["brightness"] > 0.9:
        print(f"  💡 亮度过高 ({img['brightness']:.0%})，需要降低")
        status = "已降低"
    else:
        print(f"  💡 亮度正常 ({img['brightness']:.0%})")
        status = "正常"

    processed.append({"name": img["name"], "status": status})

# ---------- 3. 列表推导式：快速筛选与转换 ----------
print("\n" + "=" * 50)
print("📊 第三步：结果统计")
print("=" * 50)

# 筛选需要特殊处理的图片
enhanced = [p["name"] for p in processed if p["status"] == "已增强"]
normal = [p["name"] for p in processed if p["status"] == "正常"]

print(f"  正常图片: {len(normal)} 张")
print(f"  需要增强: {len(enhanced)} 张")

# 生成文件名映射
name_map = {img["name"]: f"processed_{img['name']}" for img in image_data}
print(f"\n  输出文件映射:")
for original, output in name_map.items():
    print(f"    {original} → {output}")

# ---------- 4. while 循环：模拟自动阈值调整 ----------
print("\n" + "=" * 50)
print("🎯 第四步：自动阈值调整")
print("=" * 50)

# 模拟：不断调整阈值直到检测到足够多的目标
threshold = 0.95
target_count = 5
detected = 1
attempt = 0

print(f"  目标: 检测到至少 {target_count} 个目标\n")

while detected < target_count and threshold > 0.3:
    attempt += 1
    threshold -= 0.1
    detected += 1  # 模拟：降低阈值后多检测到1个

    bar = "█" * detected + "░" * (target_count - detected)
    print(f"  尝试 {attempt}: 阈值={threshold:.2f}, "
          f"检测到 {detected}/{target_count} [{bar}]")

if detected >= target_count:
    print(f"\n  ✅ 成功！最终阈值={threshold:.2f}, 检测到 {detected} 个目标")
else:
    print(f"\n  ❌ 未达标，当前检测到 {detected} 个")

# ---------- 5. 综合：break 和 continue ----------
print("\n" + "=" * 50)
print("🔍 第五步：异常检测")
print("=" * 50)

# 模拟像素值检查
pixel_rows = [
    [128, 130, 125, 132, 129],    # 正常
    [128, 130, 255, 0,   129],    # 有异常像素
    [120, 122, 118, 125, 121],    # 正常
    [0,   0,   0,   0,   0  ],    # 全黑行
]

for row_idx, row in enumerate(pixel_rows):
    # 检查是否全黑
    if all(p == 0 for p in row):
        print(f"  行 {row_idx}: ⛔ 全黑行，停止检查后续行")
        break

    # 检查是否有异常像素
    abnormal = [p for p in row if p < 10 or p > 250]
    if abnormal:
        print(f"  行 {row_idx}: ⚠️ 发现异常像素 {abnormal}")
        continue   # 跳过后续处理，检查下一行

    print(f"  行 {row_idx}: ✅ 正常 (均值={sum(row)/len(row):.1f})")
```

**运行输出示例：**

```
==================================================
📁 第一步：文件格式验证
==================================================
  ✅ photo_001.jpg
  ✅ photo_002.png
  ❌ document.pdf (不支持的格式，跳过)
  ✅ photo_003.bmp
  ❌ notes.txt (不支持的格式，跳过)
  ✅ photo_004.jpg
  ❌ data.csv (不支持的格式，跳过)

有效图片: 4/7 个

==================================================
🔧 第二步：图像处理
==================================================

[1/4] 处理: photo_001.jpg
  📐 尺寸正常: 1920x1080
  💡 亮度正常 (85%)

[2/4] 处理: photo_002.png
  📐 尺寸正常: 640x480
  💡 亮度过低 (25%)，需要增强

[3/4] 处理: photo_003.bmp
  📐 缩放: 3840x2160 → 1920x1080
  💡 亮度正常 (60%)

[4/4] 处理: photo_004.jpg
  📐 尺寸正常: 800x600
  💡 亮度过低 (10%)，需要增强

==================================================
📊 第三步：结果统计
==================================================
  正常图片: 2 张
  需要增强: 2 张

==================================================
🎯 第四步：自动阈值调整
==================================================
  目标: 检测到至少 5 个目标

  尝试 1: 阈值=0.85, 检测到 2/5 [██░░░]
  尝试 2: 阈值=0.75, 检测到 3/5 [███░░]
  尝试 3: 阈值=0.65, 检测到 4/5 [████░]
  尝试 4: 阈值=0.55, 检测到 5/5 [█████]

  ✅ 成功！最终阈值=0.55, 检测到 5 个目标
```

---

## 🚨 常见问题与易错点

### Q1: for 和 while 什么时候用哪个？

**简单记忆：**
- **知道要循环多少次** → 用 `for`（遍历列表、处理 N 张图片）
- **不知道要循环多少次** → 用 `while`（等待用户输入、自动调参）

### Q2: range(5) 为什么不包含 5？

这是 Python 的设计哲学——**左闭右开区间** `[0, 5)`。好处是：
- `range(n)` 恰好生成 n 个数
- `range(len(list))` 恰好覆盖列表所有索引
- 区间可以无缝拼接：`range(0,5)` + `range(5,10)` = `range(0,10)`

### Q3: 列表推导式和 for 循环怎么选？

| 场景 | 推荐方式 |
|------|----------|
| 简单的映射或筛选（一行能写完） | 列表推导式 |
| 逻辑复杂（多步操作、多个条件） | for 循环 |
| 需要 break/continue | for 循环（推导式不支持） |
| 只需要遍历不需要生成新列表 | for 循环 |

### Q4: 如何避免死循环？

```python
# 方法1：确保条件变量在循环内改变
count = 0
while count < 10:
    count += 1    # ← 这行不能忘

# 方法2：设置最大迭代次数（推荐！）
max_iterations = 1000
for i in range(max_iterations):
    # 你的逻辑
    if 达到目标:
        break
else:
    print("警告：达到最大迭代次数，可能未收敛")
```

> 💡 **小知识：** Python 的 `for-else` 和 `while-else` 中，`else` 块在循环**正常结束**（没有被 break 打断）时执行。这个语法比较少见，了解即可。

---

## 🎯 总结

本节学习了 Python 的三大控制流程：

✅ **条件判断**：if-elif-else 分支选择，比较运算符（`==`, `>`, `<`），逻辑运算符（`and`, `or`, `not`）
✅ **for 循环**：遍历列表/字典/字符串，`range()` 生成数字，`enumerate()` 带索引，`zip()` 并行遍历
✅ **while 循环**：条件循环，适用于不确定次数的场景
✅ **流程控制**：`break`（退出循环）、`continue`（跳过本次）、`pass`（占位）
✅ **列表推导式**：一行代码生成列表，支持筛选和转换
✅ **成员判断**：`in` / `not in` 判断元素是否在序列中

> 🔑 **核心要点：** 在计算机视觉中，`for` 循环用于遍历图像列表和像素，`if` 用于判断检测结果和参数验证，`while` 用于自适应调参，列表推导式用于快速筛选和转换数据。

**下一步：**
👉 [03 - 函数与模块](../03-函数与模块/函数与模块.md)

---

## 📚 参考资料

- [Python 控制流文档](https://docs.python.org/zh-cn/3/tutorial/controlflow.html)
- [Python 列表推导式](https://docs.python.org/zh-cn/3/tutorial/datastructures.html#list-comprehensions)

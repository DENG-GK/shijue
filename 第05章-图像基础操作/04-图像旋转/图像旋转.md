# 图像旋转

> 图像旋转在实际应用中非常常见：校正倾斜的文档、数据增强时随机旋转、制作特效等。OpenCV 提供了从简单的 90° 旋转到任意角度旋转的完整方案。

---

## 📖 理论部分

### 1. 简单旋转：cv2.rotate()

适用于 90°、180°、270° 的精确旋转，速度快且无损：

```python
import cv2
import numpy as np

img = np.random.randint(0, 256, (300, 400, 3), dtype=np.uint8)
print(f"原图: {img.shape}")   # (300, 400, 3)

# 顺时针旋转 90°
r90 = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
print(f"顺时针90°: {r90.shape}")   # (400, 300, 3) — 宽高互换了！

# 旋转 180°
r180 = cv2.rotate(img, cv2.ROTATE_180)
print(f"旋转180°: {r180.shape}")   # (300, 400, 3) — 宽高不变

# 逆时针旋转 90°（= 顺时针 270°）
r270 = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
print(f"逆时针90°: {r270.shape}")  # (400, 300, 3)
```

```
简单旋转效果：

原图 (300×400):        顺时针90° (400×300):
┌──────────────┐       ┌────────┐
│      ▲       │       │ ◄      │
│      │       │  →    │ │      │
│              │       │        │
└──────────────┘       └────────┘
  宽400 高300           宽300 高400

旋转180° (300×400):    逆时针90° (400×300):
┌──────────────┐       ┌────────┐
│              │       │        │
│      │       │       │     │  │
│      ▼       │       │     ►  │
└──────────────┘       └────────┘
```

---

### 2. 图像翻转：cv2.flip()

```python
img = np.random.randint(0, 256, (300, 400, 3), dtype=np.uint8)

# flipCode = 0：垂直翻转（上下镜像）
v_flip = cv2.flip(img, 0)

# flipCode = 1：水平翻转（左右镜像）
h_flip = cv2.flip(img, 1)

# flipCode = -1：同时翻转（等同于旋转180°）
both = cv2.flip(img, -1)
```

```
翻转效果：

原图:          垂直翻转(0):     水平翻转(1):     同时翻转(-1):
┌────────┐    ┌────────┐      ┌────────┐       ┌────────┐
│ A    B │    │ C    D │      │ B    A │       │ D    C │
│        │    │        │      │        │       │        │
│ C    D │    │ A    B │      │ D    C │       │ B    A │
└────────┘    └────────┘      └────────┘       └────────┘
               上下交换         左右交换          对角交换

flipCode:      0              1               -1
```

> 💡 **数据增强常用：** 水平翻转 `cv2.flip(img, 1)` 是图像分类和目标检测中最常用的数据增强方式之一。

---

### 3. 任意角度旋转：仿射变换

对于非 90° 倍数的旋转，需要用仿射变换：

```python
import cv2
import numpy as np

img = np.random.randint(0, 256, (400, 600, 3), dtype=np.uint8)
h, w = img.shape[:2]

# 步骤1：计算旋转矩阵
center = (w // 2, h // 2)    # 旋转中心 (x, y)
angle = 30                    # 旋转角度（逆时针为正）
scale = 1.0                   # 缩放因子

M = cv2.getRotationMatrix2D(center, angle, scale)
# M 是一个 2×3 的仿射变换矩阵

# 步骤2：应用仿射变换
rotated = cv2.warpAffine(img, M, (w, h))
# (w, h) 是输出图像的尺寸（宽, 高）
print(f"旋转30°: {rotated.shape}")
```

```
仿射变换旋转流程：

1. getRotationMatrix2D(center, angle, scale)
   → 生成旋转矩阵 M (2×3)

2. warpAffine(img, M, (output_w, output_h))
   → 对每个输出像素，通过 M 找到对应的源像素位置

注意：旋转后超出原始边界的部分会被裁剪（默认填充黑色）
```

#### 3.1 旋转后保持完整图像

默认情况下，旋转后输出尺寸和原图相同，导致角落被裁剪。要保留完整内容，需要计算新的边界：

```python
def rotate_full(img, angle):
    """旋转图像，保持完整内容不被裁剪"""
    h, w = img.shape[:2]
    center = (w / 2, h / 2)

    # 获取旋转矩阵
    M = cv2.getRotationMatrix2D(center, angle, 1.0)

    # 计算旋转后的边界尺寸
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    new_w = int(h * sin + w * cos)
    new_h = int(h * cos + w * sin)

    # 调整旋转矩阵的平移部分
    M[0, 2] += (new_w - w) / 2
    M[1, 2] += (new_h - h) / 2

    return cv2.warpAffine(img, M, (new_w, new_h))

img = np.random.randint(50, 200, (300, 400, 3), dtype=np.uint8)
full = rotate_full(img, 30)
print(f"原图: {img.shape}, 完整旋转30°: {full.shape}")
# 旋转后尺寸会变大
```

```
普通旋转 vs 完整旋转：

普通旋转（相同尺寸输出）：     完整旋转（扩大画布）：
┌────────────┐               ┌────────────────────┐
│  ╱      ╲  │               │      ╱      ╲      │
│ ╱ 保留区 ╲ │               │     ╱ 完整保留 ╲    │
│╱  域      ╲│               │    ╱  的图像    ╲   │
│╲  被裁掉  ╱│               │    ╲            ╱   │
│ ╲  角落  ╱ │               │     ╲          ╱    │
│  ╲      ╱  │               │      ╲        ╱     │
└────────────┘               └────────────────────┘
 四个角被裁掉！                所有内容都保留
```

#### 3.2 旋转并同时缩放

```python
h, w = img.shape[:2]
center = (w // 2, h // 2)

# 旋转 45° 同时缩小到 70%
M = cv2.getRotationMatrix2D(center, 45, 0.7)
result = cv2.warpAffine(img, M, (w, h))

# 旋转 -15° 同时放大到 120%
M2 = cv2.getRotationMatrix2D(center, -15, 1.2)
result2 = cv2.warpAffine(img, M2, (w, h))
```

---

### 4. NumPy 旋转（补充）

```python
# NumPy 也有旋转功能（只支持 90° 的倍数）
img = np.random.randint(0, 256, (300, 400, 3), dtype=np.uint8)

r90  = np.rot90(img, 1)    # 逆时针 90°
r180 = np.rot90(img, 2)    # 180°
r270 = np.rot90(img, 3)    # 逆时针 270° = 顺时针 90°

# 注意：np.rot90 是逆时针，cv2.ROTATE_90_CLOCKWISE 是顺时针
```

---

## 💻 代码实战

### 实战练习：图像旋转全流程

```python
# ===================================================================
# 实战练习：图像旋转全流程
# 目标：掌握简单旋转、翻转和任意角度旋转
# ===================================================================

import cv2
import numpy as np

# ---------- 1. 创建测试图像 ----------
print("=" * 55)
print("🎨 第一步：创建测试图像")
print("=" * 55)

img = np.zeros((300, 400, 3), dtype=np.uint8)
# 画一个不对称的图案以便观察旋转效果
cv2.rectangle(img, (50, 50), (350, 250), (100, 100, 100), -1)
cv2.circle(img, (200, 100), 40, (0, 0, 255), -1)      # 上方红圆
cv2.rectangle(img, (100, 180), (180, 240), (255, 0, 0), -1)  # 下方蓝块
cv2.putText(img, "TOP", (160, 80), cv2.FONT_HERSHEY_SIMPLEX,
            0.6, (255, 255, 255), 2)

print(f"  原图: {img.shape} ({img.shape[1]}×{img.shape[0]})")

# ---------- 2. 简单旋转 ----------
print("\n" + "=" * 55)
print("🔄 第二步：简单旋转")
print("=" * 55)

rotations = {
    "顺时针90°":  cv2.ROTATE_90_CLOCKWISE,
    "旋转180°":   cv2.ROTATE_180,
    "逆时针90°":  cv2.ROTATE_90_COUNTERCLOCKWISE,
}

for name, flag in rotations.items():
    result = cv2.rotate(img, flag)
    print(f"  {name}: {img.shape} → {result.shape}")

# ---------- 3. 翻转 ----------
print("\n" + "=" * 55)
print("🪞 第三步：图像翻转")
print("=" * 55)

flips = {
    "垂直翻转(上下)": 0,
    "水平翻转(左右)": 1,
    "同时翻转":      -1,
}

for name, code in flips.items():
    result = cv2.flip(img, code)
    # 翻转不改变尺寸
    print(f"  {name}: flipCode={code:>2d}, shape={result.shape}")

# 验证：同时翻转 = 旋转180°
both_flip = cv2.flip(img, -1)
rotate_180 = cv2.rotate(img, cv2.ROTATE_180)
print(f"\n  flip(-1) == rotate(180)? {np.array_equal(both_flip, rotate_180)}")

# ---------- 4. 任意角度旋转 ----------
print("\n" + "=" * 55)
print("📐 第四步：任意角度旋转")
print("=" * 55)

h, w = img.shape[:2]
center = (w // 2, h // 2)

angles = [15, 30, 45, 60, 90, 135, 180]
for angle in angles:
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(img, M, (w, h))
    # 计算黑色（被裁掉）的比例
    black_ratio = np.mean(np.all(rotated == 0, axis=2)) * 100
    print(f"  旋转{angle:>3d}°: shape={rotated.shape}, "
          f"黑色区域={black_ratio:.1f}%")

# ---------- 5. 完整旋转（不裁剪）----------
print("\n" + "=" * 55)
print("🖼️ 第五步：完整旋转")
print("=" * 55)

def rotate_full(img, angle):
    h, w = img.shape[:2]
    center = (w / 2, h / 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    new_w = int(h * sin + w * cos)
    new_h = int(h * cos + w * sin)
    M[0, 2] += (new_w - w) / 2
    M[1, 2] += (new_h - h) / 2
    return cv2.warpAffine(img, M, (new_w, new_h))

for angle in [15, 30, 45]:
    normal = cv2.warpAffine(img,
                            cv2.getRotationMatrix2D(center, angle, 1.0),
                            (w, h))
    full = rotate_full(img, angle)
    print(f"  旋转{angle}°: 普通={normal.shape}, "
          f"完整={full.shape}")

# ---------- 6. 旋转+缩放 ----------
print("\n" + "=" * 55)
print("🔀 第六步：旋转 + 缩放")
print("=" * 55)

scales = [0.5, 0.7, 1.0, 1.3]
angle = 30
for scale in scales:
    M = cv2.getRotationMatrix2D(center, angle, scale)
    result = cv2.warpAffine(img, M, (w, h))
    content_ratio = (1 - np.mean(np.all(result == 0, axis=2))) * 100
    print(f"  旋转{angle}° × {scale}: "
          f"有内容区域={content_ratio:.1f}%")

# ---------- 7. 旋转矩阵解析 ----------
print("\n" + "=" * 55)
print("🧮 第七步：旋转矩阵解析")
print("=" * 55)

M = cv2.getRotationMatrix2D((200, 150), 30, 1.0)
print(f"  旋转矩阵 M (2×3):")
print(f"    [{M[0,0]:>8.4f} {M[0,1]:>8.4f} {M[0,2]:>8.4f}]")
print(f"    [{M[1,0]:>8.4f} {M[1,1]:>8.4f} {M[1,2]:>8.4f}]")
print(f"\n  M[0,0]=cos(30°)={np.cos(np.radians(30)):.4f}")
print(f"  M[0,1]=sin(30°)={np.sin(np.radians(30)):.4f}")

print("\n✅ 图像旋转练习完成！")
```

**运行输出示例：**

```
=======================================================
🔄 第二步：简单旋转
=======================================================
  顺时针90°: (300, 400, 3) → (400, 300, 3)
  旋转180°: (300, 400, 3) → (300, 400, 3)
  逆时针90°: (300, 400, 3) → (400, 300, 3)

=======================================================
🪞 第三步：图像翻转
=======================================================
  垂直翻转(上下): flipCode= 0, shape=(300, 400, 3)
  水平翻转(左右): flipCode= 1, shape=(300, 400, 3)
  同时翻转:      flipCode=-1, shape=(300, 400, 3)

  flip(-1) == rotate(180)? True

=======================================================
📐 第四步：任意角度旋转
=======================================================
  旋转 15°: shape=(300, 400, 3), 黑色区域=12.3%
  旋转 30°: shape=(300, 400, 3), 黑色区域=22.1%
  旋转 45°: shape=(300, 400, 3), 黑色区域=28.6%
  旋转 90°: shape=(300, 400, 3), 黑色区域=16.7%

=======================================================
🖼️ 第五步：完整旋转
=======================================================
  旋转15°: 普通=(300, 400, 3), 完整=(324, 463, 3)
  旋转30°: 普通=(300, 400, 3), 完整=(396, 496, 3)
  旋转45°: 普通=(300, 400, 3), 完整=(494, 494, 3)
```

---

## 🚨 常见问题与易错点

### Q1: rotate 和 warpAffine 旋转 90° 结果一样吗？

```python
img = np.random.randint(0, 256, (300, 400, 3), dtype=np.uint8)

# cv2.rotate — 精确的90°旋转，宽高自动交换
r1 = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
print(r1.shape)   # (400, 300, 3) — 宽高交换了

# warpAffine — 需要手动指定输出尺寸
h, w = img.shape[:2]
M = cv2.getRotationMatrix2D((w/2, h/2), -90, 1.0)  # 顺时针=负角度
r2 = cv2.warpAffine(img, M, (h, w))   # 注意输出尺寸也要交换
# r2 和 r1 可能有微小差异（浮点计算）

# 建议：90°的倍数用 cv2.rotate()，其他角度用 warpAffine
```

### Q2: 旋转角度是顺时针还是逆时针？

```python
# getRotationMatrix2D 中：正角度 = 逆时针
# 日常说的"顺时针30°" → 传入 -30
M = cv2.getRotationMatrix2D(center, 30, 1.0)    # 逆时针30°
M = cv2.getRotationMatrix2D(center, -30, 1.0)   # 顺时针30°

# cv2.rotate 的常量名已经说明了方向
cv2.ROTATE_90_CLOCKWISE          # 顺时针90°
cv2.ROTATE_90_COUNTERCLOCKWISE   # 逆时针90°
```

### Q3: 旋转后出现黑色区域？

```python
# 默认行为：输出尺寸 = 输入尺寸 → 超出边界的部分被裁掉（变黑）
# 解决方案1：用 rotate_full 函数扩大画布
# 解决方案2：指定边框填充模式
M = cv2.getRotationMatrix2D(center, 30, 1.0)
result = cv2.warpAffine(img, M, (w, h),
                         borderMode=cv2.BORDER_REFLECT)  # 镜像填充边界
```

### Q4: 翻转和旋转的组合？

```python
# 常见组合
img = np.random.randint(0, 256, (300, 400, 3), dtype=np.uint8)

# 水平翻转 + 顺时针90° = 转置
flipped_rotated = cv2.rotate(cv2.flip(img, 1), cv2.ROTATE_90_CLOCKWISE)

# NumPy 转置
transposed = np.transpose(img, (1, 0, 2))

# 注意：这两个结果是相同的
print(np.array_equal(flipped_rotated, transposed))   # True
```

---

## 🎯 总结

本节学习了图像旋转操作：

✅ **简单旋转**：`cv2.rotate()` — 90°/180°/270°，快速无损
✅ **翻转**：`cv2.flip(img, code)` — 0=垂直，1=水平，-1=同时
✅ **任意旋转**：`getRotationMatrix2D` + `warpAffine` — 任意角度
✅ **完整旋转**：计算新边界，扩大画布避免裁剪
✅ **旋转+缩放**：`getRotationMatrix2D(center, angle, scale)` 同时旋转缩放
✅ **角度方向**：`getRotationMatrix2D` 中正角度 = 逆时针
✅ **数据增强**：水平翻转 `flip(img, 1)` 是最常用的增强方式

> 🔑 **核心要点：** 90° 倍数旋转用 `cv2.rotate()`（简单高效），任意角度用 `getRotationMatrix2D` + `warpAffine`。注意正角度是逆时针方向。旋转后如果不想被裁剪，需要计算新的画布尺寸。

**下一步：**
👉 [05 - 图形绘制](../05-图形绘制/图形绘制.md)

---

## 📚 参考资料

- [OpenCV 官方文档 - 几何变换](https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html)
- [OpenCV-Python 图像旋转教程](https://docs.opencv.org/4.x/dd/d52/tutorial_js_geometric_transformations.html)

# 图像裁剪

> 图像裁剪是最基本也是最常用的图像操作之一。无论是提取人脸区域、截取感兴趣区域（ROI），还是去掉多余的边框，都需要用到裁剪。好消息是——在 OpenCV 中，裁剪就是 NumPy 切片，你已经会了一半！

---

## 📖 理论部分

### 1. 裁剪的本质：NumPy 切片

OpenCV 图像就是 NumPy 数组，所以**裁剪 = 数组切片**，不需要任何特殊函数：

```python
import cv2
import numpy as np

# 基本裁剪语法
roi = img[y1:y2, x1:x2]       # 灰度图
roi = img[y1:y2, x1:x2]       # 彩色图也一样（自动包含所有通道）

# 裁剪出从 (y1,x1) 到 (y2,x2) 的矩形区域
# 注意：y1:y2 是行范围（高度方向），x1:x2 是列范围（宽度方向）
# 包含起始行/列，不包含结束行/列（Python 切片规则）
```

```
裁剪坐标示意：

  原始图像 img (H × W):
  ┌──────────────────────────────┐
  │                              │
  │     (y1,x1)                  │
  │       ┌──────────┐           │
  │       │          │           │
  │       │   ROI    │           │
  │       │          │           │
  │       └──────────┘           │
  │              (y2,x2)         │
  │                              │
  └──────────────────────────────┘

  roi = img[y1:y2, x1:x2]
  ROI 的尺寸：高度 = y2-y1，宽度 = x2-x1
```

> ⚠️ **坐标顺序再次强调：** 裁剪时是 `img[y:, x:]`，**y（行）在前，x（列）在后**。这和日常说的"宽×高"是反的，务必注意！

---

### 2. 基本裁剪操作

#### 2.1 裁剪指定区域

```python
import cv2
import numpy as np

# 创建测试图像
img = np.random.randint(0, 256, (400, 600, 3), dtype=np.uint8)
print(f"原图: {img.shape}")   # (400, 600, 3)

# 裁剪中心区域（200×300）
h, w = img.shape[:2]
cx, cy = w // 2, h // 2    # 图像中心
half_w, half_h = 150, 100

roi = img[cy-half_h:cy+half_h, cx-half_w:cx+half_w]
print(f"中心裁剪: {roi.shape}")   # (200, 300, 3)

# 裁剪四个角落
top_left     = img[:100, :100]       # 左上角 100×100
top_right    = img[:100, -100:]      # 右上角 100×100（负索引！）
bottom_left  = img[-100:, :100]      # 左下角
bottom_right = img[-100:, -100:]     # 右下角

print(f"四角裁剪: {top_left.shape}")   # (100, 100, 3)
```

#### 2.2 裁剪与复制的区别

```python
# 切片返回的是视图（共享内存）！
img = np.zeros((300, 400, 3), dtype=np.uint8)

# 视图：修改 roi 会影响原图！
roi_view = img[50:150, 100:200]
roi_view[:] = [0, 0, 255]     # roi 变红 → 原图对应区域也变红了！
print(f"原图被修改? 原图(100,150)={img[100, 150]}")   # [0, 0, 255]

# 深拷贝：独立副本，修改不影响原图
roi_copy = img[50:150, 200:300].copy()
roi_copy[:] = [0, 255, 0]     # 只修改副本
print(f"原图不变? 原图(100,250)={img[100, 250]}")     # [0, 0, 0]
```

```
视图 vs 副本：

视图（默认行为）：         副本（.copy()）：
roi = img[y1:y2, x1:x2]   roi = img[y1:y2, x1:x2].copy()

    img                         img          roi(独立)
  ┌─────────┐                ┌─────────┐   ┌──────┐
  │  ┌───┐  │ ← 共享内存     │  ┌───┐  │   │      │
  │  │roi│  │                │  │   │  │   │ copy │
  │  └───┘  │                │  └───┘  │   └──────┘
  └─────────┘                └─────────┘

修改roi → 原图也变！      修改roi → 原图不变
```

> 💡 **经验法则：**
> - 只读操作 → 直接切片（更快，不占额外内存）
> - 需要独立修改 → 用 `.copy()`
> - 不确定就用 `.copy()`，安全第一

---

### 3. 常见裁剪场景

#### 3.1 按比例裁剪

```python
def crop_center(img, ratio=0.5):
    """裁剪图像中心区域，ratio 为保留比例"""
    h, w = img.shape[:2]
    new_h, new_w = int(h * ratio), int(w * ratio)
    y1 = (h - new_h) // 2
    x1 = (w - new_w) // 2
    return img[y1:y1+new_h, x1:x1+new_w].copy()

img = np.random.randint(0, 256, (400, 600, 3), dtype=np.uint8)
center_50 = crop_center(img, 0.5)
print(f"50%中心裁剪: {center_50.shape}")   # (200, 300, 3)
```

#### 3.2 正方形裁剪（深度学习常用）

```python
def crop_square(img):
    """将图像裁剪为正方形（取中心）"""
    h, w = img.shape[:2]
    size = min(h, w)
    y1 = (h - size) // 2
    x1 = (w - size) // 2
    return img[y1:y1+size, x1:x1+size].copy()

img = np.random.randint(0, 256, (300, 500, 3), dtype=np.uint8)
square = crop_square(img)
print(f"正方形裁剪: {square.shape}")   # (300, 300, 3)
```

#### 3.3 根据边界框裁剪（目标检测）

```python
def crop_bbox(img, bbox):
    """根据边界框 [x1, y1, x2, y2] 裁剪"""
    x1, y1, x2, y2 = bbox
    # 确保不越界
    h, w = img.shape[:2]
    x1 = max(0, x1)
    y1 = max(0, y1)
    x2 = min(w, x2)
    y2 = min(h, y2)
    return img[y1:y2, x1:x2].copy()

img = np.random.randint(0, 256, (480, 640, 3), dtype=np.uint8)

# 模拟人脸检测结果：[x1, y1, x2, y2]
face_bbox = [200, 100, 400, 350]
face = crop_bbox(img, face_bbox)
print(f"人脸裁剪: {face.shape}")   # (250, 200, 3)
```

#### 3.4 去除黑色边框

```python
def remove_black_border(img, threshold=10):
    """去除图像四周的黑色边框"""
    if img.ndim == 3:
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    else:
        gray = img

    # 找到非黑色区域
    rows = np.any(gray > threshold, axis=1)
    cols = np.any(gray > threshold, axis=0)

    y1, y2 = np.where(rows)[0][[0, -1]]
    x1, x2 = np.where(cols)[0][[0, -1]]

    return img[y1:y2+1, x1:x2+1].copy()
```

---

### 4. ROI 操作：读取与写入

裁剪不仅用于提取，还可以用于**写入**（在原图上修改区域）：

```python
import cv2
import numpy as np

img = np.zeros((300, 400, 3), dtype=np.uint8)

# 在指定区域填充颜色
img[50:150, 100:200] = [255, 0, 0]     # 蓝色矩形
img[100:200, 200:300] = [0, 255, 0]    # 绿色矩形

# 复制一个区域到另一个位置
roi = img[50:150, 100:200].copy()       # 先复制
img[150:250, 250:350] = roi             # 粘贴到新位置

# 交换两个区域
region_a = img[50:100, 50:100].copy()
region_b = img[200:250, 300:350].copy()
img[50:100, 50:100] = region_b
img[200:250, 300:350] = region_a
```

> ⚠️ **复制粘贴时注意：** 源区域和目标区域的尺寸必须完全相同！如果不同，需要先用 `cv2.resize()` 调整。

---

## 💻 代码实战

### 实战练习：图像裁剪全流程

```python
# ===================================================================
# 实战练习：图像裁剪全流程
# 目标：掌握各种裁剪场景和注意事项
# ===================================================================

import cv2
import numpy as np

# ---------- 1. 创建测试图像 ----------
print("=" * 55)
print("🎨 第一步：创建测试图像")
print("=" * 55)

# 创建渐变彩色图像
img = np.zeros((400, 600, 3), dtype=np.uint8)
for y in range(400):
    for x in range(600):
        img[y, x] = [int(x * 255 / 599), int(y * 255 / 399), 128]

print(f"  原始图像: {img.shape} ({img.shape[1]}×{img.shape[0]})")

# ---------- 2. 基本裁剪 ----------
print("\n" + "=" * 55)
print("✂️ 第二步：基本裁剪")
print("=" * 55)

# 裁剪左上角
top_left = img[:200, :300]
print(f"  左上角 img[:200, :300]: {top_left.shape}")

# 裁剪右下角
bottom_right = img[200:, 300:]
print(f"  右下角 img[200:, 300:]: {bottom_right.shape}")

# 负索引裁剪
last_100 = img[-100:, -150:]
print(f"  最后100行150列: {last_100.shape}")

# ---------- 3. 中心裁剪 ----------
print("\n" + "=" * 55)
print("🎯 第三步：中心裁剪")
print("=" * 55)

h, w = img.shape[:2]
ratios = [0.8, 0.5, 0.3]
for ratio in ratios:
    new_h, new_w = int(h * ratio), int(w * ratio)
    y1 = (h - new_h) // 2
    x1 = (w - new_w) // 2
    cropped = img[y1:y1+new_h, x1:x1+new_w]
    print(f"  {ratio*100:.0f}%中心裁剪: {cropped.shape} "
          f"({cropped.shape[1]}×{cropped.shape[0]})")

# ---------- 4. 正方形裁剪 ----------
print("\n" + "=" * 55)
print("⬜ 第四步：正方形裁剪")
print("=" * 55)

size = min(h, w)
y1 = (h - size) // 2
x1 = (w - size) // 2
square = img[y1:y1+size, x1:x1+size]
print(f"  原始: {img.shape[1]}×{img.shape[0]} (宽×高)")
print(f"  正方形: {square.shape[1]}×{square.shape[0]}")
print(f"  裁剪位置: y=[{y1}:{y1+size}], x=[{x1}:{x1+size}]")

# ---------- 5. 视图与副本验证 ----------
print("\n" + "=" * 55)
print("🔍 第五步：视图 vs 副本")
print("=" * 55)

test = np.zeros((100, 100, 3), dtype=np.uint8)

# 视图
view = test[10:20, 10:20]
view[:] = [255, 0, 0]
print(f"  视图修改后原图(15,15): {test[15, 15]}")   # 被修改了

# 副本
test2 = np.zeros((100, 100, 3), dtype=np.uint8)
copy = test2[10:20, 10:20].copy()
copy[:] = [0, 255, 0]
print(f"  副本修改后原图(15,15): {test2[15, 15]}")  # 没被修改

# ---------- 6. 边界框裁剪 ----------
print("\n" + "=" * 55)
print("📦 第六步：边界框裁剪")
print("=" * 55)

# 模拟检测结果
bboxes = [
    {"class": "person", "bbox": [50, 30, 200, 350]},
    {"class": "car",    "bbox": [300, 200, 550, 380]},
    {"class": "dog",    "bbox": [400, 100, 580, 300]},
]

for det in bboxes:
    x1, y1, x2, y2 = det["bbox"]
    # 安全裁剪（防越界）
    x1 = max(0, x1)
    y1 = max(0, y1)
    x2 = min(w, x2)
    y2 = min(h, y2)
    roi = img[y1:y2, x1:x2]
    print(f"  {det['class']:>6s}: bbox={det['bbox']}, "
          f"裁剪尺寸={roi.shape[1]}×{roi.shape[0]}")

# ---------- 7. ROI 写入操作 ----------
print("\n" + "=" * 55)
print("📝 第七步：ROI 写入")
print("=" * 55)

canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# 在不同位置填充颜色块
regions = [
    ((20, 50, 120, 150), [0, 0, 255], "红色"),
    ((20, 160, 120, 260), [0, 255, 0], "绿色"),
    ((20, 270, 120, 370), [255, 0, 0], "蓝色"),
]

for (y1, x1, y2, x2), color, name in regions:
    canvas[y1:y2, x1:x2] = color
    print(f"  {name}块: ({y1},{x1})-({y2},{x2}), "
          f"大小={x2-x1}×{y2-y1}")

# 复制粘贴
source = canvas[20:120, 50:150].copy()
canvas[180:280, 50:150] = source
print(f"\n  复制红色块到下方: (180,50)-(280,150)")

# 验证
print(f"  原位置颜色: {canvas[70, 100]}")
print(f"  新位置颜色: {canvas[230, 100]}")
print(f"  相同? {np.array_equal(canvas[70, 100], canvas[230, 100])}")

print("\n✅ 图像裁剪练习完成！")
```

**运行输出示例：**

```
=======================================================
🎨 第一步：创建测试图像
=======================================================
  原始图像: (400, 600, 3) (600×400)

=======================================================
✂️ 第二步：基本裁剪
=======================================================
  左上角 img[:200, :300]: (200, 300, 3)
  右下角 img[200:, 300:]: (200, 300, 3)
  最后100行150列: (100, 150, 3)

=======================================================
🎯 第三步：中心裁剪
=======================================================
  80%中心裁剪: (320, 480, 3) (480×320)
  50%中心裁剪: (200, 300, 3) (300×200)
  30%中心裁剪: (120, 180, 3) (180×120)

=======================================================
🔍 第五步：视图 vs 副本
=======================================================
  视图修改后原图(15,15): [255   0   0]
  副本修改后原图(15,15): [0 0 0]

=======================================================
📦 第六步：边界框裁剪
=======================================================
  person: bbox=[50, 30, 200, 350], 裁剪尺寸=150×320
     car: bbox=[300, 200, 550, 380], 裁剪尺寸=250×180
     dog: bbox=[400, 100, 580, 300], 裁剪尺寸=180×200
```

---

## 🚨 常见问题与易错点

### Q1: 裁剪时 x 和 y 搞反了？

```python
# ❌ 常见错误
roi = img[x1:x2, y1:y2]   # 把 x 和 y 的位置搞反了！

# ✅ 正确写法
roi = img[y1:y2, x1:x2]   # y（行）在前，x（列）在后

# 记忆方法：
# img[行, 列] = img[y, x] = img[高度方向, 宽度方向]
# shape = (H, W) → 第一维=高=行=y，第二维=宽=列=x
```

### Q2: 裁剪后修改影响了原图？

```python
img = np.zeros((100, 100, 3), dtype=np.uint8)

# 切片是视图（共享内存）
roi = img[10:50, 10:50]
roi[:] = 255                 # 原图也变了！

# 如果不想影响原图，用 .copy()
roi = img[10:50, 10:50].copy()
roi[:] = 0                   # 原图不受影响
```

### Q3: 裁剪区域超出图像边界？

```python
img = np.zeros((100, 100), dtype=np.uint8)

# NumPy 切片不会报错，但会自动截断！
roi = img[80:200, 50:150]
print(roi.shape)   # (20, 50) — 不是(120, 100)！
# 80:200 → 实际是 80:100（只有20行）
# 50:150 → 实际是 50:100（只有50列）

# 如果需要严格检查，自己做边界限制
def safe_crop(img, y1, y2, x1, x2):
    h, w = img.shape[:2]
    y1 = max(0, y1)
    y2 = min(h, y2)
    x1 = max(0, x1)
    x2 = min(w, x2)
    return img[y1:y2, x1:x2].copy()
```

### Q4: 裁剪结果粘贴时尺寸不匹配？

```python
img = np.zeros((300, 400, 3), dtype=np.uint8)
roi = np.ones((100, 100, 3), dtype=np.uint8) * 255

# ❌ 尺寸不匹配
# img[50:200, 50:200] = roi   # 150×150 ≠ 100×100 → 报错！

# ✅ 确保尺寸一致
img[50:150, 50:150] = roi     # 100×100 = 100×100 ✓

# 或者先 resize
roi_resized = cv2.resize(roi, (150, 150))
img[50:200, 50:200] = roi_resized
```

---

## 🎯 总结

本节学习了图像裁剪操作：

✅ **裁剪语法**：`img[y1:y2, x1:x2]`，y（行）在前，x（列）在后
✅ **视图与副本**：切片默认是视图（共享内存），`.copy()` 创建独立副本
✅ **中心裁剪**：计算中心坐标，向两侧扩展
✅ **正方形裁剪**：取 `min(h, w)` 作为边长，深度学习预处理常用
✅ **边界框裁剪**：根据检测结果 `[x1,y1,x2,y2]` 裁剪目标区域
✅ **安全裁剪**：用 `max(0, ...)` 和 `min(h/w, ...)` 防止越界
✅ **ROI 写入**：直接对切片赋值可以修改原图的对应区域

> 🔑 **核心要点：** 图像裁剪就是 NumPy 切片 `img[y1:y2, x1:x2]`，简单直接。但要特别注意两件事：① **y在前x在后**（和直觉相反）；② 切片默认是**视图**，修改会影响原图，需要独立副本请用 `.copy()`。

**下一步：**
👉 [02 - 图像拼接](../02-图像拼接/图像拼接.md)

---

## 📚 参考资料

- [OpenCV-Python 图像基本操作](https://docs.opencv.org/4.x/d3/df2/tutorial_py_basic_ops.html)
- [NumPy 数组切片](https://numpy.org/doc/stable/user/basics.indexing.html)

# 图像缩放

> 图像缩放是最常用的几何变换之一。无论是调整图片尺寸适配网页、缩小图片节省存储，还是将图像缩放到模型要求的输入尺寸（如 224×224），都需要用到 `cv2.resize()`。缩放看似简单，但选择不同的插值方法会直接影响图像质量。

---

## 📖 理论部分

### 1. cv2.resize() 基本用法

```python
import cv2
import numpy as np

img = np.random.randint(0, 256, (480, 640, 3), dtype=np.uint8)

# 方式1：指定目标尺寸 (宽, 高) — 注意是 (W, H) 不是 (H, W)！
resized = cv2.resize(img, (320, 240))
print(f"指定尺寸: {resized.shape}")   # (240, 320, 3)

# 方式2：指定缩放比例
half = cv2.resize(img, None, fx=0.5, fy=0.5)    # 缩小一半
double = cv2.resize(img, None, fx=2.0, fy=2.0)  # 放大两倍
print(f"缩小一半: {half.shape}")     # (240, 320, 3)
print(f"放大两倍: {double.shape}")   # (960, 1280, 3)

# 非等比缩放
stretched = cv2.resize(img, None, fx=2.0, fy=0.5)
print(f"宽×2高÷2: {stretched.shape}")  # (240, 1280, 3)
```

> ⚠️ **最大陷阱：** `cv2.resize(img, (宽, 高))` 的参数是 **(宽度, 高度)**，和 `shape` 返回的 **(高度, 宽度)** 正好是**反的**！这是新手犯错率极高的地方。

```
cv2.resize 参数顺序 vs shape：

img.shape  = (480, 640, 3)  → (高度, 宽度, 通道)
cv2.resize → (640, 480)     → (宽度, 高度)

它们是反的！记忆方法：
  shape 返回的是 (H, W)
  resize 需要的是 (W, H)
```

---

### 2. 插值方法详解

缩放时，新像素的值需要从原始像素中"推算"出来，这个过程叫**插值**。不同的插值方法在速度和质量之间有不同的权衡。

#### 2.1 插值方法对比

| 方法 | 常量名 | 原理 | 速度 | 质量 | 推荐场景 |
|------|--------|------|------|------|----------|
| **最近邻** | `INTER_NEAREST` | 取最近的像素值 | ⚡最快 | ⭐低 | 掩膜/标签图缩放 |
| **双线性** | `INTER_LINEAR` | 2×2 邻域加权平均 | ⚡快 | ⭐⭐中 | **放大（默认）** |
| **双三次** | `INTER_CUBIC` | 4×4 邻域加权平均 | 🐢较慢 | ⭐⭐⭐高 | 高质量放大 |
| **区域** | `INTER_AREA` | 像素区域重采样 | ⚡快 | ⭐⭐⭐高 | **缩小（推荐）** |
| **Lanczos** | `INTER_LANCZOS4` | 8×8 邻域 Lanczos | 🐢最慢 | ⭐⭐⭐最高 | 最高质量放大 |

```python
img = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)

# 放大 4 倍 — 用不同插值方法
nearest  = cv2.resize(img, (400, 400), interpolation=cv2.INTER_NEAREST)
linear   = cv2.resize(img, (400, 400), interpolation=cv2.INTER_LINEAR)
cubic    = cv2.resize(img, (400, 400), interpolation=cv2.INTER_CUBIC)
lanczos  = cv2.resize(img, (400, 400), interpolation=cv2.INTER_LANCZOS4)

# 缩小 — 推荐用 INTER_AREA
small = cv2.resize(img, (25, 25), interpolation=cv2.INTER_AREA)
```

```
插值方法直觉理解：

最近邻（INTER_NEAREST）：
  像"马赛克"一样，每个新像素直接复制最近的原像素
  优点：快，不引入新值（适合标签/掩膜）
  缺点：锯齿明显

双线性（INTER_LINEAR）：
  取周围 2×2 个像素的加权平均
  优点：平滑，速度适中
  缺点：可能略微模糊

双三次（INTER_CUBIC）：
  取周围 4×4 个像素的加权平均
  优点：更平滑，细节更好
  缺点：速度较慢

区域（INTER_AREA）：
  考虑整个像素区域，类似"求平均"
  专为缩小优化，避免摩尔纹
```

#### 2.2 何时用什么插值？

```python
# 经验总结：
# 缩小图像 → INTER_AREA（效果最好，避免摩尔纹/锯齿）
# 放大图像 → INTER_LINEAR（默认，速度与质量平衡）
#           → INTER_CUBIC（更高质量，稍慢）
# 掩膜/标签 → INTER_NEAREST（不会引入新的标签值！）

# ⚠️ 特别注意：掩膜图一定要用 INTER_NEAREST！
mask = np.array([[0, 0, 255], [255, 0, 0]], dtype=np.uint8)

# ❌ 双线性插值会产生中间值（0到255之间的值）
bad = cv2.resize(mask, (6, 4), interpolation=cv2.INTER_LINEAR)
print(np.unique(bad))   # [0, 64, 128, 191, 255] — 多出了中间值！

# ✅ 最近邻只保留原始值
good = cv2.resize(mask, (6, 4), interpolation=cv2.INTER_NEAREST)
print(np.unique(good))  # [0, 255] — 只有原始值
```

---

### 3. 常见缩放场景

#### 3.1 等比缩放

```python
def resize_keep_ratio(img, target_size, pad=True, pad_color=(0, 0, 0)):
    """等比缩放到目标尺寸，可选填充"""
    h, w = img.shape[:2]
    target_w, target_h = target_size

    # 计算缩放比例
    scale = min(target_w / w, target_h / h)
    new_w = int(w * scale)
    new_h = int(h * scale)

    # 缩放
    interp = cv2.INTER_AREA if scale < 1 else cv2.INTER_LINEAR
    resized = cv2.resize(img, (new_w, new_h), interpolation=interp)

    if not pad:
        return resized

    # 填充到目标尺寸（居中）
    canvas = np.full((target_h, target_w, 3), pad_color, dtype=np.uint8)
    y_offset = (target_h - new_h) // 2
    x_offset = (target_w - new_w) // 2
    canvas[y_offset:y_offset+new_h, x_offset:x_offset+new_w] = resized

    return canvas

img = np.random.randint(0, 256, (300, 500, 3), dtype=np.uint8)
result = resize_keep_ratio(img, (224, 224))
print(f"等比缩放+填充: {result.shape}")   # (224, 224, 3)
```

```
等比缩放 + 填充示意：

原图 500×300 → 目标 224×224

1. 计算缩放比:
   scale_w = 224/500 = 0.448
   scale_h = 224/300 = 0.747
   scale = min(0.448, 0.747) = 0.448

2. 缩放: 500×0.448=224, 300×0.448=134
   → 224×134

3. 居中填充到 224×224:
   ┌──────────────────┐
   │    padding (黑)   │  45行
   ├──────────────────┤
   │                  │
   │   缩放后的图像    │  134行
   │   (224×134)      │
   ├──────────────────┤
   │    padding (黑)   │  45行
   └──────────────────┘
```

#### 3.2 深度学习预处理常用缩放

```python
def preprocess_for_model(img, input_size=(224, 224)):
    """深度学习模型输入预处理"""
    h, w = img.shape[:2]
    scale = min(input_size[0] / w, input_size[1] / h)
    new_w = int(w * scale)
    new_h = int(h * scale)
    resized = cv2.resize(img, (new_w, new_h))

    # 填充到正方形
    canvas = np.full((input_size[1], input_size[0], 3), 114, dtype=np.uint8)
    y_off = (input_size[1] - new_h) // 2
    x_off = (input_size[0] - new_w) // 2
    canvas[y_off:y_off+new_h, x_off:x_off+new_w] = resized

    return canvas

# 也有直接强制缩放的做法（简单但会变形）
def preprocess_simple(img, size=(224, 224)):
    return cv2.resize(img, size)   # 不保持比例，可能变形
```

#### 3.3 缩略图生成

```python
def make_thumbnail(img, max_size=200):
    """生成缩略图，长边不超过 max_size"""
    h, w = img.shape[:2]
    if max(h, w) <= max_size:
        return img.copy()

    scale = max_size / max(h, w)
    new_w = int(w * scale)
    new_h = int(h * scale)
    return cv2.resize(img, (new_w, new_h), interpolation=cv2.INTER_AREA)

img = np.random.randint(0, 256, (1080, 1920, 3), dtype=np.uint8)
thumb = make_thumbnail(img, 200)
print(f"缩略图: {thumb.shape}")   # (112, 200, 3)
```

---

## 💻 代码实战

### 实战练习：图像缩放全流程

```python
# ===================================================================
# 实战练习：图像缩放全流程
# 目标：掌握 cv2.resize 的各种用法和插值选择
# ===================================================================

import cv2
import numpy as np
import time

# ---------- 1. 基本缩放 ----------
print("=" * 55)
print("📐 第一步：基本缩放")
print("=" * 55)

img = np.random.randint(0, 256, (480, 640, 3), dtype=np.uint8)
print(f"  原图: {img.shape} ({img.shape[1]}×{img.shape[0]})")

# 指定目标尺寸
small = cv2.resize(img, (320, 240))
print(f"  缩小到320×240: {small.shape}")

large = cv2.resize(img, (1280, 960))
print(f"  放大到1280×960: {large.shape}")

# 指定比例
half = cv2.resize(img, None, fx=0.5, fy=0.5)
print(f"  缩小50%: {half.shape}")

double = cv2.resize(img, None, fx=2.0, fy=2.0)
print(f"  放大200%: {double.shape}")

# ---------- 2. 插值方法对比 ----------
print("\n" + "=" * 55)
print("🔬 第二步：插值方法对比")
print("=" * 55)

# 创建带清晰边缘的测试图
test = np.zeros((50, 50, 3), dtype=np.uint8)
cv2.rectangle(test, (10, 10), (40, 40), (255, 255, 255), -1)
cv2.circle(test, (25, 25), 15, (0, 0, 255), -1)

methods = {
    "NEAREST":  cv2.INTER_NEAREST,
    "LINEAR":   cv2.INTER_LINEAR,
    "CUBIC":    cv2.INTER_CUBIC,
    "AREA":     cv2.INTER_AREA,
    "LANCZOS4": cv2.INTER_LANCZOS4,
}

# 放大 8 倍
print(f"  50×50 → 400×400 (放大8倍):")
for name, method in methods.items():
    t0 = time.time()
    for _ in range(100):
        result = cv2.resize(test, (400, 400), interpolation=method)
    elapsed = (time.time() - t0) * 10   # 单次毫秒
    unique_vals = len(np.unique(result.reshape(-1, 3), axis=0))
    print(f"    {name:<10s}: 耗时≈{elapsed:.2f}ms, 唯一颜色数={unique_vals}")

# 缩小
print(f"\n  640×480 → 160×120 (缩小4倍):")
for name, method in methods.items():
    t0 = time.time()
    for _ in range(100):
        result = cv2.resize(img, (160, 120), interpolation=method)
    elapsed = (time.time() - t0) * 10
    print(f"    {name:<10s}: 耗时≈{elapsed:.2f}ms")

# ---------- 3. 掩膜缩放对比 ----------
print("\n" + "=" * 55)
print("🎭 第三步：掩膜缩放—插值方法的影响")
print("=" * 55)

mask = np.zeros((100, 100), dtype=np.uint8)
cv2.circle(mask, (50, 50), 30, 255, -1)
print(f"  原始掩膜唯一值: {np.unique(mask)}")

for name, method in methods.items():
    resized = cv2.resize(mask, (200, 200), interpolation=method)
    vals = np.unique(resized)
    status = "✅" if len(vals) <= 2 else "❌"
    print(f"    {name:<10s}: 唯一值数量={len(vals)} {status}")

print("  → 掩膜/标签图必须用 INTER_NEAREST！")

# ---------- 4. 等比缩放 ----------
print("\n" + "=" * 55)
print("📏 第四步：等比缩放与填充")
print("=" * 55)

sizes = [(640, 480), (1920, 1080), (500, 500), (100, 800)]
target = (224, 224)

for w, h in sizes:
    img_t = np.random.randint(0, 256, (h, w, 3), dtype=np.uint8)
    scale = min(target[0] / w, target[1] / h)
    new_w, new_h = int(w * scale), int(h * scale)
    resized = cv2.resize(img_t, (new_w, new_h))

    canvas = np.zeros((target[1], target[0], 3), dtype=np.uint8)
    y_off = (target[1] - new_h) // 2
    x_off = (target[0] - new_w) // 2
    canvas[y_off:y_off+new_h, x_off:x_off+new_w] = resized

    print(f"  {w}×{h} → scale={scale:.3f} → "
          f"{new_w}×{new_h} → 填充到{target[0]}×{target[1]}")

# ---------- 5. 常见分辨率转换 ----------
print("\n" + "=" * 55)
print("🖥️ 第五步：常见分辨率转换")
print("=" * 55)

img = np.random.randint(0, 256, (1080, 1920, 3), dtype=np.uint8)
print(f"  原始: 1920×1080 ({img.nbytes/1024/1024:.1f}MB)")

resolutions = {
    "720p":  (1280, 720),
    "480p":  (640, 480),
    "360p":  (480, 360),
    "缩略图": (320, 180),
}

for name, (w, h) in resolutions.items():
    resized = cv2.resize(img, (w, h), interpolation=cv2.INTER_AREA)
    mem = resized.nbytes / 1024 / 1024
    ratio = resized.size / img.size * 100
    print(f"  {name:>4s}: {w}×{h}, {mem:.1f}MB ({ratio:.1f}%)")

print("\n✅ 图像缩放练习完成！")
```

**运行输出示例：**

```
=======================================================
📐 第一步：基本缩放
=======================================================
  原图: (480, 640, 3) (640×480)
  缩小到320×240: (240, 320, 3)
  放大到1280×960: (960, 1280, 3)
  缩小50%: (240, 320, 3)
  放大200%: (960, 1280, 3)

=======================================================
🎭 第三步：掩膜缩放—插值方法的影响
=======================================================
  原始掩膜唯一值: [  0 255]
    NEAREST   : 唯一值数量=2 ✅
    LINEAR    : 唯一值数量=187 ❌
    CUBIC     : 唯一值数量=241 ❌
    AREA      : 唯一值数量=5 ❌
    LANCZOS4  : 唯一值数量=253 ❌
  → 掩膜/标签图必须用 INTER_NEAREST！

=======================================================
🖥️ 第五步：常见分辨率转换
=======================================================
  原始: 1920×1080 (5.9MB)
  720p: 1280×720, 2.6MB (44.4%)
  480p: 640×480, 0.9MB (14.8%)
  360p: 480×360, 0.5MB (8.3%)
  缩略图: 320×180, 0.2MB (2.8%)
```

---

## 🚨 常见问题与易错点

### Q1: resize 参数是 (宽, 高) 还是 (高, 宽)？

```python
img = np.zeros((480, 640, 3), dtype=np.uint8)

# cv2.resize 参数是 (宽, 高)！和 shape 相反！
resized = cv2.resize(img, (320, 240))   # (宽=320, 高=240)
print(resized.shape)   # (240, 320, 3) → shape 是 (高, 宽)

# 如果搞反了：
wrong = cv2.resize(img, (240, 320))     # 你以为的240高320宽
print(wrong.shape)   # (320, 240, 3) → 实际变成了320高240宽！

# 安全做法：用比例缩放
safe = cv2.resize(img, None, fx=0.5, fy=0.5)   # 按比例更安全
```

### Q2: 放大和缩小应该用什么插值？

```python
# 缩小 → INTER_AREA（专为缩小优化）
small = cv2.resize(img, (320, 240), interpolation=cv2.INTER_AREA)

# 放大 → INTER_LINEAR（速度快）或 INTER_CUBIC（质量好）
large = cv2.resize(img, (1280, 960), interpolation=cv2.INTER_LINEAR)

# 掩膜/标签图 → INTER_NEAREST（无论放大还是缩小！）
mask_resized = cv2.resize(mask, (320, 240), interpolation=cv2.INTER_NEAREST)
```

### Q3: 缩放后图像变模糊了？

```python
# 原因：放大本身就会模糊（信息不会凭空产生）
# 优化方法：
# 1. 用更好的插值方法
better = cv2.resize(img, (1280, 960), interpolation=cv2.INTER_CUBIC)

# 2. 放大后锐化
kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
sharpened = cv2.filter2D(better, -1, kernel)

# 3. 尽量避免大倍数放大（放大超过2倍质量下降明显）
```

### Q4: 缩放后宽高不是预期值？

```python
# fx/fy 结果是四舍五入的
img = np.zeros((101, 101, 3), dtype=np.uint8)
half = cv2.resize(img, None, fx=0.5, fy=0.5)
print(half.shape)   # 可能是(50,50)或(51,51)，取决于实现

# 需要精确尺寸时，直接指定目标大小：
exact = cv2.resize(img, (50, 50))   # 保证就是 50×50
```

---

## 🎯 总结

本节学习了图像缩放操作：

✅ **基本语法**：`cv2.resize(img, (宽, 高))` — 注意参数是 (W, H)
✅ **比例缩放**：`cv2.resize(img, None, fx=比例, fy=比例)`
✅ **插值方法**：缩小用 `INTER_AREA`，放大用 `INTER_LINEAR`/`INTER_CUBIC`
✅ **掩膜缩放**：必须用 `INTER_NEAREST`，否则会产生中间值
✅ **等比缩放**：计算 `min(target_w/w, target_h/h)` 作为统一比例
✅ **填充方案**：缩放后居中填充到目标尺寸（深度学习常用）
✅ **缩略图**：按长边限制缩放，常用于预览

> 🔑 **核心要点：** `cv2.resize(img, (宽, 高))` 的参数是 **(宽, 高)**，和 `shape` 的 **(高, 宽)** 正好相反——这是最常犯的错误。缩小用 `INTER_AREA`，放大用 `INTER_LINEAR`，掩膜**必须**用 `INTER_NEAREST`。

**下一步：**
👉 [04 - 图像旋转](../04-图像旋转/图像旋转.md)

---

## 📚 参考资料

- [OpenCV 官方文档 - resize](https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)
- [OpenCV 插值方法](https://docs.opencv.org/4.x/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121)

# 图形绘制

> 在图像上画线、画框、标注文字，是计算机视觉中最常见的可视化需求。目标检测要画边界框、关键点检测要画圆点和连线、OCR 要标注文字区域……OpenCV 提供了一整套绘图函数，让你轻松完成这些任务。

---

## 📖 理论部分

### 1. 绘图函数总览

| 函数 | 功能 | 常用场景 |
|------|------|----------|
| `cv2.line()` | 画直线 | 连线、网格 |
| `cv2.arrowedLine()` | 画箭头线 | 光流、方向标注 |
| `cv2.rectangle()` | 画矩形 | 边界框、ROI 标注 |
| `cv2.circle()` | 画圆 | 关键点、标记 |
| `cv2.ellipse()` | 画椭圆/弧 | 人脸椭圆、弧线 |
| `cv2.polylines()` | 画多边形轮廓 | 不规则区域 |
| `cv2.fillPoly()` | 填充多边形 | 掩膜生成 |
| `cv2.putText()` | 添加文字 | 标签、信息显示 |

### 2. 通用参数说明

所有绘图函数都有几个共同参数：

```python
import cv2
import numpy as np

# 通用参数说明：
# img        — 要绘制的目标图像（会被直接修改！）
# color      — 颜色，BGR 格式的元组，如 (255, 0, 0) 是蓝色
# thickness  — 线条粗细（像素），-1 表示填充
# lineType   — 线条类型：
#              cv2.LINE_8  (默认) 8连通线，有锯齿
#              cv2.LINE_4  4连通线
#              cv2.LINE_AA 抗锯齿线，平滑但稍慢
```

```
lineType 对比：

LINE_8 (默认):          LINE_AA (抗锯齿):
  ██                      ▓▓░░
    ██                      ▓▓░░
      ██                      ▓▓░░
        ██                      ▓▓░░
 锯齿明显                  边缘平滑（半透明过渡）
```

> ⚠️ **重要：** 所有绘图函数都是**直接在原图上绘制**（in-place），不会返回新图像！如果不想修改原图，先用 `.copy()` 复制一份。

---

### 3. 各绘图函数详解

#### 3.1 直线：cv2.line()

```python
import cv2
import numpy as np

canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.line(img, pt1, pt2, color, thickness, lineType)
# pt1, pt2 是 (x, y) 坐标（注意是 x 在前！）

cv2.line(canvas, (50, 50), (350, 50), (0, 0, 255), 2)        # 红色横线
cv2.line(canvas, (50, 100), (350, 100), (0, 255, 0), 5)       # 绿色粗线
cv2.line(canvas, (50, 150), (350, 250), (255, 0, 0), 1)       # 蓝色斜线
cv2.line(canvas, (50, 200), (350, 200), (255, 255, 0), 2,
         cv2.LINE_AA)                                           # 抗锯齿线
```

> ⚠️ **坐标格式：** 绘图函数的坐标是 `(x, y)`，和 `img[y, x]` 的顺序**相反**！这是最容易搞混的地方。

```
坐标对比：
  NumPy 索引: img[y, x]     → 行在前，列在后
  绘图函数:   (x, y)        → 列在前，行在后

  记忆方法：绘图用数学坐标 (x, y)，数组用矩阵坐标 [row, col]
```

#### 3.2 箭头线：cv2.arrowedLine()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.arrowedLine(img, pt1, pt2, color, thickness, lineType, tipLength)
# tipLength: 箭头长度占线段长度的比例，默认 0.1

cv2.arrowedLine(canvas, (50, 50), (200, 50), (0, 255, 0), 2)
cv2.arrowedLine(canvas, (50, 100), (200, 100), (0, 0, 255), 2,
                tipLength=0.3)   # 更大的箭头
cv2.arrowedLine(canvas, (50, 150), (200, 200), (255, 255, 0), 2,
                cv2.LINE_AA, tipLength=0.2)
```

#### 3.3 矩形：cv2.rectangle()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.rectangle(img, pt1, pt2, color, thickness)
# pt1: 左上角 (x1, y1)
# pt2: 右下角 (x2, y2)

# 空心矩形
cv2.rectangle(canvas, (50, 50), (200, 150), (0, 255, 0), 2)

# 填充矩形（thickness=-1）
cv2.rectangle(canvas, (250, 50), (380, 150), (0, 0, 255), -1)

# 粗边框
cv2.rectangle(canvas, (50, 180), (380, 270), (255, 255, 0), 4)
```

```
矩形参数示意：

  pt1 (x1,y1)
    ┌──────────────┐
    │              │  thickness=2  → 空心
    │              │  thickness=-1 → 填充
    └──────────────┘
              pt2 (x2,y2)
```

> 💡 **目标检测最常用：** 画边界框就是 `cv2.rectangle(img, (x1,y1), (x2,y2), color, 2)`，几乎每个检测项目都要用到。

#### 3.4 圆：cv2.circle()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.circle(img, center, radius, color, thickness)
# center: 圆心 (x, y)
# radius: 半径（像素）

# 空心圆
cv2.circle(canvas, (100, 150), 50, (0, 255, 0), 2)

# 实心圆
cv2.circle(canvas, (250, 150), 50, (0, 0, 255), -1)

# 小圆点（关键点标注常用）
cv2.circle(canvas, (350, 100), 5, (255, 255, 0), -1)
```

#### 3.5 椭圆：cv2.ellipse()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness)
# center:     中心坐标 (x, y)
# axes:       (长半轴, 短半轴)
# angle:      椭圆整体旋转角度（顺时针）
# startAngle: 绘制起始角度
# endAngle:   绘制结束角度（0~360 = 完整椭圆）

# 完整椭圆
cv2.ellipse(canvas, (200, 150), (100, 50), 0, 0, 360, (0, 255, 0), 2)

# 旋转 45° 的椭圆
cv2.ellipse(canvas, (200, 150), (100, 50), 45, 0, 360, (0, 0, 255), 2)

# 半椭圆（弧）
cv2.ellipse(canvas, (200, 150), (80, 40), 0, 0, 180, (255, 255, 0), 3)
```

```
椭圆参数示意：

          angle=0               angle=45
    ┌──────────────┐      ╲
    │   ╭──────╮   │        ╲  ╭──╮
    │   │      │   │          ╲│  │
    │   ╰──────╯   │           ╰──╯╲
    └──────────────┘                  ╲
  axes=(100,50)           同一椭圆旋转45°

  startAngle=0, endAngle=180 → 只画上半弧
  startAngle=0, endAngle=360 → 完整椭圆
```

#### 3.6 多边形：cv2.polylines() 和 cv2.fillPoly()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# 定义顶点坐标（必须是 int32 类型的数组）
triangle = np.array([[100, 50], [50, 200], [150, 200]], dtype=np.int32)
pentagon = np.array([[300, 50], [250, 120], [270, 200],
                     [330, 200], [350, 120]], dtype=np.int32)

# 画多边形轮廓
# cv2.polylines(img, [pts], isClosed, color, thickness)
# isClosed=True → 首尾相连
cv2.polylines(canvas, [triangle], True, (0, 255, 0), 2)

# 填充多边形
cv2.fillPoly(canvas, [pentagon], (0, 0, 255))

# 多个多边形一起画
shapes = [triangle, pentagon]
cv2.polylines(canvas, shapes, True, (255, 255, 255), 1)
```

> ⚠️ **注意：** `polylines` 的点数组必须是 `np.int32` 类型，而且要用 **列表包裹** `[pts]`，不是直接传 `pts`！

#### 3.7 文字：cv2.putText()

```python
canvas = np.zeros((300, 400, 3), dtype=np.uint8)

# cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType)
# org:       文字左下角坐标 (x, y) — 注意是左下角！
# fontFace:  字体
# fontScale: 字体缩放因子

# 基本文字
cv2.putText(canvas, "Hello OpenCV", (50, 50),
            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)

# 不同字体
fonts = [
    (cv2.FONT_HERSHEY_SIMPLEX,  "SIMPLEX"),
    (cv2.FONT_HERSHEY_PLAIN,    "PLAIN"),
    (cv2.FONT_HERSHEY_DUPLEX,   "DUPLEX"),
    (cv2.FONT_HERSHEY_COMPLEX,  "COMPLEX"),
    (cv2.FONT_HERSHEY_TRIPLEX,  "TRIPLEX"),
]

for i, (font, name) in enumerate(fonts):
    y = 80 + i * 40
    cv2.putText(canvas, name, (50, y), font, 0.8, (255, 255, 255), 1)
```

```
putText 坐标基准：

  org (x, y) 是文字的 左下角 ！

        Hello
  org → •
  (50, 100) 意味着文字底部在 y=100

  获取文字尺寸：
  (w, h), baseline = cv2.getTextSize("Hello", font, scale, thickness)
```

```python
# 获取文字尺寸（用于居中显示）
text = "Centered"
font = cv2.FONT_HERSHEY_SIMPLEX
scale = 1.0
thickness = 2

(text_w, text_h), baseline = cv2.getTextSize(text, font, scale, thickness)
print(f"文字尺寸: {text_w}×{text_h}, 基线偏移: {baseline}")

# 居中绘制
img_h, img_w = canvas.shape[:2]
x = (img_w - text_w) // 2
y = (img_h + text_h) // 2
cv2.putText(canvas, text, (x, y), font, scale, (0, 255, 255), thickness)
```

> ⚠️ **OpenCV 不支持中文！** `cv2.putText()` 只能显示英文和 ASCII 字符。显示中文需要用 PIL/Pillow 库。

---

### 4. 绘图的 in-place 特性

```python
import cv2
import numpy as np

img = np.zeros((200, 300, 3), dtype=np.uint8)

# 绘图函数直接修改原图！
cv2.circle(img, (150, 100), 50, (0, 255, 0), -1)
# img 已经被修改了，不需要 img = cv2.circle(...)

# 如果想保留原图：
original = img.copy()
annotated = img.copy()
cv2.rectangle(annotated, (10, 10), (100, 80), (0, 0, 255), 2)
# original 不受影响
```

---

### 5. 实用技巧

#### 5.1 目标检测标注（带标签的边界框）

```python
def draw_bbox(img, bbox, label, color=(0, 255, 0), thickness=2):
    """画带标签的边界框"""
    x1, y1, x2, y2 = bbox
    cv2.rectangle(img, (x1, y1), (x2, y2), color, thickness)

    # 标签背景
    font = cv2.FONT_HERSHEY_SIMPLEX
    scale = 0.6
    (tw, th), baseline = cv2.getTextSize(label, font, scale, thickness)
    cv2.rectangle(img, (x1, y1 - th - 10), (x1 + tw + 4, y1), color, -1)
    cv2.putText(img, label, (x1 + 2, y1 - 5), font, scale,
                (255, 255, 255), 1, cv2.LINE_AA)
```

#### 5.2 关键点连线（骨架绘制）

```python
def draw_skeleton(img, keypoints, connections, color=(0, 255, 255)):
    """绘制关键点和骨架连线"""
    # 画关键点
    for (x, y) in keypoints:
        cv2.circle(img, (x, y), 4, (0, 0, 255), -1)

    # 画连线
    for (i, j) in connections:
        pt1 = tuple(keypoints[i])
        pt2 = tuple(keypoints[j])
        cv2.line(img, pt1, pt2, color, 2, cv2.LINE_AA)
```

---

## 💻 代码实战

### 实战练习：图形绘制全流程

```python
# ===================================================================
# 实战练习：图形绘制全流程
# 目标：掌握所有基础绘图函数和实用技巧
# ===================================================================

import cv2
import numpy as np

# ---------- 1. 基本图形绘制 ----------
print("=" * 55)
print("🖊️ 第一步：基本图形绘制")
print("=" * 55)

canvas = np.zeros((400, 600, 3), dtype=np.uint8)

# 直线
cv2.line(canvas, (50, 50), (250, 50), (0, 0, 255), 2)
print("  画直线: (50,50)→(250,50), 红色, 粗细2")

# 箭头线
cv2.arrowedLine(canvas, (300, 50), (550, 50), (0, 255, 0), 2, tipLength=0.1)
print("  画箭头: (300,50)→(550,50), 绿色")

# 矩形
cv2.rectangle(canvas, (50, 80), (250, 180), (255, 0, 0), 2)
cv2.rectangle(canvas, (300, 80), (550, 180), (255, 0, 0), -1)
print("  画矩形: 空心 + 填充")

# 圆
cv2.circle(canvas, (150, 250), 50, (0, 255, 255), 2)
cv2.circle(canvas, (400, 250), 50, (0, 255, 255), -1)
print("  画圆: 空心 + 实心")

# 椭圆
cv2.ellipse(canvas, (150, 350), (80, 30), 0, 0, 360, (255, 0, 255), 2)
cv2.ellipse(canvas, (400, 350), (80, 30), 30, 0, 360, (255, 0, 255), 2)
print("  画椭圆: 水平 + 旋转30°")

print(f"  画布尺寸: {canvas.shape}")

# ---------- 2. 多边形 ----------
print("\n" + "=" * 55)
print("🔷 第二步：多边形绘制")
print("=" * 55)

canvas2 = np.zeros((300, 400, 3), dtype=np.uint8)

# 三角形
tri = np.array([[100, 30], [30, 200], [170, 200]], dtype=np.int32)
cv2.polylines(canvas2, [tri], True, (0, 255, 0), 2)
print(f"  三角形顶点: {tri.tolist()}")

# 填充五边形
penta = np.array([[300, 30], [250, 100], [270, 190],
                  [330, 190], [350, 100]], dtype=np.int32)
cv2.fillPoly(canvas2, [penta], (0, 0, 255))
print(f"  填充五边形顶点数: {len(penta)}")

# 星形（复杂多边形）
def make_star(cx, cy, r_outer, r_inner, n=5):
    """生成星形顶点"""
    pts = []
    for i in range(n * 2):
        angle = np.pi / 2 + i * np.pi / n
        r = r_outer if i % 2 == 0 else r_inner
        x = int(cx + r * np.cos(angle))
        y = int(cy - r * np.sin(angle))
        pts.append([x, y])
    return np.array(pts, dtype=np.int32)

star = make_star(200, 250, 40, 15)
cv2.fillPoly(canvas2, [star], (0, 255, 255))
print(f"  星形顶点数: {len(star)}")

# ---------- 3. 文字绘制 ----------
print("\n" + "=" * 55)
print("📝 第三步：文字绘制")
print("=" * 55)

canvas3 = np.zeros((350, 500, 3), dtype=np.uint8)

fonts = [
    (cv2.FONT_HERSHEY_SIMPLEX,  "SIMPLEX"),
    (cv2.FONT_HERSHEY_PLAIN,    "PLAIN"),
    (cv2.FONT_HERSHEY_DUPLEX,   "DUPLEX"),
    (cv2.FONT_HERSHEY_COMPLEX,  "COMPLEX"),
    (cv2.FONT_HERSHEY_TRIPLEX,  "TRIPLEX"),
    (cv2.FONT_HERSHEY_SCRIPT_SIMPLEX, "SCRIPT"),
]

for i, (font, name) in enumerate(fonts):
    y = 40 + i * 50
    cv2.putText(canvas3, f"{name}: Hello!", (30, y),
                font, 0.8, (255, 255, 255), 1, cv2.LINE_AA)
    print(f"  字体 {name}: y={y}")

# 文字尺寸计算
text = "OpenCV"
font = cv2.FONT_HERSHEY_SIMPLEX
scale = 2.0
thick = 3
(tw, th), baseline = cv2.getTextSize(text, font, scale, thick)
print(f"\n  '{text}' 尺寸: {tw}×{th}, 基线: {baseline}")

# ---------- 4. 居中文字 ----------
print("\n" + "=" * 55)
print("🎯 第四步：文字居中")
print("=" * 55)

canvas4 = np.full((200, 400, 3), 50, dtype=np.uint8)
text = "Centered!"
font = cv2.FONT_HERSHEY_SIMPLEX
scale = 1.5
thick = 2

(tw, th), baseline = cv2.getTextSize(text, font, scale, thick)
h, w = canvas4.shape[:2]
x = (w - tw) // 2
y = (h + th) // 2

cv2.putText(canvas4, text, (x, y), font, scale, (0, 255, 0), thick,
            cv2.LINE_AA)
print(f"  画布: {w}×{h}")
print(f"  文字: {tw}×{th}")
print(f"  位置: ({x}, {y})")

# ---------- 5. 目标检测标注 ----------
print("\n" + "=" * 55)
print("📦 第五步：目标检测标注")
print("=" * 55)

scene = np.random.randint(100, 180, (400, 600, 3), dtype=np.uint8)

detections = [
    {"class": "person", "conf": 0.95, "bbox": [50, 30, 200, 380],
     "color": (0, 255, 0)},
    {"class": "car",    "conf": 0.87, "bbox": [300, 200, 550, 370],
     "color": (255, 0, 0)},
    {"class": "dog",    "conf": 0.72, "bbox": [220, 250, 350, 380],
     "color": (0, 255, 255)},
]

for det in detections:
    x1, y1, x2, y2 = det["bbox"]
    color = det["color"]
    label = f"{det['class']} {det['conf']:.2f}"

    # 画框
    cv2.rectangle(scene, (x1, y1), (x2, y2), color, 2)

    # 标签背景
    font = cv2.FONT_HERSHEY_SIMPLEX
    (tw, th), _ = cv2.getTextSize(label, font, 0.6, 1)
    cv2.rectangle(scene, (x1, y1 - th - 8), (x1 + tw + 4, y1), color, -1)
    cv2.putText(scene, label, (x1 + 2, y1 - 4), font, 0.6,
                (255, 255, 255), 1, cv2.LINE_AA)

    print(f"  {det['class']:>6s} ({det['conf']:.2f}): "
          f"bbox=[{x1},{y1},{x2},{y2}], 标签宽={tw}")

# ---------- 6. 关键点与骨架 ----------
print("\n" + "=" * 55)
print("🦴 第六步：关键点与骨架")
print("=" * 55)

canvas6 = np.zeros((400, 300, 3), dtype=np.uint8)

# 模拟人体关键点 (x, y)
keypoints = [
    (150, 40),   # 0: 头
    (150, 100),  # 1: 颈
    (100, 100),  # 2: 左肩
    (200, 100),  # 3: 右肩
    (70, 180),   # 4: 左肘
    (230, 180),  # 5: 右肘
    (50, 260),   # 6: 左手
    (250, 260),  # 7: 右手
    (120, 200),  # 8: 左髋
    (180, 200),  # 9: 右髋
    (110, 300),  # 10: 左膝
    (190, 300),  # 11: 右膝
    (100, 370),  # 12: 左脚
    (200, 370),  # 13: 右脚
]

connections = [
    (0, 1), (1, 2), (1, 3),    # 头-颈-肩
    (2, 4), (4, 6),             # 左臂
    (3, 5), (5, 7),             # 右臂
    (1, 8), (1, 9),             # 躯干
    (8, 10), (10, 12),          # 左腿
    (9, 11), (11, 13),          # 右腿
]

# 画连线
for (i, j) in connections:
    cv2.line(canvas6, keypoints[i], keypoints[j], (0, 255, 255), 2,
             cv2.LINE_AA)

# 画关键点
for idx, (x, y) in enumerate(keypoints):
    cv2.circle(canvas6, (x, y), 5, (0, 0, 255), -1)

print(f"  关键点数: {len(keypoints)}")
print(f"  连接数:   {len(connections)}")

# ---------- 7. lineType 对比 ----------
print("\n" + "=" * 55)
print("🔍 第七步：lineType 对比")
print("=" * 55)

canvas7 = np.zeros((200, 400, 3), dtype=np.uint8)

# LINE_8 vs LINE_AA
cv2.line(canvas7, (50, 30), (200, 100), (0, 255, 0), 2, cv2.LINE_8)
cv2.line(canvas7, (50, 80), (200, 150), (0, 255, 0), 2, cv2.LINE_AA)

cv2.putText(canvas7, "LINE_8", (210, 70), cv2.FONT_HERSHEY_SIMPLEX,
            0.5, (200, 200, 200), 1)
cv2.putText(canvas7, "LINE_AA", (210, 130), cv2.FONT_HERSHEY_SIMPLEX,
            0.5, (200, 200, 200), 1)

# 抗锯齿效果统计
line8_region = canvas7[20:110, 40:210]
lineaa_region = canvas7[70:160, 40:210]
unique_8 = len(np.unique(line8_region.reshape(-1, 3), axis=0))
unique_aa = len(np.unique(lineaa_region.reshape(-1, 3), axis=0))
print(f"  LINE_8  唯一颜色数: {unique_8}")
print(f"  LINE_AA 唯一颜色数: {unique_aa}")
print("  → LINE_AA 有更多中间色（抗锯齿过渡）")

# ---------- 8. in-place 验证 ----------
print("\n" + "=" * 55)
print("⚠️ 第八步：in-place 特性验证")
print("=" * 55)

img = np.zeros((100, 100, 3), dtype=np.uint8)
original = img.copy()

cv2.circle(img, (50, 50), 30, (0, 255, 0), -1)

modified = not np.array_equal(img, original)
print(f"  绘图后原图被修改? {modified}")
print(f"  原图保存副本不变? {np.array_equal(original, np.zeros((100,100,3), dtype=np.uint8))}")

print("\n✅ 图形绘制练习完成！")
```

**运行输出示例：**

```
=======================================================
🖊️ 第一步：基本图形绘制
=======================================================
  画直线: (50,50)→(250,50), 红色, 粗细2
  画箭头: (300,50)→(550,50), 绿色
  画矩形: 空心 + 填充
  画圆: 空心 + 实心
  画椭圆: 水平 + 旋转30°
  画布尺寸: (400, 600, 3)

=======================================================
🔷 第二步：多边形绘制
=======================================================
  三角形顶点: [[100, 30], [30, 200], [170, 200]]
  填充五边形顶点数: 5
  星形顶点数: 10

=======================================================
📝 第三步：文字绘制
=======================================================
  字体 SIMPLEX: y=40
  字体 PLAIN: y=90
  字体 DUPLEX: y=140
  字体 COMPLEX: y=190
  字体 TRIPLEX: y=240
  字体 SCRIPT: y=290

  'OpenCV' 尺寸: 220×46, 基线: 22

=======================================================
📦 第五步：目标检测标注
=======================================================
  person (0.95): bbox=[50,30,200,380], 标签宽=123
     car (0.87): bbox=[300,200,550,370], 标签宽=97
     dog (0.72): bbox=[220,250,350,380], 标签宽=97

=======================================================
🦴 第六步：关键点与骨架
=======================================================
  关键点数: 14
  连接数: 13

=======================================================
⚠️ 第八步：in-place 特性验证
=======================================================
  绘图后原图被修改? True
  原图保存副本不变? True
```

---

## 🚨 常见问题与易错点

### Q1: 绘图坐标和数组索引的顺序？

```python
img = np.zeros((300, 400, 3), dtype=np.uint8)

# 数组索引：img[y, x] — 行在前，列在后
img[100, 200] = [0, 0, 255]

# 绘图函数：(x, y) — 列在前，行在后
cv2.circle(img, (200, 100), 5, (0, 255, 0), -1)

# 两个操作的位置是一样的！只是写法相反
# 记：数组用 [row, col]，绘图用 (x, y)
```

### Q2: 绘图函数没有返回值？

```python
canvas = np.zeros((200, 300, 3), dtype=np.uint8)

# ❌ 常见错误：以为需要接收返回值
# result = cv2.rectangle(canvas, (10,10), (100,100), (0,255,0), 2)
# result 其实就是 canvas 本身（同一个对象）

# ✅ 直接调用就行
cv2.rectangle(canvas, (10, 10), (100, 100), (0, 255, 0), 2)
# canvas 已经被修改了
```

### Q3: polylines 报错？

```python
# ❌ 常见错误
pts = [[100, 50], [50, 200], [150, 200]]
# cv2.polylines(img, pts, True, (0,255,0), 2)   # 报错！

# ✅ 正确：必须是 np.int32 数组，且用列表包裹
pts = np.array([[100, 50], [50, 200], [150, 200]], dtype=np.int32)
cv2.polylines(img, [pts], True, (0, 255, 0), 2)
#                  ↑ 注意这个列表包裹！
```

### Q4: putText 显示中文乱码？

```python
# OpenCV 不支持中文，需要用 PIL
# from PIL import Image, ImageDraw, ImageFont

# PIL 方案（仅示意）：
# pil_img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
# draw = ImageDraw.Draw(pil_img)
# font = ImageFont.truetype("simhei.ttf", 30)
# draw.text((x, y), "中文文字", font=font, fill=(255, 0, 0))
# img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
```

---

## 🎯 总结

本节学习了 OpenCV 图形绘制：

✅ **直线**：`cv2.line(img, pt1, pt2, color, thickness)`
✅ **箭头**：`cv2.arrowedLine(img, pt1, pt2, color, thickness, tipLength)`
✅ **矩形**：`cv2.rectangle(img, pt1, pt2, color, thickness)` — 目标检测必备
✅ **圆**：`cv2.circle(img, center, radius, color, thickness)` — 关键点标注
✅ **椭圆**：`cv2.ellipse(img, center, axes, angle, startAngle, endAngle, color)`
✅ **多边形**：`cv2.polylines()` 画轮廓，`cv2.fillPoly()` 填充
✅ **文字**：`cv2.putText()` — 坐标是左下角，不支持中文
✅ **文字尺寸**：`cv2.getTextSize()` — 用于居中和标签背景
✅ **in-place**：所有绘图函数直接修改原图，保留原图请先 `.copy()`
✅ **抗锯齿**：`cv2.LINE_AA` 线条更平滑
✅ **thickness=-1**：填充模式（矩形、圆、椭圆通用）

> 🔑 **核心要点：** 绘图坐标是 `(x, y)` 而数组索引是 `[y, x]`——顺序相反，这是最大的坑。所有绘图函数都是 in-place 操作。`thickness=-1` 表示填充。`cv2.LINE_AA` 获得抗锯齿效果。实战中最常用的是 `rectangle`（检测框）+ `putText`（标签）+ `circle`（关键点）。

**下一步：**
👉 [第06章 - 颜色空间](../../第06章-颜色空间/颜色空间.md)

---

## 📚 参考资料

- [OpenCV 官方文档 - 绘图函数](https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html)
- [OpenCV-Python 绘图教程](https://docs.opencv.org/4.x/dc/da5/tutorial_py_drawing_functions.html)

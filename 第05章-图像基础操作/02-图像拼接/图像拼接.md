# 图像拼接

> 将多张图像组合在一起显示，是图像处理中非常实用的操作。无论是制作对比图、拼接全景照片，还是将多个处理结果并排展示，都需要用到图像拼接。

---

## 📖 理论部分

### 1. 基本拼接方法

#### 1.1 NumPy 拼接函数

```python
import cv2
import numpy as np

# 创建测试图像
img_a = np.full((200, 300, 3), [255, 0, 0], dtype=np.uint8)   # 蓝色
img_b = np.full((200, 300, 3), [0, 255, 0], dtype=np.uint8)   # 绿色
img_c = np.full((200, 300, 3), [0, 0, 255], dtype=np.uint8)   # 红色

# 水平拼接（左右并排）
h_concat = np.hstack([img_a, img_b, img_c])
print(f"水平拼接: {h_concat.shape}")   # (200, 900, 3)

# 垂直拼接（上下堆叠）
v_concat = np.vstack([img_a, img_b, img_c])
print(f"垂直拼接: {v_concat.shape}")   # (600, 300, 3)

# np.concatenate（更通用）
h2 = np.concatenate([img_a, img_b], axis=1)   # axis=1 → 水平
v2 = np.concatenate([img_a, img_b], axis=0)   # axis=0 → 垂直
```

```
拼接方向示意：

水平拼接 np.hstack / axis=1：
┌────────┐┌────────┐┌────────┐
│  img_a  ││  img_b  ││  img_c  │   → 宽度相加，高度不变
│ (200×300)│(200×300)│(200×300)│
└────────┘└────────┘└────────┘
结果: (200, 900, 3)

垂直拼接 np.vstack / axis=0：
┌────────┐
│  img_a  │
│(200×300)│   → 高度相加，宽度不变
├────────┤
│  img_b  │
│(200×300)│
├────────┤
│  img_c  │
│(200×300)│
└────────┘
结果: (600, 300, 3)
```

#### 1.2 OpenCV 拼接函数

```python
# OpenCV 也有拼接函数
h_concat = cv2.hconcat([img_a, img_b, img_c])   # 水平
v_concat = cv2.vconcat([img_a, img_b, img_c])   # 垂直

# 功能和 NumPy 一样，选哪个都行
```

> 💡 **NumPy vs OpenCV 拼接：** 功能完全相同，推荐用 NumPy（`hstack`/`vstack`），因为更简洁、通用性更强。

---

### 2. 拼接的前提条件

#### 2.1 尺寸要求

```python
# ❌ 水平拼接时，高度必须相同！
img1 = np.zeros((200, 300, 3), dtype=np.uint8)
img2 = np.zeros((300, 300, 3), dtype=np.uint8)   # 高度不同
# np.hstack([img1, img2])   # 报错！高度不匹配

# ❌ 垂直拼接时，宽度必须相同！
img3 = np.zeros((200, 300, 3), dtype=np.uint8)
img4 = np.zeros((200, 400, 3), dtype=np.uint8)   # 宽度不同
# np.vstack([img3, img4])   # 报错！宽度不匹配

# ✅ 解决方法：先 resize 到相同尺寸
img2_resized = cv2.resize(img2, (300, 200))   # 调整为 (宽300, 高200)
result = np.hstack([img1, img2_resized])       # 现在可以了
```

```
拼接尺寸规则：

水平拼接要求：所有图像的 高度(H) 必须相同
┌────┐┌────┐    ✅ H相同
│ H1 ││ H2 │
└────┘└────┘

┌────┐┌──────┐  ❌ H不同
│    ││      │
└────┘│      │
      └──────┘

垂直拼接要求：所有图像的 宽度(W) 必须相同
┌────────┐  ✅ W相同    ┌────────┐  ❌ W不同
│   W1   │              │   W1   │
├────────┤              ├──────────┤
│   W2   │              │    W2    │
└────────┘              └──────────┘
```

#### 2.2 通道数和类型也要匹配

```python
# ❌ 通道数不同
gray = np.zeros((200, 300), dtype=np.uint8)         # 2维
color = np.zeros((200, 300, 3), dtype=np.uint8)     # 3维
# np.hstack([gray, color])   # 报错！维度不匹配

# ✅ 先转换通道
gray_3ch = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)   # 灰度转3通道
result = np.hstack([gray_3ch, color])

# ❌ 数据类型不同
img_u8 = np.zeros((200, 300, 3), dtype=np.uint8)
img_f32 = np.zeros((200, 300, 3), dtype=np.float32)
# np.hstack([img_u8, img_f32])   # 类型提升，可能不是你想要的

# ✅ 统一类型
img_f32_u8 = (img_f32 * 255).astype(np.uint8)
result = np.hstack([img_u8, img_f32_u8])
```

---

### 3. 实用拼接技巧

#### 3.1 智能拼接（自动调整尺寸）

```python
def safe_hconcat(images, target_height=None):
    """安全的水平拼接：自动统一高度"""
    if target_height is None:
        target_height = max(img.shape[0] for img in images)

    resized = []
    for img in images:
        h, w = img.shape[:2]
        if h != target_height:
            scale = target_height / h
            new_w = int(w * scale)
            img = cv2.resize(img, (new_w, target_height))
        # 确保是3通道
        if img.ndim == 2:
            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        resized.append(img)

    return np.hstack(resized)

def safe_vconcat(images, target_width=None):
    """安全的垂直拼接：自动统一宽度"""
    if target_width is None:
        target_width = max(img.shape[1] for img in images)

    resized = []
    for img in images:
        h, w = img.shape[:2]
        if w != target_width:
            scale = target_width / w
            new_h = int(h * scale)
            img = cv2.resize(img, (target_width, new_h))
        if img.ndim == 2:
            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        resized.append(img)

    return np.vstack(resized)
```

#### 3.2 网格拼接（多行多列）

```python
def make_grid(images, ncols=4, padding=5, bg_color=(50, 50, 50)):
    """将多张图像排列成网格"""
    n = len(images)
    nrows = (n + ncols - 1) // ncols   # 向上取整

    # 统一尺寸
    target_h = max(img.shape[0] for img in images)
    target_w = max(img.shape[1] for img in images)

    # 创建画布
    canvas_h = nrows * (target_h + padding) + padding
    canvas_w = ncols * (target_w + padding) + padding
    canvas = np.full((canvas_h, canvas_w, 3), bg_color, dtype=np.uint8)

    for idx, img in enumerate(images):
        row = idx // ncols
        col = idx % ncols

        # resize
        resized = cv2.resize(img, (target_w, target_h))
        if resized.ndim == 2:
            resized = cv2.cvtColor(resized, cv2.COLOR_GRAY2BGR)

        y = padding + row * (target_h + padding)
        x = padding + col * (target_w + padding)
        canvas[y:y+target_h, x:x+target_w] = resized

    return canvas
```

#### 3.3 添加标题/分隔线

```python
def add_title(img, title, font_scale=0.8, thickness=2):
    """在图像顶部添加标题栏"""
    h, w = img.shape[:2]
    bar_height = 40
    bar = np.zeros((bar_height, w, 3), dtype=np.uint8)

    # 居中文字
    text_size = cv2.getTextSize(title, cv2.FONT_HERSHEY_SIMPLEX,
                                 font_scale, thickness)[0]
    x = (w - text_size[0]) // 2
    y = (bar_height + text_size[1]) // 2
    cv2.putText(bar, title, (x, y), cv2.FONT_HERSHEY_SIMPLEX,
                font_scale, (255, 255, 255), thickness)

    return np.vstack([bar, img])

def add_separator(img, direction='h', width=3, color=(200, 200, 200)):
    """在图像中间添加分隔线"""
    result = img.copy()
    h, w = result.shape[:2]
    if direction == 'h':  # 水平线
        y = h // 2
        result[y:y+width, :] = color
    else:  # 垂直线
        x = w // 2
        result[:, x:x+width] = color
    return result
```

---

## 💻 代码实战

### 实战练习：图像拼接全流程

```python
# ===================================================================
# 实战练习：图像拼接全流程
# 目标：掌握各种拼接场景和技巧
# ===================================================================

import cv2
import numpy as np

# ---------- 1. 创建测试图像 ----------
print("=" * 55)
print("🎨 第一步：创建测试图像")
print("=" * 55)

# 不同颜色的图像
colors = {
    "红": ([0, 0, 255], (200, 300)),
    "绿": ([0, 255, 0], (200, 300)),
    "蓝": ([255, 0, 0], (200, 300)),
    "黄": ([0, 255, 255], (200, 300)),
}

images = {}
for name, (color, size) in colors.items():
    img = np.full((size[0], size[1], 3), color, dtype=np.uint8)
    # 加文字标记
    cv2.putText(img, name, (120, 120), cv2.FONT_HERSHEY_SIMPLEX,
                2, (255, 255, 255), 3)
    images[name] = img
    print(f"  {name}色图像: {img.shape}")

# ---------- 2. 基本拼接 ----------
print("\n" + "=" * 55)
print("🔗 第二步：基本拼接")
print("=" * 55)

# 水平
h_result = np.hstack([images["红"], images["绿"], images["蓝"]])
print(f"  水平拼接(3张): {h_result.shape}")

# 垂直
v_result = np.vstack([images["红"], images["绿"]])
print(f"  垂直拼接(2张): {v_result.shape}")

# OpenCV 方式
h_cv = cv2.hconcat([images["红"], images["绿"]])
v_cv = cv2.vconcat([images["红"], images["绿"]])
print(f"  OpenCV 水平: {h_cv.shape}")
print(f"  OpenCV 垂直: {v_cv.shape}")

# ---------- 3. 不同尺寸拼接 ----------
print("\n" + "=" * 55)
print("📐 第三步：不同尺寸的安全拼接")
print("=" * 55)

small = np.full((100, 150, 3), [0, 0, 255], dtype=np.uint8)
medium = np.full((200, 300, 3), [0, 255, 0], dtype=np.uint8)
large = np.full((300, 450, 3), [255, 0, 0], dtype=np.uint8)

print(f"  小图: {small.shape}")
print(f"  中图: {medium.shape}")
print(f"  大图: {large.shape}")

# 统一高度后水平拼接
target_h = 200
imgs_resized = []
for img in [small, medium, large]:
    h, w = img.shape[:2]
    scale = target_h / h
    new_w = int(w * scale)
    imgs_resized.append(cv2.resize(img, (new_w, target_h)))

safe_h = np.hstack(imgs_resized)
print(f"  统一高度后水平拼接: {safe_h.shape}")

# ---------- 4. 灰度与彩色混合拼接 ----------
print("\n" + "=" * 55)
print("🎨 第四步：灰度与彩色混合拼接")
print("=" * 55)

color_img = np.random.randint(0, 256, (200, 300, 3), dtype=np.uint8)
gray_img = np.random.randint(0, 256, (200, 300), dtype=np.uint8)

print(f"  彩色: {color_img.shape} (ndim={color_img.ndim})")
print(f"  灰度: {gray_img.shape} (ndim={gray_img.ndim})")

# 灰度转3通道后拼接
gray_3ch = cv2.cvtColor(gray_img, cv2.COLOR_GRAY2BGR)
mixed = np.hstack([color_img, gray_3ch])
print(f"  混合拼接: {mixed.shape}")

# ---------- 5. 网格排列 ----------
print("\n" + "=" * 55)
print("📊 第五步：网格排列")
print("=" * 55)

# 创建8张小图
grid_imgs = []
for i in range(8):
    color = np.random.randint(50, 200, 3).tolist()
    img = np.full((100, 150, 3), color, dtype=np.uint8)
    cv2.putText(img, str(i+1), (55, 65), cv2.FONT_HERSHEY_SIMPLEX,
                1.5, (255, 255, 255), 2)
    grid_imgs.append(img)

# 手动排成 2×4 网格
row1 = np.hstack(grid_imgs[:4])
row2 = np.hstack(grid_imgs[4:])
grid = np.vstack([row1, row2])
print(f"  8张图排成2×4网格: {grid.shape}")

# ---------- 6. 对比图制作 ----------
print("\n" + "=" * 55)
print("🔍 第六步：对比图制作")
print("=" * 55)

# 模拟原图和处理后的对比
original = np.random.randint(50, 200, (200, 300, 3), dtype=np.uint8)
processed = cv2.GaussianBlur(original, (15, 15), 0)

# 添加分隔线
separator = np.full((200, 3, 3), [200, 200, 200], dtype=np.uint8)
comparison = np.hstack([original, separator, processed])
print(f"  对比图（原图 | 处理后）: {comparison.shape}")

# 添加标题栏
title_height = 35
title_bar = np.zeros((title_height, comparison.shape[1], 3), dtype=np.uint8)
cv2.putText(title_bar, "Original", (50, 25),
            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 1)
cv2.putText(title_bar, "Blurred", (355, 25),
            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 1)

final = np.vstack([title_bar, comparison])
print(f"  带标题的对比图: {final.shape}")

# ---------- 7. 拼接性能 ----------
print("\n" + "=" * 55)
print("⚡ 第七步：拼接方式性能对比")
print("=" * 55)

import time

imgs = [np.random.randint(0, 256, (200, 300, 3), dtype=np.uint8)
        for _ in range(10)]

# NumPy hstack
t0 = time.time()
for _ in range(1000):
    np.hstack(imgs)
t_np = time.time() - t0

# OpenCV hconcat
t0 = time.time()
for _ in range(1000):
    cv2.hconcat(imgs)
t_cv = time.time() - t0

# concatenate
t0 = time.time()
for _ in range(1000):
    np.concatenate(imgs, axis=1)
t_cat = time.time() - t0

print(f"  1000次拼接10张图:")
print(f"    np.hstack:       {t_np:.3f}s")
print(f"    cv2.hconcat:     {t_cv:.3f}s")
print(f"    np.concatenate:  {t_cat:.3f}s")

print("\n✅ 图像拼接练习完成！")
```

**运行输出示例：**

```
=======================================================
🎨 第一步：创建测试图像
=======================================================
  红色图像: (200, 300, 3)
  绿色图像: (200, 300, 3)
  蓝色图像: (200, 300, 3)
  黄色图像: (200, 300, 3)

=======================================================
🔗 第二步：基本拼接
=======================================================
  水平拼接(3张): (200, 900, 3)
  垂直拼接(2张): (400, 300, 3)

=======================================================
📊 第五步：网格排列
=======================================================
  8张图排成2×4网格: (200, 600, 3)

=======================================================
🔍 第六步：对比图制作
=======================================================
  对比图（原图 | 处理后）: (200, 603, 3)
  带标题的对比图: (235, 603, 3)
```

---

## 🚨 常见问题与易错点

### Q1: hstack 报错 "all input arrays must have same shape"？

```python
# 原因：高度不同
img1 = np.zeros((200, 300, 3), dtype=np.uint8)
img2 = np.zeros((250, 300, 3), dtype=np.uint8)

# ❌ 高度不同
# np.hstack([img1, img2])

# ✅ 先统一高度
img2_resized = cv2.resize(img2, (300, 200))
result = np.hstack([img1, img2_resized])
```

### Q2: 灰度图和彩色图无法拼接？

```python
gray = np.zeros((200, 300), dtype=np.uint8)
color = np.zeros((200, 300, 3), dtype=np.uint8)

# ❌ 维度不同 (2D vs 3D)
# np.hstack([gray, color])

# ✅ 灰度转3通道
gray_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
result = np.hstack([gray_bgr, color])
```

### Q3: hstack 和 vstack 记不住方向？

```python
# 记忆方法：
# h = horizontal = 水平 → 左右排列 → 宽度增加
# v = vertical   = 垂直 → 上下堆叠 → 高度增加

# 或者记 axis：
# axis=0 → 沿第0维(行)拼接 → 行数增加 → 垂直
# axis=1 → 沿第1维(列)拼接 → 列数增加 → 水平
```

### Q4: 拼接大量图像时内存不足？

```python
# 大量大图拼接可能占用很多内存
# 解决方法：先缩小再拼接

def preview_grid(images, max_size=200, ncols=4):
    """创建缩略图网格"""
    thumbnails = []
    for img in images:
        h, w = img.shape[:2]
        scale = max_size / max(h, w)
        thumb = cv2.resize(img, (int(w*scale), int(h*scale)))
        thumbnails.append(thumb)
    # ... 然后拼接缩略图
```

---

## 🎯 总结

本节学习了图像拼接操作：

✅ **水平拼接**：`np.hstack()` 或 `cv2.hconcat()` — 要求高度相同
✅ **垂直拼接**：`np.vstack()` 或 `cv2.vconcat()` — 要求宽度相同
✅ **通用拼接**：`np.concatenate(axis=0/1)` — 灵活指定方向
✅ **拼接条件**：高度/宽度必须匹配，通道数和dtype也要一致
✅ **安全拼接**：先 resize 统一尺寸，灰度图先转3通道
✅ **网格排列**：先按行 hstack，再 vstack 合并所有行
✅ **对比图**：加分隔线和标题栏，方便展示处理效果

> 🔑 **核心要点：** 拼接的前提是**尺寸匹配**——水平拼接要求高度相同，垂直拼接要求宽度相同。不匹配时先用 `cv2.resize()` 统一。灰度图和彩色图拼接前，要把灰度图转成3通道。

**下一步：**
👉 [03 - 图像缩放](../03-图像缩放/图像缩放.md)

---

## 📚 参考资料

- [NumPy 数组拼接](https://numpy.org/doc/stable/reference/routines.array-manipulation.html)
- [OpenCV hconcat/vconcat](https://docs.opencv.org/4.x/d2/de8/group__core__array.html)

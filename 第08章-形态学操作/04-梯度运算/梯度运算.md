# 梯度运算

> 形态学梯度（Morphological Gradient）是一种用于提取物体边缘的技术。它通过计算膨胀和腐蚀之间的差异来获得边缘，效果类似于边缘检测，但更适合二值图像处理。

---

## 📖 理论部分

### 1. 形态学梯度的定义

#### 1.1 基本梯度

形态学梯度 = **膨胀 - 腐蚀**

```
形态学梯度的原理：

  原始图像        膨胀          腐蚀         梯度（膨胀-腐蚀）
  ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
  │        │    │▓▓▓▓▓▓▓▓│    │        │    │▓▓▓▓▓▓▓▓│
  │ ▓▓▓▓▓▓ │    │▓▓▓▓▓▓▓▓│    │  ▓▓▓▓  │    │▓▓    ▓▓│
  │ ▓▓▓▓▓▓ │ →  │▓▓▓▓▓▓▓▓│  - │  ▓▓▓▓  │  = │▓▓    ▓▓│
  │ ▓▓▓▓▓▓ │    │▓▓▓▓▓▓▓▓│    │  ▓▓▓▓  │    │▓▓    ▓▓│
  │        │    │▓▓▓▓▓▓▓▓│    │        │    │▓▓▓▓▓▓▓▓│
  └────────┘    └────────┘    └────────┘    └────────┘

  数学表示：Gradient(A, B) = Dilate(A, B) - Erode(A, B)

  结果解读：
  • 膨胀后的区域减去腐蚀后的区域
  • 剩下的就是边缘区域
  • 边缘宽度取决于结构元素的大小
```

#### 1.2 为什么能提取边缘？

```
边缘提取原理解析：

  想象一个物体：

  膨胀前后的变化：
  ┌─────────────────┐
  │     膨胀区域     │  ← 膨胀向外扩展一圈
  │  ┌───────────┐  │
  │  │           │  │
  │  │   原始    │  │
  │  │   物体    │  │
  │  │           │  │
  │  └───────────┘  │
  └─────────────────┘

  腐蚀前后的变化：
  ┌───────────────┐
  │               │  ← 原始边界
  │  ┌─────────┐  │
  │  │         │  │
  │  │ 腐蚀后  │  │  ← 腐蚀向内收缩一圈
  │  │         │  │
  │  └─────────┘  │
  └───────────────┘

  膨胀 - 腐蚀 = 边缘环带
  ┌─────────────────┐
  │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
  │ ▓             ▓ │
  │ ▓             ▓ │  ← 这就是边缘！
  │ ▓             ▓ │
  │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
  └─────────────────┘
```

---

### 2. 梯度的三种类型

#### 2.1 基本梯度（标准梯度）

```
基本梯度 = 膨胀 - 腐蚀

  特点：
  • 边缘包含物体的内侧和外侧
  • 边缘宽度 = 结构元素大小
  • 最常用的梯度类型

  示意图：
  ┌──────────────┐
  │  外部边缘    │
  │ ╔══════════╗ │
  │ ║  内部    ║ │
  │ ║  边缘    ║ │
  │ ╚══════════╝ │
  └──────────────┘
```

#### 2.2 内梯度（Internal Gradient）

```
内梯度 = 原图 - 腐蚀

  特点：
  • 只保留物体内侧的边缘
  • 边缘完全在原始物体内部
  • 不会超出原始边界

  示意图：
  ┌────────────┐
  │ ╔════════╗ │
  │ ║▓▓▓▓▓▓▓▓║ │ ← 边缘在物体内部
  │ ║▓      ▓║ │
  │ ║▓▓▓▓▓▓▓▓║ │
  │ ╚════════╝ │
  └────────────┘
    原始边界
```

#### 2.3 外梯度（External Gradient）

```
外梯度 = 膨胀 - 原图

  特点：
  • 只保留物体外侧的边缘
  • 边缘完全在原始物体外部
  • 用于标注物体轮廓

  示意图：
  ┌──────────────┐
  │ ▓▓▓▓▓▓▓▓▓▓▓▓ │ ← 边缘在物体外部
  │ ▓╔════════╗▓ │
  │ ▓║        ║▓ │
  │ ▓║        ║▓ │
  │ ▓╚════════╝▓ │
  │ ▓▓▓▓▓▓▓▓▓▓▓▓ │
  └──────────────┘
```

#### 2.4 三种梯度对比

```
三种梯度对比：

  原始图像         基本梯度        内梯度         外梯度
  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
  │          │   │ ████████ │   │          │   │ ████████ │
  │  ██████  │   │ █      █ │   │  ██████  │   │ █      █ │
  │  ██████  │ → │ █      █ │   │  █    █  │   │ █      █ │
  │  ██████  │   │ █      █ │   │  ██████  │   │ █      █ │
  │          │   │ ████████ │   │          │   │ ████████ │
  └──────────┘   └──────────┘   └──────────┘   └──────────┘

  ┌──────────────┬────────────────┬────────────────────────┐
  │    类型      │     计算公式   │        适用场景        │
  ├──────────────┼────────────────┼────────────────────────┤
  │  基本梯度    │  膨胀 - 腐蚀   │  通用边缘提取          │
  ├──────────────┼────────────────┼────────────────────────┤
  │  内梯度      │  原图 - 腐蚀   │  不想扩展边界时使用    │
  ├──────────────┼────────────────┼────────────────────────┤
  │  外梯度      │  膨胀 - 原图   │  需要边缘在外部时使用  │
  └──────────────┴────────────────┴────────────────────────┘
```

---

### 3. 形态学梯度 vs 其他边缘检测

```
形态学梯度与其他边缘检测方法对比：

  ┌─────────────────┬─────────────────────────────────────┐
  │     方法        │            特点                     │
  ├─────────────────┼─────────────────────────────────────┤
  │  形态学梯度     │ • 适合二值图像                      │
  │                 │ • 边缘宽度可控（由结构元素决定）    │
  │                 │ • 对噪声不敏感                      │
  │                 │ • 计算简单快速                      │
  ├─────────────────┼─────────────────────────────────────┤
  │  Sobel/Prewitt  │ • 适合灰度图像                      │
  │                 │ • 可以检测边缘方向                  │
  │                 │ • 对噪声敏感                        │
  ├─────────────────┼─────────────────────────────────────┤
  │  Canny          │ • 效果最好的边缘检测                │
  │                 │ • 边缘细且连续                      │
  │                 │ • 计算复杂度高                      │
  ├─────────────────┼─────────────────────────────────────┤
  │  Laplacian      │ • 二阶导数，对噪声很敏感            │
  │                 │ • 可检测细节                        │
  └─────────────────┴─────────────────────────────────────┘

  选择建议：
  • 二值图像 → 形态学梯度
  • 灰度图像需要方向信息 → Sobel
  • 需要精细边缘 → Canny
```

---

## 💻 代码实战

### 代码1：基本形态学梯度

```python
"""
基本形态学梯度
使用 cv2.MORPH_GRADIENT 提取边缘
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# ===================== 创建测试图像 =====================

def create_test_image():
    """创建包含多个形状的测试图像"""
    img = np.zeros((200, 300), dtype=np.uint8)

    # 矩形
    cv2.rectangle(img, (20, 30), (100, 110), 255, -1)

    # 圆形
    cv2.circle(img, (180, 70), 45, 255, -1)

    # 三角形
    pts = np.array([[250, 120], [200, 180], [280, 180]], dtype=np.int32)
    cv2.fillPoly(img, [pts], 255)

    return img

# ===================== 形态学梯度 =====================

original = create_test_image()

# 创建结构元素
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))

# 方法1：使用 morphologyEx
gradient = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel)

# 方法2：手动计算 (膨胀 - 腐蚀)
dilated = cv2.dilate(original, kernel)
eroded = cv2.erode(original, kernel)
gradient_manual = dilated - eroded

# ===================== 可视化 =====================

fig, axes = plt.subplots(2, 2, figsize=(12, 10))

axes[0, 0].imshow(original, cmap='gray')
axes[0, 0].set_title('原始图像', fontsize=12)
axes[0, 0].axis('off')

axes[0, 1].imshow(gradient, cmap='gray')
axes[0, 1].set_title('形态学梯度（边缘）', fontsize=12)
axes[0, 1].axis('off')

axes[1, 0].imshow(dilated, cmap='gray')
axes[1, 0].set_title('膨胀结果', fontsize=12)
axes[1, 0].axis('off')

axes[1, 1].imshow(eroded, cmap='gray')
axes[1, 1].set_title('腐蚀结果', fontsize=12)
axes[1, 1].axis('off')

plt.suptitle('形态学梯度 = 膨胀 - 腐蚀', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('morphological_gradient.png', dpi=150)
plt.show()

# 验证两种方法等价
print("两种方法结果是否一致:", np.array_equal(gradient, gradient_manual))
```

---

### 代码2：三种梯度对比

```python
"""
对比三种形态学梯度：基本梯度、内梯度、外梯度
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# 创建测试图像
def create_shape():
    img = np.zeros((150, 150), dtype=np.uint8)
    cv2.circle(img, (75, 75), 50, 255, -1)
    return img

original = create_shape()
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))

# ===================== 计算三种梯度 =====================

# 基本梯度：膨胀 - 腐蚀
dilated = cv2.dilate(original, kernel)
eroded = cv2.erode(original, kernel)
basic_gradient = dilated - eroded

# 内梯度：原图 - 腐蚀
internal_gradient = original - eroded

# 外梯度：膨胀 - 原图
external_gradient = dilated - original

# ===================== 可视化 =====================

fig, axes = plt.subplots(2, 3, figsize=(12, 8))

# 第一行：原图、膨胀、腐蚀
axes[0, 0].imshow(original, cmap='gray')
axes[0, 0].set_title('原始图像', fontsize=11)
axes[0, 0].axis('off')

axes[0, 1].imshow(dilated, cmap='gray')
axes[0, 1].set_title('膨胀', fontsize=11)
axes[0, 1].axis('off')

axes[0, 2].imshow(eroded, cmap='gray')
axes[0, 2].set_title('腐蚀', fontsize=11)
axes[0, 2].axis('off')

# 第二行：三种梯度
axes[1, 0].imshow(basic_gradient, cmap='gray')
axes[1, 0].set_title('基本梯度\n(膨胀 - 腐蚀)', fontsize=11)
axes[1, 0].axis('off')

axes[1, 1].imshow(internal_gradient, cmap='gray')
axes[1, 1].set_title('内梯度\n(原图 - 腐蚀)', fontsize=11)
axes[1, 1].axis('off')

axes[1, 2].imshow(external_gradient, cmap='gray')
axes[1, 2].set_title('外梯度\n(膨胀 - 原图)', fontsize=11)
axes[1, 2].axis('off')

plt.suptitle('三种形态学梯度对比', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('three_gradients.png', dpi=150)
plt.show()

print("边缘宽度分析：")
print(f"• 基本梯度边缘宽度: {np.sum(basic_gradient > 0)} 像素")
print(f"• 内梯度边缘宽度: {np.sum(internal_gradient > 0)} 像素")
print(f"• 外梯度边缘宽度: {np.sum(external_gradient > 0)} 像素")
print("\n注意：基本梯度 ≈ 内梯度 + 外梯度")
```

---

### 代码3：结构元素大小对边缘宽度的影响

```python
"""
演示结构元素大小如何影响边缘宽度
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# 创建测试图像
def create_shape():
    img = np.zeros((150, 150), dtype=np.uint8)
    cv2.rectangle(img, (30, 30), (120, 120), 255, -1)
    return img

original = create_shape()

# 不同大小的结构元素
kernel_sizes = [3, 5, 9, 15]

fig, axes = plt.subplots(1, len(kernel_sizes) + 1, figsize=(15, 3))

axes[0].imshow(original, cmap='gray')
axes[0].set_title('原图', fontsize=11)
axes[0].axis('off')

for i, size in enumerate(kernel_sizes):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))
    gradient = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel)

    axes[i + 1].imshow(gradient, cmap='gray')
    axes[i + 1].set_title(f'{size}×{size} 核\n边缘宽度≈{size-1}px', fontsize=10)
    axes[i + 1].axis('off')

plt.suptitle('结构元素大小对边缘宽度的影响', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('gradient_kernel_size.png', dpi=150)
plt.show()

print("结论：")
print("• 边缘宽度 ≈ 结构元素大小 - 1")
print("• 核越大，边缘越粗")
print("• 根据需求选择合适的核大小")
```

---

### 代码4：不同形状结构元素的效果

```python
"""
对比不同形状结构元素产生的梯度效果
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# 创建测试图像（正方形）
def create_shape():
    img = np.zeros((150, 150), dtype=np.uint8)
    cv2.rectangle(img, (30, 30), (120, 120), 255, -1)
    return img

original = create_shape()

# 三种形状的结构元素
kernel_rect = cv2.getStructuringElement(cv2.MORPH_RECT, (7, 7))
kernel_cross = cv2.getStructuringElement(cv2.MORPH_CROSS, (7, 7))
kernel_ellipse = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))

# 计算梯度
gradient_rect = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel_rect)
gradient_cross = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel_cross)
gradient_ellipse = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel_ellipse)

# 可视化
fig, axes = plt.subplots(2, 4, figsize=(14, 7))

# 第一行：结构元素
axes[0, 0].imshow(original, cmap='gray')
axes[0, 0].set_title('原图', fontsize=11)
axes[0, 0].axis('off')

axes[0, 1].imshow(kernel_rect, cmap='gray')
axes[0, 1].set_title('矩形核', fontsize=11)
axes[0, 1].axis('off')

axes[0, 2].imshow(kernel_cross, cmap='gray')
axes[0, 2].set_title('十字核', fontsize=11)
axes[0, 2].axis('off')

axes[0, 3].imshow(kernel_ellipse, cmap='gray')
axes[0, 3].set_title('椭圆核', fontsize=11)
axes[0, 3].axis('off')

# 第二行：梯度结果
axes[1, 0].imshow(original, cmap='gray')
axes[1, 0].set_title('原图', fontsize=11)
axes[1, 0].axis('off')

axes[1, 1].imshow(gradient_rect, cmap='gray')
axes[1, 1].set_title('矩形核梯度', fontsize=11)
axes[1, 1].axis('off')

axes[1, 2].imshow(gradient_cross, cmap='gray')
axes[1, 2].set_title('十字核梯度', fontsize=11)
axes[1, 2].axis('off')

axes[1, 3].imshow(gradient_ellipse, cmap='gray')
axes[1, 3].set_title('椭圆核梯度', fontsize=11)
axes[1, 3].axis('off')

plt.suptitle('不同形状结构元素的梯度效果', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('gradient_kernel_shape.png', dpi=150)
plt.show()

print("观察结论：")
print("• 矩形核：边缘均匀，角落呈直角")
print("• 十字核：边缘呈阶梯状，有锯齿")
print("• 椭圆核：边缘圆滑，角落被削圆")
```

---

### 代码5：形态学梯度应用 - 轮廓提取

```python
"""
使用形态学梯度提取物体轮廓
并与原图叠加显示
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# ===================== 创建测试图像 =====================

def create_objects():
    """创建包含多个物体的图像"""
    img = np.zeros((250, 350), dtype=np.uint8)

    # 多个形状
    cv2.rectangle(img, (20, 20), (100, 100), 255, -1)
    cv2.circle(img, (170, 60), 45, 255, -1)
    cv2.ellipse(img, (280, 60), (40, 30), 0, 0, 360, 255, -1)

    # 下排
    pts1 = np.array([[50, 150], [20, 220], [80, 220]], dtype=np.int32)
    cv2.fillPoly(img, [pts1], 255)

    cv2.rectangle(img, (120, 140), (200, 230), 255, -1)

    # 五边形
    pts2 = np.array([[280, 140], [320, 170], [305, 220],
                     [255, 220], [240, 170]], dtype=np.int32)
    cv2.fillPoly(img, [pts2], 255)

    return img

# ===================== 轮廓提取 =====================

original = create_objects()
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))

# 提取边缘
edges = cv2.morphologyEx(original, cv2.MORPH_GRADIENT, kernel)

# 创建彩色图像用于叠加显示
original_color = cv2.cvtColor(original, cv2.COLOR_GRAY2BGR)
overlay = original_color.copy()

# 将边缘标记为红色
overlay[edges > 0] = [0, 0, 255]  # BGR格式的红色

# ===================== 可视化 =====================

fig, axes = plt.subplots(1, 3, figsize=(14, 4))

axes[0].imshow(original, cmap='gray')
axes[0].set_title('原始二值图像', fontsize=12)
axes[0].axis('off')

axes[1].imshow(edges, cmap='gray')
axes[1].set_title('提取的边缘', fontsize=12)
axes[1].axis('off')

axes[2].imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
axes[2].set_title('边缘叠加显示（红色）', fontsize=12)
axes[2].axis('off')

plt.suptitle('形态学梯度轮廓提取', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('contour_extraction.png', dpi=150)
plt.show()

print("应用场景：")
print("• 物体检测后的轮廓标注")
print("• 形状分析的预处理")
print("• 工业检测中的边缘定位")
```

---

### 代码6：灰度图像的形态学梯度

```python
"""
形态学梯度在灰度图像上的应用
可以用于增强边缘和纹理
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
plt.rcParams['axes.unicode_minus'] = False

# ===================== 创建灰度测试图像 =====================

def create_gray_image():
    """创建灰度渐变图像"""
    img = np.zeros((200, 200), dtype=np.uint8)

    # 渐变圆
    for r in range(80, 0, -1):
        gray_value = int(255 * (80 - r) / 80)
        cv2.circle(img, (100, 100), r, gray_value, -1)

    return img

# ===================== 灰度图像梯度 =====================

gray = create_gray_image()
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))

# 形态学梯度
gradient = cv2.morphologyEx(gray, cv2.MORPH_GRADIENT, kernel)

# 与 Sobel 对比
sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=5)
sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=5)
sobel = np.sqrt(sobel_x**2 + sobel_y**2)
sobel = np.uint8(np.clip(sobel, 0, 255))

# ===================== 可视化 =====================

fig, axes = plt.subplots(1, 3, figsize=(12, 4))

axes[0].imshow(gray, cmap='gray')
axes[0].set_title('原始灰度图像', fontsize=12)
axes[0].axis('off')

axes[1].imshow(gradient, cmap='gray')
axes[1].set_title('形态学梯度', fontsize=12)
axes[1].axis('off')

axes[2].imshow(sobel, cmap='gray')
axes[2].set_title('Sobel 梯度（对比）', fontsize=12)
axes[2].axis('off')

plt.suptitle('灰度图像的形态学梯度', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('gray_gradient.png', dpi=150)
plt.show()

print("灰度图像形态学梯度特点：")
print("• 可以检测灰度变化的边缘")
print("• 对噪声相对不敏感")
print("• 边缘比 Sobel 更粗，但更均匀")
```

---

## 📝 本节总结

```
┌────────────────────────────────────────────────────────────────┐
│                      形态学梯度总结                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  1. 三种梯度类型                                                │
│     ┌──────────────┬────────────────┬────────────────────┐     │
│     │    类型      │    计算公式    │       效果         │     │
│     ├──────────────┼────────────────┼────────────────────┤     │
│     │  基本梯度    │  膨胀 - 腐蚀   │  内外双侧边缘      │     │
│     ├──────────────┼────────────────┼────────────────────┤     │
│     │  内梯度      │  原图 - 腐蚀   │  仅内侧边缘        │     │
│     ├──────────────┼────────────────┼────────────────────┤     │
│     │  外梯度      │  膨胀 - 原图   │  仅外侧边缘        │     │
│     └──────────────┴────────────────┴────────────────────┘     │
│                                                                │
│  2. OpenCV 函数                                                 │
│     cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)          │
│                                                                │
│  3. 边缘宽度控制                                                │
│     • 边缘宽度 ≈ 结构元素大小 - 1                              │
│     • 核越大，边缘越粗                                         │
│                                                                │
│  4. 与其他边缘检测对比                                          │
│     • 形态学梯度：适合二值图像，抗噪声，边缘宽度可控           │
│     • Sobel/Canny：适合灰度图像，边缘更细腻                    │
│                                                                │
│  5. 应用场景                                                    │
│     • 物体轮廓提取                                             │
│     • 边缘增强                                                 │
│     • 形状分析预处理                                           │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

---

## 🎯 下一步学习

在下一节 **"05-顶帽与黑帽"** 中，我们将：
- 学习顶帽变换提取亮细节
- 学习黑帽变换提取暗细节
- 掌握光照不均匀图像的处理技巧

---

> 💡 **练习建议**：尝试用形态学梯度处理实际图像，对比不同结构元素大小的效果，找到最适合你需求的参数！

# 双边滤波

> 双边滤波是一种**保边去噪**滤波器。它在高斯滤波的基础上增加了**颜色相似度权重**——只有颜色接近的像素才会被用来平滑，从而在去噪的同时保留清晰的边缘。这是专业美颜磨皮、HDR 合成等高级应用的核心技术！

---

## 📖 理论部分

### 1. 为什么需要双边滤波？

#### 1.1 高斯滤波的问题：边缘模糊

前面我们学过，高斯滤波根据**空间距离**来分配权重——近的权重大，远的权重小。但它有一个致命问题：**完全不考虑像素值的差异**。

```
高斯滤波在边缘处的问题：

  原始边缘（黑→白的锐利边界）：
  ┌───┬───┬───┬───┬───┬───┐
  │ 0 │ 0 │ 0 │255│255│255│
  │ 0 │ 0 │ 0 │255│255│255│
  │ 0 │ 0 │ 0 │255│255│255│
  └───┴───┴───┴───┴───┴───┘

  对边界处的像素做高斯滤波时：
  ┌───┬───┬───┐
  │ 0 │ 0 │ 0 │     高斯只看距离，不看颜色
  ├───┼───┼───┤     所以黑色和白色都参与计算
  │ 0 │ 0 │255│ ←   结果 ≈ (0×大权重 + 255×小权重) / 总和
  ├───┼───┼───┤            ≈ 85（灰色！）
  │ 0 │ 0 │255│
  └───┴───┴───┘

  高斯滤波后：
  ┌───┬───┬───┬───┬───┬───┐
  │ 0 │ 0 │ 85│170│255│255│    锐利的边缘变成了渐变！
  │ 0 │ 0 │ 85│170│255│255│
  │ 0 │ 0 │ 85│170│255│255│
  └───┴───┴───┴───┴───┴───┘
```

> 💡 **问题根源：** 高斯滤波认为"近的像素就应该影响大"，完全不管它们是否属于同一区域（比如边缘两侧的像素其实属于不同物体）。

#### 1.2 双边滤波的解决方案

双边滤波的核心思想：**不仅看距离，还要看颜色是否相近**。

```
双边滤波的双重权重：

  普通高斯：
    权重 = f(空间距离)
    只看"远近"

  双边滤波：
    权重 = f(空间距离) × g(颜色差异)
           ↑               ↑
        距离越近越大      颜色越接近越大

  ┌─────────────────────────────────────────────────────────┐
  │                                                         │
  │  生活类比：                                             │
  │                                                         │
  │  高斯滤波像"问邻居借钱"：                              │
  │    → 离我家越近的邻居，借给我的越多                    │
  │    → 不管他是好人还是坏人                              │
  │                                                         │
  │  双边滤波像"问邻居借钱，但只找关系好的"：              │
  │    → 离我家越近 AND 和我关系越好的邻居，借给我越多    │
  │    → 隔壁的陌生人？虽然距离近，但关系差，权重低！      │
  │                                                         │
  └─────────────────────────────────────────────────────────┘
```

---

### 2. 双边滤波的数学原理

#### 2.1 权重公式

```
双边滤波的权重公式：

  W(i,j,k,l) = exp(-((i-k)² + (j-l)²) / (2×σs²))  ×  exp(-|I(i,j) - I(k,l)|² / (2×σr²))
               ──────────────────────────────────     ─────────────────────────────────
                        空间高斯权重                            颜色高斯权重
                       (距离越近越大)                         (颜色越接近越大)

  其中：
    (i,j) = 中心像素坐标
    (k,l) = 邻域内某个像素的坐标
    I(i,j), I(k,l) = 对应位置的像素值
    σs = 空间高斯的标准差（控制"距离多远开始权重变小"）
    σr = 颜色高斯的标准差（控制"颜色差多少开始权重变小"）
```

```
两个 σ 参数的含义：

  σs（sigmaSpace）：空间域参数
  ┌──────────────────────────────────────────┐
  │  控制空间距离的影响范围                  │
  │  σs 大 → 更远的像素也参与计算（更平滑）  │
  │  σs 小 → 只有很近的像素参与（保留细节）  │
  └──────────────────────────────────────────┘

  σr（sigmaColor）：颜色域参数
  ┌──────────────────────────────────────────┐
  │  控制颜色差异的容忍度                    │
  │  σr 大 → 颜色差异大的像素也参与（更平滑）│
  │  σr 小 → 只有颜色很接近的参与（边缘锐利）│
  └──────────────────────────────────────────┘
```

#### 2.2 在边缘处的行为

```
双边滤波在边缘处的表现：

  边缘区域的邻域：
  ┌───┬───┬───┐
  │ 0 │ 0 │ 0 │     黑色像素（值=0）
  ├───┼───┼───┤
  │ 0 │ ● │255│     ● 是当前处理的像素（值=0）
  ├───┼───┼───┤     右边是白色（值=255）
  │ 0 │ 0 │255│
  └───┴───┴───┘

  计算权重：
  ┌──────────────────────────────────────────────────────┐
  │  左边的黑色像素：                                    │
  │    空间权重：大（距离近）                            │
  │    颜色权重：大（都是 0，颜色相同）                  │
  │    → 总权重 = 大 × 大 = 很大 ✓                       │
  │                                                      │
  │  右边的白色像素：                                    │
  │    空间权重：大（距离近）                            │
  │    颜色权重：小（0 vs 255，颜色差异巨大）            │
  │    → 总权重 = 大 × 小 = 很小 ✗                       │
  └──────────────────────────────────────────────────────┘

  结果：白色像素虽然距离近，但因为颜色差异大，几乎不参与计算！
        → 边缘被保留了！
```

---

### 3. 双边滤波的特点

```
双边滤波的优缺点：

  ✅ 优点：
  ┌──────────────────────────────────────────────────┐
  │ 1. 去噪的同时保留边缘（这是最大的优势！）        │
  │ 2. 平滑区域变得更平滑                            │
  │ 3. 边缘区域保持锐利                              │
  │ 4. 非常适合人像磨皮（皮肤平滑，五官清晰）        │
  └──────────────────────────────────────────────────┘

  ❌ 缺点：
  ┌──────────────────────────────────────────────────┐
  │ 1. 计算速度很慢（比高斯滤波慢很多！）            │
  │ 2. 不能用快速傅里叶变换加速（非线性）            │
  │ 3. 参数调节需要经验（两个 σ 参数）               │
  │ 4. 可能产生阶梯效应（梯度被平坦化）              │
  └──────────────────────────────────────────────────┘
```

---

### 4. OpenCV 中的双边滤波

```
函数签名：

  cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)
  ├── src        : 输入图像
  ├── d          : 邻域直径（-1 表示根据 sigmaSpace 自动计算）
  ├── sigmaColor : 颜色空间的 σ（σr）
  └── sigmaSpace : 坐标空间的 σ（σs）

  参数建议：
  ┌─────────────────────────────────────────────────────────┐
  │  d = 9 或 -1（自动）：                                  │
  │    小于 5 效果不明显，大于 15 会很慢                    │
  │                                                         │
  │  sigmaColor = 75：                                      │
  │    值越大，更多颜色差异大的像素被混合                   │
  │    美颜磨皮建议 50-100                                  │
  │                                                         │
  │  sigmaSpace = 75：                                      │
  │    值越大，更远的像素被考虑（更模糊）                   │
  │    一般和 sigmaColor 取相近的值                         │
  └─────────────────────────────────────────────────────────┘

  常用调用：
  cv2.bilateralFilter(img, 9, 75, 75)   ← 经典参数组合
```

---

### 5. 双边滤波的应用场景

```
双边滤波的典型应用：

  1. 人像美颜/磨皮
     ┌────────────────────────────────────────────┐
     │  皮肤纹理被平滑（去掉毛孔、瑕疵）          │
     │  五官边缘保持锐利（眼睛、嘴唇不模糊）      │
     │  → 这就是美颜相机的核心原理之一！          │
     └────────────────────────────────────────────┘

  2. HDR 色调映射
     ┌────────────────────────────────────────────┐
     │  分离图像的"基础层"和"细节层"            │
     │  双边滤波提取平滑的基础层                  │
     │  原图 - 基础层 = 细节层                    │
     │  分别处理后再合并                          │
     └────────────────────────────────────────────┘

  3. 卡通风格化
     ┌────────────────────────────────────────────┐
     │  多次双边滤波使颜色过渡变得平坦            │
     │  形成类似卡通的色块效果                    │
     │  边缘仍然保持锐利                          │
     └────────────────────────────────────────────┘

  4. 图像去噪预处理
     ┌────────────────────────────────────────────┐
     │  在边缘检测、特征提取之前                  │
     │  去除噪声但保留边缘                        │
     │  提高后续处理的准确性                      │
     └────────────────────────────────────────────┘
```

---

## 💻 代码部分

### 代码示例 1：基础双边滤波

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# ========== cv2.bilateralFilter() 基本用法 ==========
# 参数：(图像, 邻域直径d, sigmaColor, sigmaSpace)

# 轻度双边滤波
bilateral_light = cv2.bilateralFilter(img, 5, 50, 50)

# 中度双边滤波（常用参数）
bilateral_medium = cv2.bilateralFilter(img, 9, 75, 75)

# 强度双边滤波
bilateral_strong = cv2.bilateralFilter(img, 15, 100, 100)

# 显示结果
cv2.imshow("Original", img)
cv2.imshow("Bilateral Light (5, 50, 50)", bilateral_light)
cv2.imshow("Bilateral Medium (9, 75, 75)", bilateral_medium)
cv2.imshow("Bilateral Strong (15, 100, 100)", bilateral_strong)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 2：双边滤波 vs 高斯滤波（边缘保持对比）

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 高斯滤波（会模糊边缘）
gaussian = cv2.GaussianBlur(img, (15, 15), 0)

# 双边滤波（保持边缘）
bilateral = cv2.bilateralFilter(img, 15, 75, 75)

# 边缘检测对比
edges_original = cv2.Canny(img, 100, 200)
edges_gaussian = cv2.Canny(gaussian, 100, 200)
edges_bilateral = cv2.Canny(bilateral, 100, 200)

# 显示滤波结果
cv2.imshow("Original", img)
cv2.imshow("Gaussian 15x15", gaussian)
cv2.imshow("Bilateral (15, 75, 75)", bilateral)

cv2.imshow("Edges - Original", edges_original)
cv2.imshow("Edges - Gaussian", edges_gaussian)
cv2.imshow("Edges - Bilateral", edges_bilateral)

cv2.waitKey(0)
cv2.destroyAllWindows()

# 观察：
# - 高斯滤波后的边缘变得模糊、断断续续
# - 双边滤波后的边缘仍然清晰！
```

---

### 代码示例 3：sigmaColor 和 sigmaSpace 的影响

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 固定 d=9，测试不同的 sigma 组合

# sigmaColor 的影响（固定 sigmaSpace=75）
colors = [25, 50, 75, 100, 150]
for sc in colors:
    result = cv2.bilateralFilter(img, 9, sc, 75)
    cv2.imshow(f"sigmaColor={sc}, sigmaSpace=75", result)

cv2.imshow("Original", img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# sigmaSpace 的影响（固定 sigmaColor=75）
spaces = [25, 50, 75, 100, 150]
for ss in spaces:
    result = cv2.bilateralFilter(img, 9, 75, ss)
    cv2.imshow(f"sigmaColor=75, sigmaSpace={ss}", result)

cv2.imshow("Original", img)
cv2.waitKey(0)
cv2.destroyAllWindows()

# 观察：
# - sigmaColor 大：颜色差异大的像素也被混合，边缘开始模糊
# - sigmaSpace 大：更远的像素参与计算，整体更平滑
```

---

### 代码示例 4：人像磨皮效果

```python
import cv2
import numpy as np

# 读取人像图片
img = cv2.imread("portrait.jpg")
if img is None:
    # 创建模拟的"人像"
    img = np.ones((300, 300, 3), dtype=np.uint8) * 200
    # 添加一些模拟的皮肤瑕疵
    for _ in range(100):
        y, x = np.random.randint(50, 250), np.random.randint(50, 250)
        color = np.random.randint(150, 220)
        cv2.circle(img, (x, y), np.random.randint(1, 4),
                   (color, color, color), -1)
    print("未找到人像图片，使用模拟图像")

# 方法1：高斯滤波磨皮（边缘会模糊）
gaussian_skin = cv2.GaussianBlur(img, (15, 15), 0)

# 方法2：双边滤波磨皮（边缘保持清晰）
bilateral_skin = cv2.bilateralFilter(img, 9, 75, 75)

# 方法3：强力双边磨皮
bilateral_strong = cv2.bilateralFilter(img, 15, 100, 100)

# 方法4：迭代双边滤波（更强的磨皮效果，但更慢）
bilateral_iter = img.copy()
for _ in range(3):
    bilateral_iter = cv2.bilateralFilter(bilateral_iter, 5, 50, 50)

# 显示
cv2.imshow("Original", img)
cv2.imshow("Gaussian Smooth", gaussian_skin)
cv2.imshow("Bilateral Smooth", bilateral_skin)
cv2.imshow("Bilateral Strong", bilateral_strong)
cv2.imshow("Bilateral Iterative (3x)", bilateral_iter)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 5：卡通风格化效果

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 卡通化步骤：
# 1. 多次双边滤波使颜色平坦化
cartoon = img.copy()
for _ in range(5):
    cartoon = cv2.bilateralFilter(cartoon, 9, 75, 75)

# 2. 转灰度并用中值滤波去噪
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.medianBlur(gray, 7)

# 3. 自适应阈值提取边缘
edges = cv2.adaptiveThreshold(
    gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY, 9, 9
)

# 4. 将边缘与平坦化的彩色图合并
edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
cartoon_final = cv2.bitwise_and(cartoon, edges_color)

# 显示
cv2.imshow("Original", img)
cv2.imshow("Bilateral x5", cartoon)
cv2.imshow("Edges", edges)
cv2.imshow("Cartoon Effect", cartoon_final)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 6：双边滤波的速度对比

```python
import cv2
import numpy as np
import time

# 读取图像
img = cv2.imread("test.jpg")
if img is None:
    img = np.random.randint(0, 256, (500, 500, 3), dtype=np.uint8)

# 测试不同滤波器的速度
iterations = 10

# 高斯滤波
start = time.time()
for _ in range(iterations):
    cv2.GaussianBlur(img, (15, 15), 0)
gaussian_time = (time.time() - start) / iterations * 1000

# 均值滤波
start = time.time()
for _ in range(iterations):
    cv2.blur(img, (15, 15))
blur_time = (time.time() - start) / iterations * 1000

# 中值滤波
start = time.time()
for _ in range(iterations):
    cv2.medianBlur(img, 15)
median_time = (time.time() - start) / iterations * 1000

# 双边滤波（最慢！）
start = time.time()
for _ in range(iterations):
    cv2.bilateralFilter(img, 15, 75, 75)
bilateral_time = (time.time() - start) / iterations * 1000

print("滤波器速度对比")
print("=" * 40)
print(f"图像大小：{img.shape[1]}×{img.shape[0]}")
print(f"核大小：15×15")
print("-" * 40)
print(f"均值滤波：    {blur_time:.2f} ms")
print(f"高斯滤波：    {gaussian_time:.2f} ms")
print(f"中值滤波：    {median_time:.2f} ms")
print(f"双边滤波：    {bilateral_time:.2f} ms")
print("-" * 40)
print(f"双边滤波比高斯慢 {bilateral_time/gaussian_time:.1f} 倍！")

# 典型输出：
# 双边滤波比高斯滤波慢 10-30 倍
```

---

## 📝 本节小结

```
双边滤波 - 知识脑图：

  双边滤波 (cv2.bilateralFilter)
  │
  ├── 核心原理
  │   ├── 双重权重 = 空间权重 × 颜色权重
  │   ├── 颜色接近的像素权重大
  │   └── 边缘两侧颜色差异大 → 不互相影响 → 边缘保留
  │
  ├── 参数
  │   ├── d：邻域直径（-1 自动，推荐 5-15）
  │   ├── sigmaColor：颜色差异容忍度
  │   └── sigmaSpace：空间距离影响范围
  │
  ├── 优点
  │   ├── 去噪同时保留边缘（最大优势！）
  │   ├── 平滑区域更平滑
  │   └── 适合美颜磨皮
  │
  ├── 缺点
  │   ├── 速度很慢（比高斯慢 10-30 倍）
  │   └── 参数需要调节
  │
  └── 应用场景
      ├── 人像美颜/磨皮
      ├── HDR 色调映射
      ├── 卡通风格化
      └── 图像去噪预处理
```

> 💡 **关键要点：**
> 1. `cv2.bilateralFilter(img, 9, 75, 75)` 是常用的参数组合
> 2. 双边滤波 = 空间高斯 × 颜色高斯，颜色差异大的像素权重低
> 3. 这是保留边缘的关键——边缘两侧颜色差异大，互不干扰
> 4. 缺点是速度很慢，实时应用需要考虑优化或替代方案
> 5. 美颜磨皮的核心技术：皮肤平滑 + 五官边缘锐利

---

👉 [上一节：中值滤波](../04-中值滤波/中值滤波.md) | [返回章节目录](../图像滤波.md) | [下一节：滤波器对比](../06-滤波器对比/滤波器对比.md)

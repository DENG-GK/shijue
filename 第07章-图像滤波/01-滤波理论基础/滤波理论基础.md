# 滤波理论基础

> 图像滤波是图像处理中最核心的基础操作之一。简单来说，滤波就是用一个"小窗口"在图像上滑动，根据窗口内像素的信息来计算新的像素值。掌握滤波的基本原理，后面学习各种具体滤波器就会轻松很多！

---

## 📖 理论部分

### 1. 什么是图像滤波？

#### 1.1 从生活中理解滤波

在日常生活中，你其实已经接触过很多"滤波"操作：

```
生活中的"滤波"例子：

  ┌─────────────────────────────────────────────────────┐
  │  🔊 音乐均衡器                                      │
  │     降低高音噪声、增强低音 → 音频滤波                │
  │                                                     │
  │  📷 美颜相机                                        │
  │     磨皮（去掉皮肤上的小瑕疵）→ 图像平滑滤波        │
  │                                                     │
  │  ☕ 咖啡滤纸                                        │
  │     让咖啡液通过，阻挡咖啡渣 → 物理滤波              │
  │                                                     │
  │  📊 股票均线                                        │
  │     用最近几天的平均价格代替当天价格 → 数据平滑      │
  └─────────────────────────────────────────────────────┘

  它们的共同点：从原始数据中"过滤"掉不想要的部分，
  保留或增强想要的部分。
```

图像滤波的核心思想也是一样：**利用像素周围邻居的信息，来重新计算该像素的值**。

#### 1.2 为什么需要图像滤波？

实际拍摄的照片往往不完美，可能存在各种问题：

```
图像中常见的问题：

  原始图像            存在的问题
  ┌──────────┐
  │ ▓▓▓▓▓▓▓▓ │  ← 1. 噪声：随机的亮点/暗点（拍照时光线不足、传感器干扰）
  │ ▓▓░▓▓▓▓▓ │       像照片上的"雪花点"
  │ ▓▓▓▓▓░▓▓ │
  │ ▓▓▓▓▓▓▓▓ │  ← 2. 毛刺：边缘不平滑（低分辨率、压缩伪影）
  │ ▓░▓▓▓▓▓▓ │       像锯齿一样的边缘
  └──────────┘
       ↓  滤波处理后
  ┌──────────┐
  │ ▓▓▓▓▓▓▓▓ │  ← 噪声被去除，图像变干净
  │ ▓▓▓▓▓▓▓▓ │     边缘更平滑
  │ ▓▓▓▓▓▓▓▓ │
  │ ▓▓▓▓▓▓▓▓ │
  │ ▓▓▓▓▓▓▓▓ │
  └──────────┘
```

**图像滤波的主要用途：**

| 用途 | 说明 | 典型场景 |
|------|------|----------|
| **去噪** | 去除图像中的随机噪声 | 夜景照片降噪、医学图像去噪 |
| **平滑** | 让图像变得更柔和 | 美颜磨皮、背景虚化 |
| **锐化** | 增强图像的边缘和细节 | 照片清晰化、文字增强 |
| **边缘检测** | 找出图像中物体的轮廓 | 自动驾驶、目标识别的预处理 |
| **特征提取** | 提取特定方向或频率的信息 | 纹理分析、模式识别 |

---

### 2. 卷积——滤波的核心操作

#### 2.1 什么是卷积？

图像滤波的数学基础就是**卷积（Convolution）**。别被这个名字吓到，它的操作非常简单！

```
卷积的直观理解：

  想象你拿着一个小小的"放大镜"（卷积核），
  在一张大照片上从左到右、从上到下慢慢移动。

  每移到一个位置：
    1. 看看放大镜覆盖的这一小块区域内有哪些像素
    2. 把这些像素的值和放大镜上的"权重"做运算
    3. 算出一个新的数字，作为中心像素的新值

  ┌─────────────────────────────────────────┐
  │                                         │
  │    原始图像（大）                        │
  │    ┌───┬───┬───┬───┬───┬───┬───┐       │
  │    │   │   │   │   │   │   │   │       │
  │    ├───┼───┼───┼───┼───┼───┼───┤       │
  │    │   │ ╔═══════╗ │   │   │   │       │
  │    ├───┤ ║ 卷积核 ║ ├───┼───┼───┤       │
  │    │   │ ║ (小窗) ║ │   │   │   │       │
  │    ├───┤ ╚═══════╝ ├───┼───┼───┤       │
  │    │   │   │   │   │   │   │   │       │
  │    ├───┼───┼───┼───┼───┼───┼───┤       │
  │    │   │   │   │   │   │   │   │       │
  │    └───┴───┴───┴───┴───┴───┴───┘       │
  │                                         │
  │    小窗口在大图上滑动 → 产生新图像       │
  └─────────────────────────────────────────┘
```

#### 2.2 卷积核（Kernel）

卷积核也叫**滤波器（Filter）**或**模板（Mask）**，它是一个小的矩阵，通常是奇数大小（3×3、5×5、7×7等），定义了如何利用周围像素来计算新值。

```
为什么卷积核是奇数大小？

  3×3 的核：
  ┌───┬───┬───┐
  │   │   │   │
  ├───┼───┼───┤     中心位置明确 ✓
  │   │ ● │   │     ● 就是中心
  ├───┼───┼───┤
  │   │   │   │
  └───┴───┴───┘

  4×4 的核：
  ┌───┬───┬───┬───┐
  │   │   │   │   │
  ├───┼───┼───┼───┤   中心在哪？ ✗
  │   │ ? │ ? │   │   找不到唯一的中心点！
  ├───┼───┼───┼───┤
  │   │   │   │   │
  ├───┼───┼───┼───┤
  │   │   │   │   │
  └───┴───┴───┴───┘

  → 奇数大小保证有一个明确的中心像素
```

不同的卷积核实现不同的滤波效果：

```
不同卷积核的效果：

  均值核（模糊/平滑）：      锐化核：                边缘检测核：
  ┌─────┬─────┬─────┐      ┌─────┬─────┬─────┐    ┌─────┬─────┬─────┐
  │ 1/9 │ 1/9 │ 1/9 │      │  0  │ -1  │  0  │    │ -1  │ -1  │ -1  │
  ├─────┼─────┼─────┤      ├─────┼─────┼─────┤    ├─────┼─────┼─────┤
  │ 1/9 │ 1/9 │ 1/9 │      │ -1  │  5  │ -1  │    │ -1  │  8  │ -1  │
  ├─────┼─────┼─────┤      ├─────┼─────┼─────┤    ├─────┼─────┼─────┤
  │ 1/9 │ 1/9 │ 1/9 │      │  0  │ -1  │  0  │    │ -1  │ -1  │ -1  │
  └─────┴─────┴─────┘      └─────┴─────┴─────┘    └─────┴─────┴─────┘
  所有值相等 → 平均         中心权重大 → 增强细节   中心与周围相减 → 提取边缘
```

#### 2.3 卷积计算步骤（手把手演示）

让我们用一个具体的例子来演示卷积是怎么算的：

```
完整的卷积计算示例：

  原始图像（5×5）：              3×3 均值卷积核：
  ┌────┬────┬────┬────┬────┐    ┌─────┬─────┬─────┐
  │ 10 │ 20 │ 30 │ 40 │ 50 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    ├─────┼─────┼─────┤
  │ 20 │ 30 │ 40 │ 50 │ 60 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    ├─────┼─────┼─────┤
  │ 30 │ 40 │ 50 │ 60 │ 70 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    └─────┴─────┴─────┘
  │ 40 │ 50 │ 60 │ 70 │ 80 │
  ├────┼────┼────┼────┼────┤
  │ 50 │ 60 │ 70 │ 80 │ 90 │
  └────┴────┴────┴────┴────┘

  计算位置(1,1)处（即值为30的那个像素）的新值：

  Step 1: 取出3×3邻域           Step 2: 逐元素相乘
  ┌────┬────┬────┐              ┌──────┬──────┬──────┐
  │ 10 │ 20 │ 30 │              │10×1/9│20×1/9│30×1/9│
  ├────┼────┼────┤     →        ├──────┼──────┼──────┤
  │ 20 │ 30 │ 40 │              │20×1/9│30×1/9│40×1/9│
  ├────┼────┼────┤              ├──────┼──────┼──────┤
  │ 30 │ 40 │ 50 │              │30×1/9│40×1/9│50×1/9│
  └────┴────┴────┘              └──────┴──────┴──────┘

  Step 3: 全部加起来
  = (10+20+30+20+30+40+30+40+50) / 9
  = 270 / 9
  = 30

  → 位置(1,1)的新值为 30

  然后窗口向右移动一格，计算下一个位置...直到遍历完整幅图像。
```

> 💡 **核心公式：** 新像素值 = Σ(邻域像素 × 对应核权重)

---

### 3. 边界处理

#### 3.1 边界问题是什么？

当卷积核移到图像边缘时，核的一部分会"伸出"图像外面——那里没有像素值！这就是**边界问题**。

```
边界问题示意：

  卷积核在图像左上角时：

        ？？？
        ？┌────┬────┬────┬────┐
        ？│ 10 │ 20 │ 30 │ 40 │
         ─┼────┼────┼────┼────┤
          │ 20 │ 30 │ 40 │ 50 │
          ├────┼────┼────┼────┤
          │ 30 │ 40 │ 50 │ 60 │
          └────┴────┴────┴────┘

  ？的位置在图像外面，没有像素值！
  怎么办？ → 需要"边界填充"策略
```

#### 3.2 OpenCV 中的边界填充方式

OpenCV 提供了多种边界处理方式：

```
假设图像边缘一行为：| A | B | C | D |

不同填充方式的效果：

  1. BORDER_CONSTANT（常数填充，默认填0）：
     | 0 | 0 | A | B | C | D | 0 | 0 |
     用固定值（通常是0，即黑色）填充

  2. BORDER_REPLICATE（复制边缘像素）：
     | A | A | A | B | C | D | D | D |
     把最边缘的像素复制到外面

  3. BORDER_REFLECT（镜像反射）：
     | C | B | A | B | C | D | C | B |
     像照镜子一样反射

  4. BORDER_REFLECT_101（不含边界的反射，OpenCV 默认）：
     | D | C | B | A | B | C | D | C |  ← 注意 A 不重复
     类似 REFLECT 但不重复边界像素

  5. BORDER_WRAP（环绕）：
     | C | D | A | B | C | D | A | B |
     像游戏地图一样左右连接
```

> 💡 **OpenCV 默认使用 `BORDER_REFLECT_101`**（也叫 `BORDER_DEFAULT`），大多数情况下效果最好。

```python
import cv2
import numpy as np

# 创建一个小图像来演示边界填充
img = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
], dtype=np.uint8)

# 不同的边界填充方式
# 参数：(图像, 上, 下, 左, 右, 填充方式)

# 1. 常数填充（默认填0）
constant = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0)
print("常数填充（0）：")
print(constant)
# [[0, 0, 0, 0, 0],
#  [0, 1, 2, 3, 0],
#  [0, 4, 5, 6, 0],
#  [0, 7, 8, 9, 0],
#  [0, 0, 0, 0, 0]]

# 2. 复制边缘
replicate = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_REPLICATE)
print("复制边缘：")
print(replicate)
# [[1, 1, 2, 3, 3],
#  [1, 1, 2, 3, 3],
#  [4, 4, 5, 6, 6],
#  [7, 7, 8, 9, 9],
#  [7, 7, 8, 9, 9]]

# 3. 镜像反射（默认）
reflect = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_REFLECT_101)
print("镜像反射（默认）：")
print(reflect)
# [[5, 4, 5, 6, 5],
#  [2, 1, 2, 3, 2],
#  [5, 4, 5, 6, 5],
#  [8, 7, 8, 9, 8],
#  [5, 4, 5, 6, 5]]
```

---

### 4. 滤波器的分类

#### 4.1 按处理方式分类

```
滤波器分类总览：

  图像滤波器
  ├── 线性滤波器
  │   ├── 均值滤波（所有邻居取平均）
  │   ├── 高斯滤波（加权平均，中心权重大）
  │   └── 自定义卷积核
  │
  └── 非线性滤波器
      ├── 中值滤波（取中间值）
      ├── 双边滤波（空间+颜色双重加权）
      └── 最大/最小值滤波
```

**线性滤波**和**非线性滤波**的区别：

| 特性 | 线性滤波 | 非线性滤波 |
|------|----------|------------|
| 计算方式 | 加权求和（卷积） | 排序、条件判断等 |
| 数学表示 | 可以用矩阵乘法表示 | 无法用简单矩阵表示 |
| 典型代表 | 均值滤波、高斯滤波 | 中值滤波、双边滤波 |
| 对边缘的影响 | 会模糊边缘 | 可以保留边缘 |
| 计算速度 | 通常较快 | 通常较慢 |

```
直观理解线性 vs 非线性：

  假设邻域中有这些像素值：[10, 12, 11, 200, 13, 10, 12, 11, 14]
                                              ↑
                                           噪声点（特别大）

  线性滤波（均值）：
    新值 = (10+12+11+200+13+10+12+11+14) / 9 = 32.6
    → 噪声值 200 拉高了平均值！结果偏大

  非线性滤波（中值）：
    排序后：[10, 10, 11, 11, 12, 12, 13, 14, 200]
    新值 = 12（中间那个值）
    → 噪声值 200 被完全忽略！结果准确

  结论：非线性滤波对异常值（噪声）的抵抗力更强！
```

#### 4.2 按功能分类

```
按功能分类：

  ┌──────────────────────────────────────────────┐
  │           低通滤波（Low-Pass Filter）         │
  │                                              │
  │  保留平缓变化（低频），去除剧烈变化（高频）  │
  │  效果：图像变模糊、变平滑                    │
  │  代表：均值滤波、高斯滤波                    │
  │                                              │
  │  生活类比：戴上近视眼镜（度数不对的），       │
  │  看东西模模糊糊，细节看不清了                 │
  └──────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────┐
  │           高通滤波（High-Pass Filter）        │
  │                                              │
  │  保留剧烈变化（高频），去除平缓变化（低频）  │
  │  效果：增强边缘、提取轮廓                    │
  │  代表：拉普拉斯算子、Sobel 算子              │
  │                                              │
  │  生活类比：用铅笔描出照片中物体的轮廓线，    │
  │  只留下线条，去掉色块                        │
  └──────────────────────────────────────────────┘
```

> 💡 **频率的含义：** 在图像中，"频率"指的是像素值变化的剧烈程度。平坦区域（如蓝天）是低频，边缘和纹理（如头发丝）是高频。

---

### 5. 噪声类型

了解常见的噪声类型，有助于我们选择合适的滤波器：

#### 5.1 高斯噪声

```
高斯噪声（Gaussian Noise）：

  特点：每个像素上叠加一个随机偏移值，偏移量符合正态分布
  来源：传感器热噪声、电路干扰

  原始像素值：  100  100  100  100  100
  加噪声后：     98  103   97  101  105
                 ↓    ↓    ↓    ↓    ↓
  偏移量：       -2   +3   -3   +1   +5  ← 大多数偏移较小

  视觉效果：图像看起来有点"沙沙的"，像蒙了一层薄雾

  ┌──────────────────────┐     ┌──────────────────────┐
  │  ████████████████    │     │  █▓██▓███▓█▓██▓█    │
  │  ████████████████    │ →   │  ██▓████▓██████▓    │
  │  ████████████████    │     │  █▓██████▓█▓████    │
  │  原始图像（干净）    │     │  加了高斯噪声        │
  └──────────────────────┘     └──────────────────────┘

  适合的滤波器：高斯滤波、均值滤波
```

#### 5.2 椒盐噪声

```
椒盐噪声（Salt-and-Pepper Noise）：

  特点：随机出现极黑（0）或极白（255）的像素点
  来源：数据传输错误、传感器故障

  原始像素值：  100  100  100  100  100
  加噪声后：    100    0  100  255  100
                       ↑         ↑
                    "胡椒"     "盐粒"
                    (黑点)     (白点)

  视觉效果：图像上随机散布黑白点，像撒了胡椒和盐

  ┌──────────────────────┐     ┌──────────────────────┐
  │  ████████████████    │     │  █○██●███○█●██○█    │
  │  ████████████████    │ →   │  ██●████○██████●    │
  │  ████████████████    │     │  █○██████●█○████    │
  │  原始图像（干净）    │     │  ○=白点 ●=黑点       │
  └──────────────────────┘     └──────────────────────┘

  适合的滤波器：中值滤波（效果最好！）
```

#### 5.3 均匀噪声

```
均匀噪声（Uniform Noise）：

  特点：随机偏移值在某个范围内均匀分布
  来源：量化误差、模数转换

  偏移量在 [-10, +10] 内均匀随机
  每个偏移值出现的概率相同

  适合的滤波器：均值滤波
```

---

### 6. 卷积核大小的影响

#### 6.1 核越大，模糊越强

```
不同大小卷积核的效果：

  原始图像        3×3 核          5×5 核          7×7 核
  ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
  │清晰锐利│    │略微模糊│    │明显模糊│    │严重模糊│
  │细节丰富│ →  │细节减少│ →  │细节更少│ →  │细节很少│
  │边缘清楚│    │边缘变软│    │边缘模糊│    │边缘消失│
  └────────┘    └────────┘    └────────┘    └────────┘

  核大小增大 → 参与计算的像素越多 → 平滑效果越强
                                   → 但细节损失也越多！

  这就像：
  ┌──────────────────────────────────────────────────────┐
  │  问3个人的意见   → 结果还比较有个性（细节保留多）    │
  │  问9个人的意见   → 结果变得中庸（细节减少）          │
  │  问25个人的意见  → 结果变得非常平均（细节丢失严重）  │
  └──────────────────────────────────────────────────────┘
```

> 💡 **实际建议：** 一般从 3×3 或 5×5 开始尝试，根据效果逐步调整。核太大会导致图像过于模糊。

#### 6.2 计算量与核大小的关系

```
核大小与计算量：

  核大小    每个像素的乘加次数    相对计算量
  ─────    ──────────────────    ──────────
   3×3           9 次                1x
   5×5          25 次              2.8x
   7×7          49 次              5.4x
   9×9          81 次              9.0x
  11×11        121 次             13.4x

  → 核大小翻倍，计算量大约增长 4 倍！
```

---

## 💻 代码部分

### 代码示例 1：手动实现卷积操作

> 通过手动实现，深入理解卷积的工作原理。

```python
import cv2
import numpy as np

def manual_convolution(image, kernel):
    """
    手动实现2D卷积操作

    参数：
        image: 输入灰度图像 (H, W)
        kernel: 卷积核 (kH, kW)

    返回：
        卷积结果图像
    """
    # 获取图像和卷积核的尺寸
    img_h, img_w = image.shape[:2]
    ker_h, ker_w = kernel.shape[:2]

    # 计算padding大小（保证输出图像和输入大小一样）
    pad_h = ker_h // 2
    pad_w = ker_w // 2

    # 对图像进行边界填充（用镜像反射）
    padded = cv2.copyMakeBorder(
        image, pad_h, pad_h, pad_w, pad_w,
        cv2.BORDER_REFLECT_101
    )

    # 创建输出图像
    output = np.zeros_like(image, dtype=np.float64)

    # 逐像素计算卷积
    for i in range(img_h):
        for j in range(img_w):
            # 取出当前位置对应的邻域
            region = padded[i:i+ker_h, j:j+ker_w].astype(np.float64)
            # 逐元素相乘后求和
            output[i, j] = np.sum(region * kernel)

    # 裁剪到 0-255 并转为 uint8
    output = np.clip(output, 0, 255).astype(np.uint8)
    return output


# ========== 实际使用 ==========

# 读取图像并转为灰度
img = cv2.imread("test.jpg", cv2.IMREAD_GRAYSCALE)

# 定义一个 3×3 均值卷积核
kernel_mean = np.ones((3, 3), dtype=np.float64) / 9.0
print("均值卷积核：")
print(kernel_mean)
# [[0.111 0.111 0.111]
#  [0.111 0.111 0.111]
#  [0.111 0.111 0.111]]

# 手动卷积
result_manual = manual_convolution(img, kernel_mean)

# OpenCV 内置卷积（对比用）
result_opencv = cv2.filter2D(img, -1, kernel_mean)

# 对比结果（应该非常接近）
diff = cv2.absdiff(result_manual, result_opencv)
print(f"手动实现与 OpenCV 的最大差异：{diff.max()}")
# 通常差异为 0 或 1（浮点精度导致）

# 显示结果
cv2.imshow("Original", img)
cv2.imshow("Manual Convolution", result_manual)
cv2.imshow("OpenCV filter2D", result_opencv)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 2：OpenCV 的 filter2D 函数

> 实际开发中我们不需要手动实现卷积，OpenCV 提供了高效的 `filter2D` 函数。

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# ========== filter2D 基本用法 ==========
# cv2.filter2D(src, ddepth, kernel)
#   src: 输入图像
#   ddepth: 输出图像深度（-1 表示与输入相同）
#   kernel: 卷积核

# 1. 均值模糊核
kernel_blur = np.ones((5, 5), dtype=np.float32) / 25
result_blur = cv2.filter2D(img, -1, kernel_blur)

# 2. 锐化核
kernel_sharpen = np.array([
    [ 0, -1,  0],
    [-1,  5, -1],
    [ 0, -1,  0]
], dtype=np.float32)
result_sharpen = cv2.filter2D(img, -1, kernel_sharpen)

# 3. 边缘检测核
kernel_edge = np.array([
    [-1, -1, -1],
    [-1,  8, -1],
    [-1, -1, -1]
], dtype=np.float32)
result_edge = cv2.filter2D(img, -1, kernel_edge)

# 4. 浮雕效果核
kernel_emboss = np.array([
    [-2, -1, 0],
    [-1,  1, 1],
    [ 0,  1, 2]
], dtype=np.float32)
result_emboss = cv2.filter2D(img, -1, kernel_emboss)

# 显示所有效果
cv2.imshow("Original", img)
cv2.imshow("Blur (Mean)", result_blur)
cv2.imshow("Sharpen", result_sharpen)
cv2.imshow("Edge Detection", result_edge)
cv2.imshow("Emboss", result_emboss)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 3：添加噪声并观察效果

```python
import cv2
import numpy as np

def add_gaussian_noise(image, mean=0, sigma=25):
    """添加高斯噪声"""
    noise = np.random.normal(mean, sigma, image.shape).astype(np.float64)
    noisy = image.astype(np.float64) + noise
    return np.clip(noisy, 0, 255).astype(np.uint8)

def add_salt_pepper_noise(image, amount=0.05):
    """添加椒盐噪声"""
    noisy = image.copy()
    h, w = image.shape[:2]
    # 计算噪声像素数量
    num_noise = int(h * w * amount)

    # 添加"盐"（白点）
    for _ in range(num_noise):
        y = np.random.randint(0, h)
        x = np.random.randint(0, w)
        noisy[y, x] = 255

    # 添加"胡椒"（黑点）
    for _ in range(num_noise):
        y = np.random.randint(0, h)
        x = np.random.randint(0, w)
        noisy[y, x] = 0

    return noisy


# ========== 实际使用 ==========

# 读取灰度图像
img = cv2.imread("test.jpg", cv2.IMREAD_GRAYSCALE)

# 添加不同类型的噪声
gaussian_noisy = add_gaussian_noise(img, mean=0, sigma=25)
salt_pepper_noisy = add_salt_pepper_noise(img, amount=0.05)

# 显示原图和加噪结果
cv2.imshow("Original", img)
cv2.imshow("Gaussian Noise (sigma=25)", gaussian_noisy)
cv2.imshow("Salt & Pepper Noise (5%)", salt_pepper_noisy)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 4：边界填充效果可视化

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 填充大小（像素）
top = bottom = left = right = 50

# 不同的边界填充方式
constant = cv2.copyMakeBorder(img, top, bottom, left, right,
                               cv2.BORDER_CONSTANT, value=(0, 0, 0))

replicate = cv2.copyMakeBorder(img, top, bottom, left, right,
                                cv2.BORDER_REPLICATE)

reflect = cv2.copyMakeBorder(img, top, bottom, left, right,
                              cv2.BORDER_REFLECT)

reflect101 = cv2.copyMakeBorder(img, top, bottom, left, right,
                                 cv2.BORDER_REFLECT_101)

wrap = cv2.copyMakeBorder(img, top, bottom, left, right,
                           cv2.BORDER_WRAP)

# 显示所有填充效果
cv2.imshow("CONSTANT (Black)", constant)
cv2.imshow("REPLICATE", replicate)
cv2.imshow("REFLECT", reflect)
cv2.imshow("REFLECT_101 (Default)", reflect101)
cv2.imshow("WRAP", wrap)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 5：不同大小卷积核的模糊效果对比

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 使用不同大小的均值核进行模糊
sizes = [3, 5, 9, 15, 25]
results = []

for size in sizes:
    # 创建均值核
    kernel = np.ones((size, size), dtype=np.float32) / (size * size)
    # 应用卷积
    result = cv2.filter2D(img, -1, kernel)
    results.append(result)

    # 显示
    cv2.imshow(f"Kernel {size}x{size}", result)

cv2.imshow("Original", img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 📝 本节小结

```
滤波理论基础 - 知识脑图：

  图像滤波
  │
  ├── 核心概念
  │   ├── 卷积：小窗口滑动 + 加权求和
  │   ├── 卷积核：定义权重的小矩阵（奇数大小）
  │   └── 边界处理：图像边缘的填充策略
  │
  ├── 分类方式
  │   ├── 线性 vs 非线性
  │   │   ├── 线性：加权求和（均值、高斯）
  │   │   └── 非线性：排序/条件（中值、双边）
  │   │
  │   └── 低通 vs 高通
  │       ├── 低通：去噪/平滑（模糊效果）
  │       └── 高通：锐化/边缘检测
  │
  ├── 噪声类型
  │   ├── 高斯噪声 → 推荐高斯/均值滤波
  │   ├── 椒盐噪声 → 推荐中值滤波
  │   └── 均匀噪声 → 推荐均值滤波
  │
  └── 核大小影响
      ├── 核越大 → 平滑越强 → 细节损失越多
      └── 核越大 → 计算量越大（约 4 倍增长）
```

> 💡 **关键要点：**
> 1. 卷积 = 小窗口滑动 + 逐元素相乘 + 求和
> 2. 不同的卷积核实现不同的效果（模糊、锐化、边缘检测）
> 3. 核越大模糊越强，但细节丢失越多
> 4. 不同噪声适合不同的滤波器
> 5. 边界处理默认用镜像反射（BORDER_REFLECT_101）

---

👉 [返回章节目录](../图像滤波.md) | [下一节：均值滤波](../02-均值滤波/均值滤波.md)

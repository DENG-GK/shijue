# 均值滤波

> 均值滤波是最简单、最直观的图像平滑方法。它的思路就一句话：**把每个像素替换为周围邻居的平均值**。就像"少数服从多数"一样，少量的噪声点会被周围正常的像素"淹没"。

---

## 📖 理论部分

### 1. 均值滤波的原理

#### 1.1 核心思想

```
均值滤波的直观理解：

  想象一个班级的考试成绩：
  [88, 92, 85, 15, 90, 87, 91]
                   ↑
              有个同学发挥失常（噪声）

  如果我们对每3个相邻成绩取平均：
    位置0：只有右邻 → 保持 88
    位置1：(88+92+85)/3 = 88.3
    位置2：(92+85+15)/3 = 64.0   ← 受到噪声影响
    位置3：(85+15+90)/3 = 63.3   ← 噪声被"稀释"了
    位置4：(15+90+87)/3 = 64.0   ← 受到噪声影响
    ...

  噪声值 15 虽然还有影响，但不再那么突兀了。
  如果用更多的邻居取平均（比如5个），噪声会被进一步稀释。
```

均值滤波的卷积核非常简单——所有元素都相等，总和为1：

```
3×3 均值核：                    5×5 均值核：

┌─────┬─────┬─────┐           ┌─────┬─────┬─────┬─────┬─────┐
│ 1/9 │ 1/9 │ 1/9 │           │ 1/25│ 1/25│ 1/25│ 1/25│ 1/25│
├─────┼─────┼─────┤           ├─────┼─────┼─────┼─────┼─────┤
│ 1/9 │ 1/9 │ 1/9 │           │ 1/25│ 1/25│ 1/25│ 1/25│ 1/25│
├─────┼─────┼─────┤           ├─────┼─────┼─────┼─────┼─────┤
│ 1/9 │ 1/9 │ 1/9 │           │ 1/25│ 1/25│ 1/25│ 1/25│ 1/25│
└─────┴─────┴─────┘           ├─────┼─────┼─────┼─────┼─────┤
                               │ 1/25│ 1/25│ 1/25│ 1/25│ 1/25│
每个权重 = 1/(3×3)             ├─────┼─────┼─────┼─────┼─────┤
         = 1/9 ≈ 0.111        │ 1/25│ 1/25│ 1/25│ 1/25│ 1/25│
                               └─────┴─────┴─────┴─────┴─────┘
                               每个权重 = 1/(5×5) = 1/25 = 0.04
```

> 💡 **核心公式：** 新像素值 = 邻域内所有像素值的算术平均值

#### 1.2 计算过程详解

```
均值滤波逐步计算示例（3×3 核）：

  原始图像：                     卷积核：
  ┌────┬────┬────┬────┬────┐    ┌─────┬─────┬─────┐
  │ 45 │ 50 │ 55 │ 48 │ 52 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    ├─────┼─────┼─────┤
  │ 48 │ 52 │200 │ 50 │ 47 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    ├─────┼─────┼─────┤
  │ 50 │ 46 │ 51 │ 53 │ 49 │    │ 1/9 │ 1/9 │ 1/9 │
  ├────┼────┼────┼────┼────┤    └─────┴─────┴─────┘
  │ 47 │ 53 │ 48 │ 45 │ 51 │
  ├────┼────┼────┼────┼────┤
  │ 51 │ 49 │ 52 │ 50 │ 46 │
  └────┴────┴────┴────┴────┘
              ↑
         这个 200 是噪声！（其他像素都在 45-55 附近）

  计算位置(1,2)处（即噪声点 200）的新值：

  取出 3×3 邻域：
  ┌────┬────┬────┐
  │ 50 │ 55 │ 48 │
  ├────┼────┼────┤
  │ 52 │200 │ 50 │  ← 中心是噪声点
  ├────┼────┼────┤
  │ 46 │ 51 │ 53 │
  └────┴────┴────┘

  新值 = (50+55+48+52+200+50+46+51+53) / 9
       = 605 / 9
       = 67.2 ≈ 67

  原本的噪声值 200 → 变成了 67
  虽然还是比周围的 50 左右偏大，但已经好多了！

  如果用 5×5 的核，噪声会被更多正常像素稀释，
  结果会更接近真实值 ~50。
```

---

### 2. 均值滤波的优缺点

```
均值滤波的优缺点：

  ✅ 优点：
  ┌──────────────────────────────────────────┐
  │ 1. 简单直观，容易理解和实现              │
  │ 2. 计算速度快（只需加法和除法）          │
  │ 3. 对高斯噪声有较好的抑制效果            │
  │ 4. 核越大，平滑效果越强                  │
  └──────────────────────────────────────────┘

  ❌ 缺点：
  ┌──────────────────────────────────────────┐
  │ 1. 会模糊图像边缘和细节（最大的问题！）  │
  │ 2. 对椒盐噪声效果不好（极端值拉偏平均）  │
  │ 3. 核越大，模糊越严重                    │
  │ 4. 所有邻居权重相同，不够"聪明"          │
  └──────────────────────────────────────────┘
```

```
均值滤波模糊边缘的问题：

  原始图像（有清晰边缘）：
  ┌───┬───┬───┬───┬───┬───┐
  │ 0 │ 0 │ 0 │255│255│255│    左边是黑色，右边是白色
  │ 0 │ 0 │ 0 │255│255│255│    中间有一条锐利的边缘
  │ 0 │ 0 │ 0 │255│255│255│
  └───┴───┴───┴───┴───┴───┘

  均值滤波后（3×3核）：
  ┌───┬───┬───┬───┬───┬───┐
  │ 0 │ 0 │ 85│170│255│255│    边缘变成了渐变过渡！
  │ 0 │ 0 │ 85│170│255│255│    锐利的边缘 → 模糊的过渡
  │ 0 │ 0 │ 85│170│255│255│
  └───┴───┴───┴───┴───┴───┘

  → 这就是均值滤波的代价：去噪的同时，边缘也变模糊了
```

---

### 3. OpenCV 中的均值滤波函数

OpenCV 提供了两种均值滤波方式：

| 函数 | 说明 |
|------|------|
| `cv2.blur()` | 标准均值滤波（最常用） |
| `cv2.boxFilter()` | 方框滤波（可选是否归一化） |

```
函数参数详解：

  cv2.blur(src, ksize)
  ├── src   : 输入图像
  └── ksize : 核大小，格式为 (宽, 高)，如 (3,3)、(5,5)

  cv2.boxFilter(src, ddepth, ksize, normalize=True)
  ├── src       : 输入图像
  ├── ddepth    : 输出深度，-1 表示与输入相同
  ├── ksize     : 核大小
  └── normalize : 是否归一化
      ├── True  : 除以核面积（= 均值滤波）
      └── False : 不除（= 求和，结果会很大，可能溢出！）
```

```
blur() 和 boxFilter() 的关系：

  cv2.blur(img, (5,5))
      ↕  完全等价
  cv2.boxFilter(img, -1, (5,5), normalize=True)

  而 normalize=False 的 boxFilter 计算的是"区域求和"，
  结果 = 邻域内所有像素之和（不除以数量），可用于特殊计算。
```

---

## 💻 代码部分

### 代码示例 1：基础均值滤波

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# ========== cv2.blur() 基本用法 ==========
# 3×3 均值滤波
blur_3 = cv2.blur(img, (3, 3))

# 5×5 均值滤波
blur_5 = cv2.blur(img, (5, 5))

# 9×9 均值滤波
blur_9 = cv2.blur(img, (9, 9))

# 15×15 均值滤波（模糊效果很明显）
blur_15 = cv2.blur(img, (15, 15))

# 显示结果对比
cv2.imshow("Original", img)
cv2.imshow("Blur 3x3", blur_3)
cv2.imshow("Blur 5x5", blur_5)
cv2.imshow("Blur 9x9", blur_9)
cv2.imshow("Blur 15x15", blur_15)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 2：boxFilter 的 normalize 参数

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# normalize=True → 均值滤波（和 blur 一样）
box_norm = cv2.boxFilter(img, -1, (5, 5), normalize=True)

# normalize=False → 求和滤波（不除以核面积）
# 注意：结果可能非常大，uint8 会溢出截断到 255
box_sum = cv2.boxFilter(img, -1, (5, 5), normalize=False)

# 使用更大深度避免溢出
box_sum_float = cv2.boxFilter(img, cv2.CV_64F, (5, 5), normalize=False)
print(f"归一化后最大值：{box_norm.max()}")        # ≤ 255
print(f"未归一化最大值：{box_sum_float.max()}")    # 可能很大

# 显示
cv2.imshow("Original", img)
cv2.imshow("boxFilter normalize=True", box_norm)
cv2.imshow("boxFilter normalize=False (clipped)", box_sum)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

### 代码示例 3：对噪声图像进行均值滤波

```python
import cv2
import numpy as np

def add_gaussian_noise(image, mean=0, sigma=25):
    """添加高斯噪声"""
    noise = np.random.normal(mean, sigma, image.shape).astype(np.float64)
    noisy = image.astype(np.float64) + noise
    return np.clip(noisy, 0, 255).astype(np.uint8)

def add_salt_pepper_noise(image, amount=0.05):
    """添加椒盐噪声"""
    noisy = image.copy()
    h, w = image.shape[:2]
    num_noise = int(h * w * amount)
    # 盐（白点）
    for _ in range(num_noise):
        y, x = np.random.randint(0, h), np.random.randint(0, w)
        noisy[y, x] = 255
    # 胡椒（黑点）
    for _ in range(num_noise):
        y, x = np.random.randint(0, h), np.random.randint(0, w)
        noisy[y, x] = 0
    return noisy

# 读取灰度图像
img = cv2.imread("test.jpg", cv2.IMREAD_GRAYSCALE)

# ========== 对高斯噪声进行均值滤波 ==========
gaussian_noisy = add_gaussian_noise(img, sigma=30)

gauss_blur3 = cv2.blur(gaussian_noisy, (3, 3))
gauss_blur5 = cv2.blur(gaussian_noisy, (5, 5))
gauss_blur9 = cv2.blur(gaussian_noisy, (9, 9))

cv2.imshow("Original", img)
cv2.imshow("Gaussian Noisy", gaussian_noisy)
cv2.imshow("Blur 3x3", gauss_blur3)
cv2.imshow("Blur 5x5", gauss_blur5)
cv2.imshow("Blur 9x9", gauss_blur9)
cv2.waitKey(0)

# ========== 对椒盐噪声进行均值滤波 ==========
sp_noisy = add_salt_pepper_noise(img, amount=0.05)

sp_blur3 = cv2.blur(sp_noisy, (3, 3))
sp_blur5 = cv2.blur(sp_noisy, (5, 5))
sp_blur9 = cv2.blur(sp_noisy, (9, 9))

cv2.imshow("Salt-Pepper Noisy", sp_noisy)
cv2.imshow("SP Blur 3x3", sp_blur3)
cv2.imshow("SP Blur 5x5", sp_blur5)
cv2.imshow("SP Blur 9x9", sp_blur9)
cv2.waitKey(0)
cv2.destroyAllWindows()

# 观察结论：
# - 均值滤波对高斯噪声效果不错（噪声被平均掉了）
# - 均值滤波对椒盐噪声效果一般（黑白极端值拖偏了平均值）
# - 核越大，去噪越好，但图像也越模糊
```

---

### 代码示例 4：均值滤波的去噪效果量化评估

```python
import cv2
import numpy as np

def psnr(original, processed):
    """计算峰值信噪比 (PSNR)，值越大说明越接近原图"""
    mse = np.mean((original.astype(np.float64) - processed.astype(np.float64)) ** 2)
    if mse == 0:
        return float('inf')
    return 10 * np.log10(255.0 ** 2 / mse)

# 读取原始清晰图像
img = cv2.imread("test.jpg", cv2.IMREAD_GRAYSCALE)

# 添加高斯噪声
noisy = img.astype(np.float64) + np.random.normal(0, 25, img.shape)
noisy = np.clip(noisy, 0, 255).astype(np.uint8)

print(f"噪声图像 PSNR：{psnr(img, noisy):.2f} dB")

# 不同核大小的去噪效果
for k in [3, 5, 7, 9, 11, 15]:
    denoised = cv2.blur(noisy, (k, k))
    p = psnr(img, denoised)
    print(f"均值滤波 {k:2d}×{k:2d} → PSNR：{p:.2f} dB")

# 典型输出：
# 噪声图像 PSNR：20.18 dB
# 均值滤波  3× 3 → PSNR：24.82 dB   ← 明显改善
# 均值滤波  5× 5 → PSNR：25.93 dB   ← 继续改善
# 均值滤波  7× 7 → PSNR：25.78 dB   ← 开始下降！
# 均值滤波  9× 9 → PSNR：25.12 dB   ← 过度模糊
# 均值滤波 11×11 → PSNR：24.31 dB
# 均值滤波 15×15 → PSNR：23.05 dB
#
# 结论：核不是越大越好！存在一个最佳平衡点（通常在 5×5 左右）
```

---

### 代码示例 5：非方形核的均值滤波

```python
import cv2
import numpy as np

# 读取图像
img = cv2.imread("test.jpg")

# 核不一定是正方形的！可以是长方形

# 水平方向模糊（宽核）：水平方向平滑，垂直方向保留
blur_h = cv2.blur(img, (15, 1))

# 垂直方向模糊（高核）：垂直方向平滑，水平方向保留
blur_v = cv2.blur(img, (1, 15))

# 正方形模糊（对比用）
blur_sq = cv2.blur(img, (15, 15))

# 显示
cv2.imshow("Original", img)
cv2.imshow("Horizontal Blur (15,1)", blur_h)   # 有运动模糊效果
cv2.imshow("Vertical Blur (1,15)", blur_v)     # 像下雨的效果
cv2.imshow("Square Blur (15,15)", blur_sq)     # 均匀模糊
cv2.waitKey(0)
cv2.destroyAllWindows()

# 水平核 (15,1)：模拟水平运动模糊
# 垂直核 (1,15)：模拟垂直运动模糊/雨滴效果
# 这在创意图像处理中很有用！
```

---

## 📝 本节小结

```
均值滤波 - 知识脑图：

  均值滤波 (cv2.blur / cv2.boxFilter)
  │
  ├── 原理
  │   ├── 邻域内所有像素取算术平均
  │   ├── 卷积核：所有元素相等，总和为 1
  │   └── 核大小：(宽, 高)，通常为奇数正方形
  │
  ├── 函数
  │   ├── cv2.blur(img, (k,k))         ← 最常用
  │   └── cv2.boxFilter(img, -1, (k,k), normalize=True/False)
  │
  ├── 优点
  │   ├── 简单快速
  │   ├── 对高斯噪声效果好
  │   └── 容易理解和实现
  │
  ├── 缺点
  │   ├── 模糊边缘和细节
  │   ├── 对椒盐噪声效果差
  │   └── 所有像素权重相同（不够智能）
  │
  └── 技巧
      ├── 核大小有最佳平衡点（不是越大越好）
      └── 非方形核可实现方向性模糊
```

> 💡 **关键要点：**
> 1. `cv2.blur(img, (5,5))` 是最常用的均值滤波调用
> 2. 核越大平滑效果越强，但边缘也越模糊
> 3. 均值滤波对高斯噪声效果好，对椒盐噪声效果差
> 4. 所有邻居"一视同仁"是优点也是缺点 → 下一节的高斯滤波会改进这一点！

---

👉 [上一节：滤波理论基础](../01-滤波理论基础/滤波理论基础.md) | [返回章节目录](../图像滤波.md) | [下一节：高斯滤波](../03-高斯滤波/高斯滤波.md)

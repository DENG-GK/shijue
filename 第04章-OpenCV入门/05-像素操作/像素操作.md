# 像素操作

> 像素是图像的最小单元，掌握像素级别的操作，你就真正拥有了对图像"逐点控制"的能力。本节将从单个像素的读写、通道拆分合并、图像算术运算到位运算，全面覆盖像素级操作的核心技能。

---

## 📖 理论部分

### 1. 像素访问与修改

#### 1.1 灰度图像的像素操作

灰度图像是一个二维数组，每个元素就是一个像素值（0~255）：

```python
import cv2
import numpy as np

# 创建灰度图像
gray = np.zeros((100, 150), dtype=np.uint8)

# 读取像素值：img[行, 列] = img[y, x]
pixel = gray[50, 75]
print(f"位置(50,75)的像素值: {pixel}")   # 0

# 修改单个像素
gray[50, 75] = 255   # 设为白色

# 修改一个区域（用切片）
gray[20:40, 30:60] = 200   # 矩形区域设为灰色

# 用条件修改
gray[gray < 100] = 0       # 所有暗像素变为黑色
```

```
像素坐标系统：

    x (列)  →
  ┌──────────────────┐
  │ (0,0)  (0,1) ... │  y (行)
  │ (1,0)  (1,1) ... │  ↓
  │  ...    ...      │
  └──────────────────┘

  img[y, x] ← 注意：行在前，列在后！
  等同于 img[row, col]
```

> ⚠️ **关键提醒：** `img[y, x]` 中 y 是行号（垂直方向），x 是列号（水平方向）。这和数学中的 (x, y) 坐标是**反过来**的！

#### 1.2 彩色图像的像素操作

彩色图像是三维数组，每个像素是一个 [B, G, R] 三元组：

```python
color = np.zeros((100, 150, 3), dtype=np.uint8)

# 读取像素（返回 BGR 数组）
pixel = color[50, 75]
print(f"像素值: {pixel}")   # [0 0 0]

b, g, r = color[50, 75]
print(f"B={b}, G={g}, R={r}")

# 修改像素
color[50, 75] = [255, 0, 0]     # 蓝色（BGR！）
color[50, 76] = [0, 255, 0]     # 绿色
color[50, 77] = [0, 0, 255]     # 红色

# 访问单个通道的值
blue_value = color[50, 75, 0]    # B 通道
green_value = color[50, 75, 1]   # G 通道
red_value = color[50, 75, 2]     # R 通道

# 修改区域
color[20:60, 30:80] = [0, 255, 255]   # 矩形区域设为黄色
```

#### 1.3 逐像素操作的性能问题

```python
# ❌ 用 Python 循环逐像素操作（非常慢！）
img = np.zeros((480, 640), dtype=np.uint8)
for y in range(480):
    for x in range(640):
        img[y, x] = (x + y) % 256
# 这在 480×640 的图上需要遍历 307,200 次！

# ✅ 用 NumPy 向量化操作（快几十到几百倍！）
ys = np.arange(480).reshape(-1, 1)   # 列向量
xs = np.arange(640).reshape(1, -1)   # 行向量
img = ((xs + ys) % 256).astype(np.uint8)
# 利用广播机制，一行搞定，速度提升巨大！
```

> 💡 **经验法则：** 能用 NumPy 向量化就不要用 Python 循环。在图像处理中，这往往意味着 **几十倍甚至上百倍** 的性能差异。

---

### 2. 通道操作

#### 2.1 通道拆分

```python
import cv2
import numpy as np

# 创建彩色图像
color = np.zeros((200, 300, 3), dtype=np.uint8)
color[:, :100] = [255, 0, 0]      # 左1/3 蓝色
color[:, 100:200] = [0, 255, 0]   # 中1/3 绿色
color[:, 200:] = [0, 0, 255]      # 右1/3 红色

# 方式1：OpenCV 拆分（推荐）
b, g, r = cv2.split(color)
print(f"B通道 shape: {b.shape}")   # (200, 300)
print(f"G通道 shape: {g.shape}")   # (200, 300)
print(f"R通道 shape: {r.shape}")   # (200, 300)

# 方式2：NumPy 索引（性能更好，推荐！）
b = color[:, :, 0]   # B 通道
g = color[:, :, 1]   # G 通道
r = color[:, :, 2]   # R 通道
```

> 💡 **性能提示：** `cv2.split()` 会创建三个独立副本，而 NumPy 索引 `color[:,:,0]` 返回的是**视图**（共享内存）。如果只是读取通道值，NumPy 索引更高效；如果需要独立修改，用 `cv2.split()` 或 `.copy()`。

#### 2.2 通道合并

```python
# 把三个单通道合成一张彩色图
merged = cv2.merge([b, g, r])
print(f"合并后 shape: {merged.shape}")   # (200, 300, 3)

# NumPy 方式
merged2 = np.stack([b, g, r], axis=2)
# 或
merged3 = np.dstack([b, g, r])
```

#### 2.3 通道操作的常见应用

```python
import cv2
import numpy as np

img = np.random.randint(0, 256, (200, 300, 3), dtype=np.uint8)

# --- 应用1：BGR 转 RGB（用于 Matplotlib 显示）---
rgb = img[:, :, ::-1]         # 通道反转
# 等价于 cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# --- 应用2：只保留某个通道 ---
# 只保留红色通道（其他通道设为0）
red_only = np.zeros_like(img)
red_only[:, :, 2] = img[:, :, 2]   # 只复制 R 通道

# 只保留蓝色通道
blue_only = np.zeros_like(img)
blue_only[:, :, 0] = img[:, :, 0]

# --- 应用3：手动实现灰度化 ---
# 标准灰度公式：Gray = 0.299*R + 0.587*G + 0.114*B
b, g, r = img[:, :, 0], img[:, :, 1], img[:, :, 2]
gray_manual = (0.299 * r + 0.587 * g + 0.114 * b).astype(np.uint8)
# 等价于 cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# --- 应用4：交换通道 ---
# BGR → BRG
brg = img[:, :, [0, 2, 1]]
```

```
通道拆分与合并示意：

彩色图像 (H, W, 3)
┌─────────────┐
│ [B, G, R]   │     cv2.split()
│ [B, G, R]   │  ─────────────→  B通道(H,W) + G通道(H,W) + R通道(H,W)
│ [B, G, R]   │
│   ...       │  ←─────────────  cv2.merge([B, G, R])
└─────────────┘     cv2.merge()
```

---

### 3. 图像算术运算

#### 3.1 饱和运算 vs 取模运算（复习强化）

这是 OpenCV 最重要的概念之一，值得再次强调：

```python
import cv2
import numpy as np

a = np.array([[200]], dtype=np.uint8)
b = np.array([[100]], dtype=np.uint8)

# NumPy 加法：取模（溢出绕回）
print(a + b)                  # [[44]]  → (200+100) % 256 = 44

# OpenCV 加法：饱和（溢出截断到255）
print(cv2.add(a, b))         # [[255]] → min(200+100, 255) = 255

# NumPy 减法：取模（负数绕回）
print(b - a)                  # [[156]] → (100-200) % 256 = 156

# OpenCV 减法：饱和（负数截断到0）
print(cv2.subtract(b, a))    # [[0]]   → max(100-200, 0) = 0
```

```
加法对比示意：

像素值 200 + 像素值 100 = ?

NumPy:   200 + 100 = 300 → 300 % 256 = 44   ← 变暗了！错误！
                          ┌─────┐
         300 ─ 超过256 ─→ │ 取模 │ → 44
                          └─────┘

OpenCV:  200 + 100 = 300 → min(300, 255) = 255  ← 变白了！正确！
                          ┌─────┐
         300 ─ 超过255 ─→ │ 截断 │ → 255
                          └─────┘

减法对比：
NumPy:   50 - 200 = -150 → (-150 + 256) = 106  ← 变亮了！错误！
OpenCV:  50 - 200 = -150 → max(-150, 0) = 0     ← 变黑了！正确！
```

#### 3.2 亮度调整

```python
import cv2
import numpy as np

img = np.random.randint(50, 200, (200, 300, 3), dtype=np.uint8)

# 增加亮度（加一个标量）
bright = cv2.add(img, np.full_like(img, 50))
# 或更简洁：
bright = cv2.add(img, (50, 50, 50, 0))  # 注意需要4个元素（最后一个被忽略）

# 降低亮度
dark = cv2.subtract(img, np.full_like(img, 50))

# 调整对比度（乘以系数）
# 对比度增强：像素值 × 系数 + 偏移
alpha = 1.5   # 对比度系数（>1 增强，<1 减弱）
beta = 0      # 亮度偏移
enhanced = cv2.convertScaleAbs(img, alpha=alpha, beta=beta)
# convertScaleAbs: 先乘 alpha，再加 beta，最后取绝对值并转 uint8
```

#### 3.3 图像融合：cv2.addWeighted()

两张图像按权重混合，实现渐变过渡效果：

```python
# dst = α × img1 + β × img2 + γ
# 通常 α + β = 1，γ = 0

img1 = np.random.randint(0, 256, (200, 300, 3), dtype=np.uint8)
img2 = np.random.randint(0, 256, (200, 300, 3), dtype=np.uint8)
# 注意：两张图必须尺寸和类型完全相同！

# 各占一半
blended = cv2.addWeighted(img1, 0.5, img2, 0.5, 0)

# img1 占主导
blended_1 = cv2.addWeighted(img1, 0.7, img2, 0.3, 0)

# img2 占主导
blended_2 = cv2.addWeighted(img1, 0.3, img2, 0.7, 0)

# 加一点整体亮度偏移
blended_bright = cv2.addWeighted(img1, 0.5, img2, 0.5, 30)
```

```
图像融合公式：

  dst = α × img1 + β × img2 + γ

  ┌─────────┐       ┌─────────┐       ┌─────────┐
  │  img1   │ × α + │  img2   │ × β + │    γ    │ = 融合结果
  │         │       │         │       │ (亮度)  │
  └─────────┘       └─────────┘       └─────────┘

  例：α=0.7, β=0.3, γ=0
  → 70% 的 img1 + 30% 的 img2
```

---

### 4. 位运算（掩膜操作基础）

位运算在图像掩膜操作中**极其重要**，是后续很多高级操作的基础。

#### 4.1 四种基本位运算

```python
import cv2
import numpy as np

# 创建两个简单的二值图像
a = np.zeros((200, 200), dtype=np.uint8)
b = np.zeros((200, 200), dtype=np.uint8)

# a: 左半区域为白色
a[:, :100] = 255

# b: 上半区域为白色
b[:100, :] = 255

# 位与 AND：两个都是白色才是白色
and_result = cv2.bitwise_and(a, b)

# 位或 OR：任一个是白色就是白色
or_result = cv2.bitwise_or(a, b)

# 位异或 XOR：两个不同才是白色
xor_result = cv2.bitwise_xor(a, b)

# 位非 NOT：黑变白，白变黑
not_result = cv2.bitwise_not(a)
```

```
位运算示意（200×200 图像）：

图像 a（左半白色）：       图像 b（上半白色）：
┌──────┬──────┐           ┌─────────────┐
│██████│      │           │█████████████│
│██████│      │           │█████████████│
│██████│      │           │             │
│██████│      │           │             │
└──────┴──────┘           └─────────────┘

AND（交集）：              OR（并集）：
┌──────┬──────┐           ┌─────────────┐
│██████│      │           │█████████████│
│██████│      │           │█████████████│
│      │      │           │██████│      │
│      │      │           │██████│      │
└──────┴──────┘           └─────────────┘
 左上角                    L形区域

XOR（不同的部分）：        NOT a（反转）：
┌──────┬──────┐           ┌──────┬──────┐
│      │██████│           │      │██████│
│      │██████│           │      │██████│
│██████│      │           │      │██████│
│██████│      │           │      │██████│
└──────┴──────┘           └──────┴──────┘
```

#### 4.2 掩膜应用：提取感兴趣区域（ROI）

```python
import cv2
import numpy as np

# 原始图像
img = np.random.randint(50, 200, (200, 300, 3), dtype=np.uint8)

# 创建掩膜（圆形区域）
mask = np.zeros((200, 300), dtype=np.uint8)
cv2.circle(mask, (150, 100), 80, 255, -1)   # 在中心画一个白色实心圆

# 用掩膜提取区域
# bitwise_and 配合 mask 参数：只保留掩膜为白色的区域
result = cv2.bitwise_and(img, img, mask=mask)
# mask为0的位置 → 结果为0（黑色）
# mask为255的位置 → 保留原图像素

print(f"原图 shape: {img.shape}")
print(f"掩膜 shape: {mask.shape}")
print(f"结果 shape: {result.shape}")
```

```
掩膜提取示意：

  原始图像        掩膜（mask）      提取结果
┌───────────┐   ┌───────────┐   ┌───────────┐
│ xxxxxxxxx │   │    ****   │   │    xxxx   │
│ xxxxxxxxx │   │  ********  │  │  xxxxxxx  │
│ xxxxxxxxx │ & │ ********** │ = │ xxxxxxxxx │
│ xxxxxxxxx │   │  ********  │   │  xxxxxxx  │
│ xxxxxxxxx │   │    ****   │   │    xxxx   │
└───────────┘   └───────────┘   └───────────┘
  x=有内容        *=白色区域      只保留圆形区域
```

#### 4.3 Logo 叠加（位运算的经典应用）

```python
import cv2
import numpy as np

# 模拟场景：把一个小logo叠加到大图上
# 创建大图（背景）
background = np.random.randint(100, 200, (400, 600, 3), dtype=np.uint8)

# 创建小logo（前景）
logo = np.zeros((80, 80, 3), dtype=np.uint8)
cv2.circle(logo, (40, 40), 35, (0, 0, 255), -1)   # 红色圆形logo
cv2.putText(logo, "CV", (15, 50), cv2.FONT_HERSHEY_SIMPLEX,
            0.8, (255, 255, 255), 2)

# 步骤1：创建 logo 的掩膜
logo_gray = cv2.cvtColor(logo, cv2.COLOR_BGR2GRAY)
_, mask = cv2.threshold(logo_gray, 10, 255, cv2.THRESH_BINARY)
mask_inv = cv2.bitwise_not(mask)

# 步骤2：在背景中挖出 logo 大小的区域
rows, cols = logo.shape[:2]
roi = background[10:10+rows, 10:10+cols]   # 左上角区域

# 步骤3：用掩膜分别提取背景和前景
bg_part = cv2.bitwise_and(roi, roi, mask=mask_inv)   # 挖掉logo形状
fg_part = cv2.bitwise_and(logo, logo, mask=mask)      # 只保留logo

# 步骤4：合并
combined = cv2.add(bg_part, fg_part)
background[10:10+rows, 10:10+cols] = combined
```

```
Logo 叠加流程：

1. 原始 ROI           2. 掩膜 mask         3. 反掩膜 mask_inv
┌──────────┐         ┌──────────┐         ┌──────────┐
│ 背景内容  │         │   ****   │         │ **    ** │
│ 背景内容  │         │ ******** │         │          │
│ 背景内容  │         │ ******** │         │          │
│ 背景内容  │         │   ****   │         │ **    ** │
└──────────┘         └──────────┘         └──────────┘

4. bg_part              5. fg_part           6. 最终结果
   (背景去掉logo区)       (只有logo)            (合并)
┌──────────┐         ┌──────────┐         ┌──────────┐
│ 背景  背景│         │   logo   │         │ 背景logo │
│          │         │ logologol│         │ logo背logo│
│ 背景  背景│         │   logo   │         │ 背景logo │
└──────────┘         └──────────┘         └──────────┘
```

---

## 💻 代码实战

### 实战练习：像素操作全流程

```python
# ===================================================================
# 实战练习：像素操作全流程
# 目标：掌握像素访问、通道操作、算术运算和位运算
# ===================================================================

import cv2
import numpy as np

# ---------- 1. 像素级绘图 ----------
print("=" * 55)
print("🎨 第一步：像素级绘图")
print("=" * 55)

canvas = np.zeros((200, 300, 3), dtype=np.uint8)

# 用像素级操作画彩色条纹
stripe_width = 50
colors_bgr = [
    [0, 0, 255],     # 红色
    [0, 165, 255],   # 橙色
    [0, 255, 255],   # 黄色
    [0, 255, 0],     # 绿色
    [255, 0, 0],     # 蓝色
    [128, 0, 128],   # 紫色
]

for i, color in enumerate(colors_bgr):
    x_start = i * stripe_width
    x_end = min((i + 1) * stripe_width, 300)
    canvas[:, x_start:x_end] = color

print(f"  画布 shape: {canvas.shape}")
print(f"  左上角像素: {canvas[0, 0]} (红色)")
print(f"  中间像素:   {canvas[100, 150]} (黄色)")

# 画渐变效果
gradient = np.zeros((100, 256, 3), dtype=np.uint8)
for x in range(256):
    gradient[:, x] = [x, 0, 255 - x]   # 从红到蓝的渐变

print(f"  渐变图 shape: {gradient.shape}")

# ---------- 2. 通道操作 ----------
print("\n" + "=" * 55)
print("🔬 第二步：通道拆分与合并")
print("=" * 55)

# 拆分通道
b, g, r = cv2.split(canvas)
print(f"  B通道: shape={b.shape}, 唯一值={np.unique(b)[:5]}...")
print(f"  G通道: shape={g.shape}, 唯一值={np.unique(g)[:5]}...")
print(f"  R通道: shape={r.shape}, 唯一值={np.unique(r)[:5]}...")

# 通道交换：BGR → RGB
rgb_canvas = cv2.merge([r, g, b])
print(f"\n  BGR→RGB: 原(0,0)={canvas[0,0]} → RGB(0,0)={rgb_canvas[0,0]}")

# 只保留红色通道
red_only = np.zeros_like(canvas)
red_only[:, :, 2] = canvas[:, :, 2]
print(f"  只保留R通道: (0,0)={red_only[0,0]}")

# 手动灰度化
gray_manual = (0.299 * r.astype(float) +
               0.587 * g.astype(float) +
               0.114 * b.astype(float)).astype(np.uint8)
gray_cv = cv2.cvtColor(canvas, cv2.COLOR_BGR2GRAY)
print(f"  手动灰度 vs OpenCV灰度: "
      f"差异={np.max(np.abs(gray_manual.astype(int) - gray_cv.astype(int)))}")

# ---------- 3. 算术运算 ----------
print("\n" + "=" * 55)
print("⚡ 第三步：算术运算对比")
print("=" * 55)

img1 = np.random.randint(100, 200, (100, 100, 3), dtype=np.uint8)
img2 = np.random.randint(100, 200, (100, 100, 3), dtype=np.uint8)

# NumPy vs OpenCV 加法
np_add = img1 + img2
cv_add = cv2.add(img1, img2)

print(f"  img1[0,0]: {img1[0,0]}")
print(f"  img2[0,0]: {img2[0,0]}")
print(f"  NumPy加法: {np_add[0,0]}  (取模: {img1[0,0].astype(int) + img2[0,0].astype(int)} % 256)")
print(f"  OpenCV加法: {cv_add[0,0]} (饱和: min({img1[0,0].astype(int) + img2[0,0].astype(int)}, 255))")

# 溢出像素统计
overflow_pixels = np.sum(img1.astype(int) + img2.astype(int) > 255)
total_pixels = img1.size
print(f"\n  溢出像素: {overflow_pixels}/{total_pixels} "
      f"({overflow_pixels/total_pixels*100:.1f}%)")
print(f"  → 这些像素用NumPy加法会得到错误结果！")

# ---------- 4. 亮度与对比度调整 ----------
print("\n" + "=" * 55)
print("💡 第四步：亮度与对比度")
print("=" * 55)

img = np.random.randint(50, 200, (100, 100, 3), dtype=np.uint8)
original_mean = np.mean(img)
print(f"  原始亮度: 均值={original_mean:.1f}")

# 增加亮度
bright = cv2.add(img, np.full_like(img, 50))
print(f"  +50亮度:  均值={np.mean(bright):.1f}")

# 降低亮度
dark = cv2.subtract(img, np.full_like(img, 50))
print(f"  -50亮度:  均值={np.mean(dark):.1f}")

# 增强对比度
enhanced = cv2.convertScaleAbs(img, alpha=1.5, beta=0)
print(f"  1.5x对比度: 均值={np.mean(enhanced):.1f}, "
      f"标准差={np.std(enhanced):.1f} (原={np.std(img):.1f})")

# ---------- 5. 图像融合 ----------
print("\n" + "=" * 55)
print("🎭 第五步：图像融合")
print("=" * 55)

img_a = np.random.randint(0, 128, (100, 100, 3), dtype=np.uint8)   # 较暗
img_b = np.random.randint(128, 256, (100, 100, 3), dtype=np.uint8) # 较亮

alphas = [0.0, 0.25, 0.5, 0.75, 1.0]
print(f"  {'α':>5s} {'β':>5s} {'融合均值':>10s}")
print("  " + "-" * 25)
for alpha in alphas:
    beta = 1.0 - alpha
    blended = cv2.addWeighted(img_a, alpha, img_b, beta, 0)
    print(f"  {alpha:>5.2f} {beta:>5.2f} {np.mean(blended):>10.1f}")

# ---------- 6. 位运算 ----------
print("\n" + "=" * 55)
print("🔧 第六步：位运算")
print("=" * 55)

# 创建两个形状
shape_a = np.zeros((100, 100), dtype=np.uint8)
shape_b = np.zeros((100, 100), dtype=np.uint8)
cv2.rectangle(shape_a, (10, 10), (70, 70), 255, -1)    # 矩形
cv2.circle(shape_b, (60, 50), 40, 255, -1)              # 圆形

# 位运算
and_result = cv2.bitwise_and(shape_a, shape_b)
or_result = cv2.bitwise_or(shape_a, shape_b)
xor_result = cv2.bitwise_xor(shape_a, shape_b)
not_a = cv2.bitwise_not(shape_a)

print(f"  形状A 白色像素: {np.sum(shape_a == 255)}")
print(f"  形状B 白色像素: {np.sum(shape_b == 255)}")
print(f"  AND (交集):    {np.sum(and_result == 255)} 像素")
print(f"  OR  (并集):    {np.sum(or_result == 255)} 像素")
print(f"  XOR (异或):    {np.sum(xor_result == 255)} 像素")
print(f"  NOT A (反转):  {np.sum(not_a == 255)} 像素")

# 验证集合关系：AND + XOR = OR
or_check = cv2.add(and_result, xor_result)
print(f"\n  验证: AND + XOR == OR? {np.array_equal(or_check, or_result)}")

# ---------- 7. 掩膜应用 ----------
print("\n" + "=" * 55)
print("🎭 第七步：掩膜提取")
print("=" * 55)

# 创建彩色图像
img = np.random.randint(50, 200, (200, 200, 3), dtype=np.uint8)

# 创建圆形掩膜
mask = np.zeros((200, 200), dtype=np.uint8)
cv2.circle(mask, (100, 100), 80, 255, -1)

# 提取
masked = cv2.bitwise_and(img, img, mask=mask)

# 统计
total_pixels = 200 * 200
mask_pixels = np.sum(mask == 255)
black_pixels = np.sum(np.all(masked == 0, axis=2))

print(f"  总像素:     {total_pixels}")
print(f"  掩膜区域:   {mask_pixels} 像素 ({mask_pixels/total_pixels*100:.1f}%)")
print(f"  提取后黑色: {black_pixels} 像素")
print(f"  提取后有色: {total_pixels - black_pixels} 像素")

print("\n✅ 像素操作练习完成！")
```

**运行输出示例：**

```
=======================================================
🎨 第一步：像素级绘图
=======================================================
  画布 shape: (200, 300, 3)
  左上角像素: [  0   0 255] (红色)
  中间像素:   [  0 255 255] (黄色)

=======================================================
⚡ 第三步：算术运算对比
=======================================================
  img1[0,0]: [142 168 115]
  img2[0,0]: [175 143 128]
  NumPy加法: [ 61  55 243]  (取模)
  OpenCV加法: [255 255 243] (饱和)

  溢出像素: 19892/30000 (66.3%)
  → 这些像素用NumPy加法会得到错误结果！

=======================================================
🎭 第五步：图像融合
=======================================================
   α     β     融合均值
  -------------------------
   0.00  1.00      191.0
   0.25  0.75      159.0
   0.50  0.50      127.5
   0.75  0.25       96.0
   1.00  0.00       63.5

=======================================================
🔧 第六步：位运算
=======================================================
  形状A 白色像素: 3600
  形状B 白色像素: 4980
  AND (交集):    2320 像素
  OR  (并集):    6260 像素
  XOR (异或):    3940 像素

  验证: AND + XOR == OR? True
```

---

## 🚨 常见问题与易错点

### Q1: img[y, x] 还是 img[x, y]？

```python
# 始终是 img[y, x] = img[行, 列]
# y = 行号 = 垂直方向
# x = 列号 = 水平方向

img = np.zeros((100, 200, 3), dtype=np.uint8)   # 100行 200列

# ✅ 正确
img[50, 100] = [255, 0, 0]    # 第50行第100列

# ❌ 常见错误：把 x, y 搞反
# 如果图像是 100×200，那么 img[150, 50] 会报错！
# 因为行只有100个（0~99），150超出范围

# 记忆方法：
# img[y, x] = img[row, col]
# shape = (height, width) = (行数, 列数)
```

### Q2: cv2.split() 和 NumPy 索引哪个好？

```python
img = np.random.randint(0, 256, (480, 640, 3), dtype=np.uint8)

# cv2.split() → 创建副本（独立内存）
b, g, r = cv2.split(img)
b[0, 0] = 0           # 不影响原图

# NumPy 索引 → 视图（共享内存）
b_view = img[:, :, 0]
b_view[0, 0] = 0      # 会修改原图！

# 需要独立修改 → 用 cv2.split() 或 .copy()
# 只是读取 → 用 NumPy 索引（更快）
```

### Q3: addWeighted 两张图尺寸不同会怎样？

```python
img1 = np.zeros((100, 200, 3), dtype=np.uint8)
img2 = np.zeros((200, 300, 3), dtype=np.uint8)

# ❌ 尺寸不同会报错！
# cv2.addWeighted(img1, 0.5, img2, 0.5, 0)
# → error: The operation is neither 'array op array' ...

# ✅ 先调整到相同尺寸
img2_resized = cv2.resize(img2, (200, 100))   # 注意：resize 参数是 (宽, 高)
blended = cv2.addWeighted(img1, 0.5, img2_resized, 0.5, 0)
```

### Q4: 位运算的 mask 参数是什么意思？

```python
img = np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)
mask = np.zeros((100, 100), dtype=np.uint8)
mask[20:80, 20:80] = 255

# 没有 mask：对所有像素做运算
result1 = cv2.bitwise_and(img, img)           # 等于原图

# 有 mask：只对 mask=255 的像素做运算，其余为0
result2 = cv2.bitwise_and(img, img, mask=mask)
# mask=255 的位置 → 保留原像素
# mask=0 的位置 → 输出为 0（黑色）

# mask 必须是单通道 uint8，尺寸和图像相同
```

---

## 🎯 总结

本节学习了 OpenCV 的像素级操作：

✅ **像素访问**：`img[y, x]` 读写像素，y=行，x=列，注意顺序
✅ **通道拆分**：`cv2.split()` 或 `img[:,:,0]`，前者创建副本，后者是视图
✅ **通道合并**：`cv2.merge([b,g,r])` 或 `np.dstack([b,g,r])`
✅ **通道应用**：BGR→RGB 转换、单通道提取、手动灰度化
✅ **饱和运算**：`cv2.add()` / `cv2.subtract()` → 图像处理必须用这个
✅ **亮度对比度**：加减标量调亮度，`convertScaleAbs` 调对比度
✅ **图像融合**：`cv2.addWeighted(img1, α, img2, β, γ)` → α+β 通常为 1
✅ **位运算**：`bitwise_and/or/xor/not` → 掩膜操作的核心
✅ **掩膜提取**：`cv2.bitwise_and(img, img, mask=mask)` → 只保留白色区域
✅ **性能原则**：向量化操作 >> Python 循环

> 🔑 **核心要点：** 图像加减法**必须用 cv2.add() / cv2.subtract()**（饱和运算），避免 NumPy 取模导致的溢出错误。位运算 + 掩膜是 OpenCV 中提取感兴趣区域的标准方法，Logo 叠加就是经典应用场景。

**下一步：**
👉 [第05章 - 图像基础操作](../../第05章-图像基础操作/图像基础操作.md)

---

## 📚 参考资料

- [OpenCV-Python 图像基本操作](https://docs.opencv.org/4.x/d3/df2/tutorial_py_basic_ops.html)
- [OpenCV-Python 图像算术运算](https://docs.opencv.org/4.x/d0/d86/tutorial_py_image_arithmetics.html)
- [NumPy 数组索引](https://numpy.org/doc/stable/reference/arrays.indexing.html)
